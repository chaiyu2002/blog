<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老兵驿站</title>
  
  <subtitle>linux MongoDB</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.oxysun.cn/"/>
  <updated>2018-07-07T11:59:06.607Z</updated>
  <id>http://www.oxysun.cn/</id>
  
  <author>
    <name>荒于嬉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java：Tomcat的部署实例之资源目录</title>
    <link href="http://www.oxysun.cn/java/java-deploy-resource-folder.html"/>
    <id>http://www.oxysun.cn/java/java-deploy-resource-folder.html</id>
    <published>2018-07-07T11:55:00.000Z</published>
    <updated>2018-07-07T11:59:06.607Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat上部署应用后，原本目录是否会被移除。<br><a id="more"></a></p><p><strong>实例：</strong><br>一个项目的资源放在了WebContent下面，这样每次打包，都会将这些文件打包进去，这样在打包时，导致打出来的war包有好几百兆，这样上传Git也非常不方便。</p><p>方案1：<br>分析：如果删除掉本地WebContent下的资源文件，再部署到服务器上，war包其实是一个压缩包，加压后覆盖原本目录下的相同内容，因为新上传的war包没有相同的资源文件，这样就不会覆盖原本的资源文件。<br>结果：加压后的项目目录也不存在资源文件了，看来这个部署过程，是会删掉原本的项目目录的。</p><p>方案2：<br>分析：因为webapps是web服务根目录，那么把资源文件从项目目录移到webapps下面，这样应该也可以被访问到。<br>结果：成功，可以被访问到。</p><p>为了验证这个，上网查了很多帖子，众说纷纭，最后还是在<a href="https://tomcat.apache.org/tomcat-8.0-doc/deployer-howto.html" target="_blank" rel="noopener">官网</a>找到这么一段话：</p><blockquote><p>The following deployment sequence will occur on Tomcat startup in that case:</p><ol><li>Any Context Descriptors will be deployed first.</li><li>Exploded web applications not referenced by any Context Descriptor will then be deployed. If they have an associated .WAR file in the appBase and it is newer than the exploded web application, the exploded directory will be removed and the webapp will be redeployed from the .WAR</li><li>.WAR files will be deployed</li></ol></blockquote><p>注意这里<code>the exploded directory will be removed and the webapp will be redeployed from the .WAR</code>，原本的解压目录会被移除，应用会被重新从<code>war</code>文件中部署。</p><p>寻根究底，而不人云亦云，这样才是端正的学习的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat上部署应用后，原本目录是否会被移除。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.oxysun.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Git：工作流程Git Flow</title>
    <link href="http://www.oxysun.cn/git/git-git-flow.html"/>
    <id>http://www.oxysun.cn/git/git-git-flow.html</id>
    <published>2018-07-06T13:22:00.000Z</published>
    <updated>2018-07-07T11:54:48.936Z</updated>
    
    <content type="html"><![CDATA[<p>Git的工作流程Git Flow介绍。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考：<a href="https://nvie.com/posts/a-successful-git-branching-model/，" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/，</a> 这篇帖子是10年发表的，而我大概是08、09年接触的Git，当时因为刚刚花了好大气力研究明白SVN的流程，所以对Git很排斥，这也是我工作中一直以来的一个问题，因为在一项老技术上花了太多气力，而导致对新技术的出现本能地产生很大的排斥。如果当时仔细去研究一下Git，应该会发现Git不是来革我们这些SVN拥趸的命，而是提供完善和丰富了SVN的功能。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从CVS到SVN，再从SVN到Git。<br>从中心化到去中心化的中心化（Decentralized but centralized），这句话挺有挺有深意。</p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h2><p>项目存在两个长期分支：</p><ul><li>主分支master。</li><li>开发分支develop或者dev。</li></ul><blockquote><p>We consider origin/master to be the main branch where the source code of HEAD always reflects a production-ready state.<br>We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. This is where any automatic nightly builds are built from.</p></blockquote><p>这里的HEAD是Git的一个指针，指向当前的分支上。<br>上面的话的意思大概是master分支总是指向“等待上生产”状态的代码。develop分支往往是最近交付的开发修改。这个过程是和原本的SVN工作流是很接近的，一个开发分支，一个线上分支。开发完，测试后，发布到线上。SVN流程推荐在测试时分叉一个branch出来进行测试，这个时候不影响trunk上业务的继续开发，这个工作流没有这么明说，但是因为Git的灵活性，建立一个临时的测试分支也是没有问题的。Git好就好在非常灵活，不过也正是因为如此，导致了一些问题，之前有一个小朋友，把所有的功能分支都保存了下来，还说这样会更加方便，我很难理解，这样怎么会方便呢？每个人分支都需要不断同步。灵活也应该是相对的，在一个相对固定的流程下，适当的灵活，是可以提高效率的。</p><p><img src="https://nvie.com/img/main-branches@2x.png" width="50%" height="50%"></p><h2 id="支持分支"><a href="#支持分支" class="headerlink" title="支持分支"></a>支持分支</h2><p>原文叫做supporting branches。这里面的每一个分支都有指定的目的和约束的规则，如何产生和如何合并。</p><ul><li>Feature branches</li><li>Release branches</li><li>Hotfix branches</li></ul><h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>可以产生于:<br>develop<br>必须合并到:<br>develop<br>分支命名约定:<br>除了master, develop, release-<em>, or hotfix-</em> 都可以，前面几个作为保留。</p><p>功能分支用于开发未来的一项功能，目标的发布此时可能还不确定。这个分支最终会被合并回develop（采用了）或者被抛弃掉（不采用）。<br>功能分支更多存在于用户仓库，而不是origin仓库。<br><img src="https://nvie.com/img/merge-without-ff@2x.png" width="50%" height="50%"></p><p><strong>创建：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b myfeature develop</span><br><span class="line">Switched to a new branch &quot;myfeature&quot;</span><br></pre></td></tr></table></figure></p><p><strong>合并回develop：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git branch -d myfeature</span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure><p>对于–no-ff，参考：<a href="https://git-scm.com/docs/git-merge，有待更进一步的解释。" target="_blank" rel="noopener">https://git-scm.com/docs/git-merge，有待更进一步的解释。</a></p><h3 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h3><p>可以产生于:<br>develop<br>必须合并到:<br>develop和master分支<br>分支命名约定:<br>release-*</p><p>我理解的，这里主要用于准备一个发布版的功能已经开发完成，等待一些信息最后的确认，为了不影响下一个开发版的正常进行，打出一个发布分支。</p><p><strong>创建一个发布分支</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop</span><br><span class="line">Switched to a new branch &quot;release-1.2&quot;</span><br><span class="line">$ ./bump-version.sh 1.2</span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2&quot;</span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure></p><p><strong>结束一个发布分支</strong><br>合并回master分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git tag -a 1.2</span><br></pre></td></tr></table></figure></p><p>合并回develop分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure></p><p>删除原分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d release-1.2</span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure></p><h3 id="热修复分支"><a href="#热修复分支" class="headerlink" title="热修复分支"></a>热修复分支</h3><p>可以产生于:<br>master<br>必须合并到:<br>develop和master分支<br>分支命名约定:<br>hotfix-*</p><p>主要用于对线上代码进行热修复用，线上代码出现了问题，开出一个分支进行修复，等修复完成，合并回master和develop分支。</p><p><strong>创建</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line">Switched to a new branch &quot;hotfix-1.2.1&quot;</span><br><span class="line">$ ./bump-version.sh 1.2.1</span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;</span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p><strong>提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;Fixed severe production problem&quot;</span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed severe production problem</span><br><span class="line">5 files changed, 32 insertions(+), 17 deletions(-)</span><br></pre></td></tr></table></figure><p><strong>结束</strong><br>合并回master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git tag -a 1.2.1</span><br></pre></td></tr></table></figure></p><p>合并回develop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure></p><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix-1.2.1</span><br><span class="line">Deleted branch hotfix-1.2.1 (was abbe5d6).</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git的工作流程Git Flow介绍。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://www.oxysun.cn/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：netstat</title>
    <link href="http://www.oxysun.cn/linux/shell-command-netstat.html"/>
    <id>http://www.oxysun.cn/linux/shell-command-netstat.html</id>
    <published>2018-07-05T07:14:47.000Z</published>
    <updated>2018-07-05T07:53:32.718Z</updated>
    
    <content type="html"><![CDATA[<p>netstat命令用来查看系统中所有的网络套接字连接情况。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>netstat [选项]</p><p>参考：<a href="https://linux.die.net/man/8/netstat。" target="_blank" rel="noopener">https://linux.die.net/man/8/netstat。</a></p><p><code>netstat</code>命令用来查看系统中所有的网络套接字连接情况。</p><!-- more --><h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>netstat</code> [选项]</p><p>参考：<a href="https://linux.die.net/man/8/netstat。" target="_blank" rel="noopener">https://linux.die.net/man/8/netstat。</a></p><p><code>netstat</code>命令用来查看系统中所有的网络套接字连接情况。</p><!-- more --><h2 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>netstat</code> [选项]</p><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p><code>netstat</code>命令用来查看系统中所有的网络套接字连接情况，包括TCP、UDP和Unix套接字。也可以显示路由表，接口状态，masquerade 连接，多播成员（Multicast Memberships）等等。另外，它还可以列出处于监听状态（等待接入请求）的套接字，比如想确认系统中的web服务是否起来，就可以查看80端口有没有打开。</p><h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul><li>-a或–all：显示所有选项，默认不显示LISTEN相关。</li><li>-t或–tcp：(TCP)仅显示TCP相关选项。</li><li>-u或–udp：(UDP)仅显示UDP相关选项。</li><li>-x或–unix：此参数的效果和指定”-A unix”参数相同。</li><li>-n或–numeric：拒绝显示别名，能显示数字的全部转化成数字。</li><li>-l或–listening：仅列出有在Listen(监听)的服务状态。</li><li>-g或–groups：显示多重广播功能群组组员名单。</li><li>-p或–programs：显示建立相关链接的程序名和PID。</li><li>-r或–route：显示路由信息，路由表。</li><li>-e或–extend：显示扩展信息，例如UID等。</li><li>-s或–statistics：按各个协议进行统计。</li><li>-c或–continuous：每隔一个固定时间，执行该netstat命令。</li><li>-g或–groups：显示多重广播功能群组组员名单。</li></ul><p>提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到。</p><h2 id="输出信息含义"><a href="#输出信息含义" class="headerlink" title="输出信息含义"></a>输出信息含义</h2><p><code>netstat</code>的输出结构可以分为两个部分：<br>一个是Active Internet connections，称为有源TCP连接。其中”Recv-Q”和”Send-Q”指的是接收队列和发送队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 VM01.root:ssh           61.149.11.230:21859     ESTABLISHED</span><br><span class="line">tcp        0      0 localhost:51476         localhost:27017         ESTABLISHED</span><br><span class="line">tcp        0      0 VM01.root:ssh           61.149.11.230:50883     ESTABLISHED</span><br><span class="line">tcp        0      0 VM01.root:58300         47.89.193.173:3666      ESTABLISHED</span><br></pre></td></tr></table></figure></p><p>另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。Proto显示连接使用的协议，RefCnt表示连接到本套接口上的进程号，Types显示套接口的类型，State显示套接口当前的状态，Path表示连接到套接口的其它进程使用的路径名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    15049    /run/user/0/systemd/notify</span><br><span class="line">unix  3      [ ]         DGRAM                    13640    /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    13645    /run/systemd/journal/syslog</span><br><span class="line">unix  8      [ ]         DGRAM                    13660    /run/systemd/journal/socket</span><br><span class="line">unix  25     [ ]         DGRAM                    10467    /run/systemd/journal/dev-log</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>实例：</strong>列出当前所有的连接（-a）<br>命令：<code>netstat -a</code><br>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# netstat -a</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 *:8838                  *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:27017         *:*                     LISTEN     </span><br><span class="line">tcp        0      0 *:8330                  *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:submission    *:*                     LISTEN </span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>列出所有TCP端口（-t）<br>命令：<code>netstat -at</code><br>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# netstat -at</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 *:8838                  *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:27017         *:*                     LISTEN     </span><br><span class="line">tcp        0      0 *:8330                  *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:submission    *:*                     LISTEN</span><br></pre></td></tr></table></figure><p><strong>示例：</strong>列出所有监听TCP的端口，数字显示<br>描述：查看本机监听的（-l）TCP连接（-t）的IP地址的数字显示（-n）。不适用-n的话，就会用端口的约定名称来显示，例如80端口，会显示成http。<br>命令：<code>netstat -tnl</code><br>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# netstat -tnl</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:8838            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:27017         0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:8330            0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure><p><strong>示例：</strong>获取本机的所有的TCP连接的进程名、进程号以及用户ID<br>描述：使用-p选项查看进程信息，-ep选项可以同时查看进程名和用户名。另外，-n和-e选项一起使用，User列的属性就是用户ID，而不是用户名。<br>查看本机所有的（al）TCP连接的（t）进程名（p）和用户名ID（ne）。<br>命令：<code>netstat -altpen</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# netstat -altpen</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8838            0.0.0.0:*               LISTEN      0          11863750    31212/bnewd     </span><br><span class="line">tcp        0      0 127.0.0.1:27017         0.0.0.0:*               LISTEN      110        2945745     18546/mongod    </span><br><span class="line">tcp        0      0 0.0.0.0:8330            0.0.0.0:*               LISTEN      0          22250263    13550/btnd      </span><br><span class="line">tcp        0      0 127.0.0.1:587           0.0.0.0:*               LISTEN      0          12285119    11792/sendmail: MTA</span><br></pre></td></tr></table></figure><p>这个可能是最屌的命令了，也可能是最常用的命令了。</p><p>还有一些实例，暂时不常用，有待完善。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;netstat命令用来查看系统中所有的网络套接字连接情况。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.oxysun.cn/categories/linux/"/>
    
      <category term="shell" scheme="http://www.oxysun.cn/categories/linux/shell/"/>
    
    
      <category term="Linux" scheme="http://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB：聚合之累加操作符</title>
    <link href="http://www.oxysun.cn/mongodb/mongodb-collection-aggregator-accumulate-operator.html"/>
    <id>http://www.oxysun.cn/mongodb/mongodb-collection-aggregator-accumulate-operator.html</id>
    <published>2018-07-04T15:29:00.000Z</published>
    <updated>2018-07-04T15:31:52.096Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的聚合之累加操作符。<br><a id="more"></a></p><p>官网：<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#considerations。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/group/#considerations。</a></p><h1 id="累加操作符"><a href="#累加操作符" class="headerlink" title="累加操作符"></a>累加操作符</h1><p>感觉这个没有太多可说的，简单翻译一下。</p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$avg</td><td>Returns an average of numerical values. Ignores non-numeric values.（返回平均值）</td></tr><tr><td>$first</td><td>Returns a value from the first document for each group. Order is only defined if the documents are in a defined order.（返回第一个）</td></tr><tr><td>$last</td><td>Returns a value from the last document for each group. Order is only defined if the documents are in a defined order.（返回最后一个）</td></tr><tr><td>$max</td><td>Returns the highest expression value for each group.（返回最大值）</td></tr><tr><td>$min</td><td>Returns the lowest expression value for each group.（返回最小值）</td></tr><tr><td>$push</td><td>Returns an array of expression values for each group.</td></tr><tr><td>$addToSet</td><td>Returns an array of unique expression values for each group. Order of the array elements is undefined.（）</td></tr><tr><td>$stdDevPop</td><td>Returns the population standard deviation of the input values.</td></tr><tr><td>$stdDevSamp</td><td>Returns the sample standard deviation of the input values.</td></tr><tr><td>$sum</td><td>Returns a sum of numerical values. Ignores non-numeric values.（返回总和）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB的聚合之累加操作符。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB：聚合之介绍</title>
    <link href="http://www.oxysun.cn/mongodb/mongodb-collection-aggregation-introduction.html"/>
    <id>http://www.oxysun.cn/mongodb/mongodb-collection-aggregation-introduction.html</id>
    <published>2018-07-04T15:24:00.000Z</published>
    <updated>2018-07-04T15:30:54.749Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的聚合功能介绍。<br><a id="more"></a></p><p>官网：<a href="https://docs.mongodb.com/manual/aggregation/#single-purpose-agg-operations。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/aggregation/#single-purpose-agg-operations。</a></p><p>初衷：MongoDB的使用还是有一定难度的，官网讲解的一环牵扯一环，不容易一下子把握住重点，也不利于快速查询操作，所以整理一下。</p><p>聚合函数是对记录集（data records）进行操作，是把多条记录集合（group）在一起，进行处理，与此相对应的是sql的group by等操作，这是数据处理的一个方面。</p><p>MongoDB提供三种聚合方法：</p><ol><li>聚合管道。</li><li>map-reduce函数。</li><li>单一功能的聚合方法。</li></ol><h1 id="聚合管道"><a href="#聚合管道" class="headerlink" title="聚合管道"></a>聚合管道</h1><p>接触过<code>linux shell</code>的人应该对管道不会陌生，管道就是对输入的数据进行一系列的处理、转换，变成新的数据。</p><p>这里的聚合管道是对记录集进行多阶段的转换，产出新聚合结果，例如：<br><img src="https://docs.mongodb.com/manual/_images/aggregation-pipeline.bakedsvg.svg" alt="这里写图片描述"></p><p>解释一下：</p><ol><li>数据集合：<code>orders</code>，共有4条记录，这里省略了<code>_id</code> 这个域。</li><li>需求：查找所有<code>status=&quot;A&quot;</code> 的记录，根据cust_id进行分组，计算每个组的<code>amount</code>的和。</li><li>分析：<br><code>{$match: {status: &quot;A&quot;}}</code>，第一个阶段，匹配阶段，查找所有<code>status=&quot;A&quot;</code> 的记录。<br><code>{$group: {_id: &quot;$cust_id&quot;, total: {$sum: &quot;$amount&quot;}}}</code>，第二个阶段，分组计算，根据<code>cust_id</code>进行分组，对每个组的<code>amount</code>进行求和。这里涉及<code>$group</code> 的语法，如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $group: &#123; _id: &lt;expression&gt;, &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;, ... &#125; &#125;</span><br></pre></td></tr></table></figure><p>其中，_id是强制的，后面是可选的。<br><code>&lt;accumulator1&gt;</code>是累加操作符，参考<a href="/mongodb/mongodb-collection-aggregator-accumulate-operator.html">这里</a>，例如这里的<code>$sum</code>，注意，这里必须要加<code>$</code>。<br><code>&lt;expression1&gt;</code>是表达式，<a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#aggregation-expressions" target="_blank" rel="noopener">有待补充</a>， <code>&quot;$amount&quot;</code> , 表示是去取上一个结果中的<code>amount</code> 这个域，对其进行累加，并把结果存入新的域<code>total</code>中。</p><p>这个例子看明白了，聚合就基本明白了。</p><h1 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h1><p>map-reduce操作分为两个阶段：map阶段，处理每一条记录，产出一个或多个对象；reduce阶段，合并map阶段的输出。作为可选，map-reduce可以有一个最终阶段来对结果进行最终的操作。map-reduce也可以进行查询、排序和限制输出结果。<br><img src="https://docs.mongodb.com/manual/_images/map-reduce.bakedsvg.svg" alt="这里写图片描述"></p><h1 id="单一功能的聚合方法"><a href="#单一功能的聚合方法" class="headerlink" title="单一功能的聚合方法"></a>单一功能的聚合方法</h1><p>MongoDB也提供<code>db.collection.count()</code>（求和）和<code>db.collection.distinct()</code>（去重）函数。<br><img src="https://docs.mongodb.com/manual/_images/distinct.bakedsvg.svg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB的聚合功能介绍。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB：查找记录 find（1）</title>
    <link href="http://www.oxysun.cn/mongodb/mongodb-collection-find-1.html"/>
    <id>http://www.oxysun.cn/mongodb/mongodb-collection-find-1.html</id>
    <published>2018-07-02T13:03:00.000Z</published>
    <updated>2018-07-02T15:15:43.385Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB如何查询记录之一。<br><a id="more"></a></p><p>官网：<a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/method/db.collection.find/。</a></p><h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure><p>在集合或者视图的文档中进行选择，并且返回一个指向被选中的文档的游标。（原文是：Selects documents in a collection or view and returns a cursor to the selected documents.）</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>query</td><td>文档型</td><td>可选。使用查询操作符(<a href="https://www.oxysun.cn/mongodb/mongodb-collection-find-projection-operator.html">参考这里</a>)，指定了查询过滤器。 想要返回集合中所有的文档，忽略这个参数，或者传一个空的文档({})。</td></tr><tr><td>projection</td><td>文档型</td><td>可选。制定了匹配查询过滤器，要返回的文档的域。想要返回匹配的文档中的所有域，忽略这个参数。</td></tr></tbody></table><h1 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h1><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>projection参数决定了哪些域需要被返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; field1: &lt;value&gt;, field2: &lt;value&gt; ... &#125;</span><br></pre></td></tr></table></figure><p><code>&lt;value&gt;</code>可以是:</p><ul><li>1 或 true 表示要在返回文档中包含这个域。</li><li>0 或 false 表示不包含这个域。</li><li>表达式使用了投影操作符（有待解释）。</li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>实例</strong> 查找<a href="https://www.oxysun.cn/mongodb/mongodb-collection-create.html">上文</a>test集合中的所有文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080199&quot;),</span><br><span class="line">    &quot;meta&quot; : &#123;</span><br><span class="line">        &quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">        &quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;a&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;b&quot; : &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080120&quot;),</span><br><span class="line">    &quot;meta&quot; : &#123;</span><br><span class="line">        &quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">        &quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;a&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;b&quot; : &quot;3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>pretty()</code>是用来让展示更加舒适。</p><p><strong>实例</strong> 查找test集合中的<code>b=&quot;3&quot;</code>的记录，这里要注意<code>“3”</code>和<code>3</code>是不一样的，这里是要符合js的语法，字符串和数字表示方式是不同的。做一个好的程序员，一定要严谨，而做到了严谨，可以帮你更快地提高，更快地产出，更好地规避错误，其实加快了你的职场发展节奏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find(&#123;b: &quot;3&quot;&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080120&quot;),</span><br><span class="line">&quot;meta&quot; : &#123;</span><br><span class="line">&quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">&quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">&#125;,</span><br><span class="line">&quot;a&quot; : &quot;1&quot;,</span><br><span class="line">&quot;b&quot; : &quot;3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这次只查出了一条符合条件的记录。</p><p><strong>实例</strong> 查找test集合中的b=”3”的记录a和b两个域，不要其它域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find(&#123;b: &quot;3&quot;&#125;, &#123;a: 1, b: 1&#125;).pretty()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080120&quot;), &quot;a&quot; : &quot;1&quot;, &quot;b&quot; : &quot;3&quot; &#125;</span><br></pre></td></tr></table></figure><p>可以看到，没有涉及的域就没有再获取出来，这样在一些情况下是可以节省网络开销和分析成本的，在《高性能MySQL》也是讲过类似的原理，不要大而全地去把所有内容获取回来，对于资源的使用，应该是有规划的、经济地去使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB如何查询记录之一。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB：查询和投影操作符</title>
    <link href="http://www.oxysun.cn/mongodb/mongodb-collection-find-projection-operator.html"/>
    <id>http://www.oxysun.cn/mongodb/mongodb-collection-find-projection-operator.html</id>
    <published>2018-07-02T13:03:00.000Z</published>
    <updated>2018-07-02T15:08:33.373Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB查询和投影操作符。<br><a id="more"></a></p><p>官网：<a href="https://docs.mongodb.com/manual/reference/operator/query/。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query/。</a></p><p>这一章节都是很简单的英语，就做一个很简单的备注，如果连这个英语都看不懂，那就需要提高了，程序员看不懂基本的英语是很难提高的。<br>这一章节还需要完善一些样例，这个有待补充。</p><h1 id="查询选择器"><a href="#查询选择器" class="headerlink" title="查询选择器"></a>查询选择器</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$eq</td><td>Matches values that are equal to a specified value.（判断相等）</td></tr><tr><td>$gt</td><td>Matches values that are greater than a specified value.（判断大于）</td></tr><tr><td>$gte</td><td>Matches values that are greater than or equal to a specified value.（判断大于等于）</td></tr><tr><td>$in</td><td>Matches any of the values specified in an array.（判断在其中）</td></tr><tr><td>$lt</td><td>Matches values that are less than a specified value.（判断小于）</td></tr><tr><td>$lte</td><td>Matches values that are less than or equal to a specified value.（判断小于等于）</td></tr><tr><td>$ne</td><td>Matches all values that are not equal to a specified value.（判断所有值都不等于指定值）</td></tr><tr><td>$nin</td><td>Matches none of the values specified in an array.（判断不在其中）</td></tr></tbody></table><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$and</td><td>Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.（与）</td></tr><tr><td>$not</td><td>Inverts the effect of a query expression and returns documents that do not match the query expression.（非）</td></tr><tr><td>$nor</td><td>Joins query clauses with a logical NOR returns all documents that fail to match both clauses.（异或）</td></tr><tr><td>$or</td><td>Joins query clauses with a logical OR returns all documents that match the conditions of either clause.（或）</td></tr></tbody></table><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$exists</td><td>Matches documents that have the specified field.</td></tr><tr><td>$type</td><td>Selects documents if a field is of the specified type.</td></tr></tbody></table><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$expr</td><td>Allows use of aggregation expressions within the query language.</td></tr><tr><td>$jsonSchema</td><td>Validate documents against the given JSON Schema.</td></tr><tr><td>$mod</td><td>Performs a modulo operation on the value of a field and selects documents with a specified result.</td></tr><tr><td>$regex</td><td>Selects documents where values match a specified regular expression.</td></tr><tr><td>$text</td><td>Performs text search.</td></tr><tr><td>$where</td><td>Matches documents that satisfy a JavaScript expression.</td></tr></tbody></table><h2 id="地理空间"><a href="#地理空间" class="headerlink" title="地理空间"></a>地理空间</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$geoIntersects</td><td>Selects geometries that intersect with a GeoJSON geometry. The 2dsphere index supports <code>$geoIntersects</code>.</td></tr><tr><td>$geoWithin</td><td>Selects geometries within a bounding GeoJSON geometry. The 2dsphere and 2d indexes support <code>$geoWithin</code>.</td></tr><tr><td>$near</td><td>Returns geospatial objects in proximity to a point. Requires a geospatial index. The 2dsphere and 2d indexes support <code>$near</code>.</td></tr><tr><td>$nearSphere</td><td>Returns geospatial objects in proximity to a point on a sphere. Requires a geospatial index. The 2dsphere and 2d indexes support <code>$nearSphere</code>.</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$all</td><td>Matches arrays that contain all elements specified in the query.</td></tr><tr><td>$elemMatch</td><td>Selects documents if element in the array field matches all the specified <code>$elemMatch</code> conditions.</td></tr><tr><td>$size</td><td>Selects documents if the array field is a specified size.</td></tr></tbody></table><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$bitsAllClear</td><td>Matches numeric or binary values in which a set of bit positions all have a value of 0.</td></tr><tr><td>$bitsAllSet</td><td>Matches numeric or binary values in which a set of bit positions all have a value of 1.</td></tr><tr><td>$bitsAnyClear</td><td>Matches numeric or binary values in which any bit from a set of bit positions has a value of 0.</td></tr><tr><td>$bitsAnySet</td><td>Matches numeric or binary values in which any bit from a set of bit positions has a value of 1.</td></tr></tbody></table><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$comment</td><td>Adds a comment to a query predicate.</td></tr></tbody></table><h1 id="投影操作"><a href="#投影操作" class="headerlink" title="投影操作"></a>投影操作</h1><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>Projects the first element in an array that matches the query condition.</td></tr><tr><td>$elemMatch</td><td>Projects the first element in an array that matches the specified <code>$elemMatch</code> condition.</td></tr><tr><td>$meta</td><td>Projects the document’s score assigned during <code>$text</code> operation.</td></tr><tr><td>$slice</td><td>Limits the number of elements projected from an array. Supports skip and limit slices.</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB查询和投影操作符。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：touch</title>
    <link href="http://www.oxysun.cn/linux/shell-command-touch.html"/>
    <id>http://www.oxysun.cn/linux/shell-command-touch.html</id>
    <published>2018-07-01T06:28:00.000Z</published>
    <updated>2018-07-05T07:53:32.719Z</updated>
    
    <content type="html"><![CDATA[<p>touch命令用来创建文件，也可以更改和修改一个文件的时间戳。<br><a id="more"></a></p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p><code>touch [选项]... 文件...</code></p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>touch命令用来创建文件，也可以更改和修改一个文件的时间戳。Linux中的每个文件都与时间戳相关联，而且每个文件都存储上次访问时间，上次修改时间，上次更改时间的信息。因为，无论何时创建一个新文件，访问或者修改现有文件，时间戳都会被自动更新。<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-man.png" alt=""></p><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><p>Linux中的文件有三个时间：</p><ul><li>access time（atime）：访问时间，对一次文件的内容就会更新。例如cat，vi/vim，cp，touch命令。</li><li>modification time（mtime）：修改时间，对文件内容修改一次就会更新。例如touch，vi/vim命令。</li><li>status time（ctime）：状态改动时间。通过chmod/chown/chgrp等命令更改一次文件属性，通过touch准确地修改时间等，这个时间就会更新。例如mv，touch，chmod/chown/chgrp，vi/vim等命令。</li></ul><p>touch命令选项：</p><ul><li>-a，只改变访问时间。</li><li>-c，如果文件不存在，那就不创建。</li><li>-d，更新访问时间和修改时间。</li><li>-m，只改变修改时间。</li><li>-r，将参照文件ref_file相应的时间戳作为指定文件file时间戳的新值。</li><li>-t，用指定的时间创建文件，格式是[[CC]YY]MMDDhhmm[.SS]。CCYY的范围在1969~2068之内。SS为秒数，范围在0~61之间，这样可以处理闰秒。由于系统的限制，早于1970年1月1日的时间是错误的。</li></ul><h3 id="示例：1-创建空文件"><a href="#示例：1-创建空文件" class="headerlink" title="示例：1. 创建空文件"></a>示例：1. 创建空文件</h3><p>描述：若文件不存在，使用touch命令可以轻松地创建一个空文件，或是创建多个。如果文件已存在，那么文件的3个时间：修改时间（mtime）、状态改动时间（ctime）和访问时间（atime）都会被更新为当前时间。stat命令可以查看文件时间。<br>命令：<br><code>touch my_one</code><br><code>stat my_one</code><br><code>touch my_one my_two my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch.png" alt=""></p><h3 id="示例：2-只改变文件的修改时间（mtime）和状态改动时间（ctime）"><a href="#示例：2-只改变文件的修改时间（mtime）和状态改动时间（ctime）" class="headerlink" title="示例：2. 只改变文件的修改时间（mtime）和状态改动时间（ctime）"></a>示例：2. 只改变文件的修改时间（mtime）和状态改动时间（ctime）</h3><p>描述：只改变my_three文件的修改时间为当前时间，同时状态改动时间会在命令执行后更新为当前时间。这个操作并不需要修改文件内容。-m选项只更改文件的修改时间。<br>命令：<code>touch -m my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-m.png" alt=""></p><h3 id="示例：3-只改变文件访问时间（atime）和状态改动时间（ctime）"><a href="#示例：3-只改变文件访问时间（atime）和状态改动时间（ctime）" class="headerlink" title="示例：3. 只改变文件访问时间（atime）和状态改动时间（ctime）"></a>示例：3. 只改变文件访问时间（atime）和状态改动时间（ctime）</h3><p>描述：只改变my_three文件的访问时间为当前时间，同时状态改动时间会在命令执行后更新为当前时间。如果文件不存在，会创建新的空文件。-a选项只更改文件的访问时间。<br>命令：<code>touch -a my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-a.png" alt=""></p><h3 id="示例：4-指定文件的访问时间和修改时间"><a href="#示例：4-指定文件的访问时间和修改时间" class="headerlink" title="示例：4. 指定文件的访问时间和修改时间"></a>示例：4. 指定文件的访问时间和修改时间</h3><p>描述：同时设置文件的访问时间和修改时间为指定时间，同时会更新状态改变时间为当前命令执行后的时间。如果文件不存在，会创建新的空文件。-d选项同时改变文件的访问时间和修改时间。<br>命令：<code>touch -d &quot;2018-06-14 14:00:00&quot; my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-d.png" alt=""></p><p>描述：将my_three文件的访问时间和修改时间修改成两天前。touch还支持像date命令那样修改文件的时间。<br>命令：<code>touch -d &quot;2 days ago&quot; my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-d-date.png" alt=""></p><h3 id="示例：5-避免创建新文件"><a href="#示例：5-避免创建新文件" class="headerlink" title="示例：5. 避免创建新文件"></a>示例：5. 避免创建新文件</h3><p>描述：更新atime、ctime、mtime，如果文件不存在，-c选项不会创建新的文件。<br>命令：<code>touch -c leena</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-a.png" alt=""></p><h3 id="示例：6-使用另一个文件的时间戳"><a href="#示例：6-使用另一个文件的时间戳" class="headerlink" title="示例：6. 使用另一个文件的时间戳"></a>示例：6. 使用另一个文件的时间戳</h3><p>描述：-r选项将my_three的时间戳作为my_two文件的时间戳的新值，这两个文件有相同的时间戳。<br>命令：<code>touch -r my_three my_two</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-r.png" alt=""></p><h3 id="示例：7-使用指定的时间戳创建一个文件"><a href="#示例：7-使用指定的时间戳创建一个文件" class="headerlink" title="示例：7. 使用指定的时间戳创建一个文件"></a>示例：7. 使用指定的时间戳创建一个文件</h3><p>描述：将my_four文件的时间戳指定为1997年6月14日17点00分55秒。时间格式是[[CC]YY]MMDDhhmm[.SS]。<br>命令：<code>touch -t 199706141700.55 my_four</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-t.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;touch命令用来创建文件，也可以更改和修改一个文件的时间戳。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.oxysun.cn/categories/linux/"/>
    
      <category term="shell" scheme="http://www.oxysun.cn/categories/linux/shell/"/>
    
    
      <category term="Linux" scheme="http://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：sed</title>
    <link href="http://www.oxysun.cn/linux/shell-command-sed.html"/>
    <id>http://www.oxysun.cn/linux/shell-command-sed.html</id>
    <published>2018-07-01T02:00:00.000Z</published>
    <updated>2018-07-05T07:53:32.718Z</updated>
    
    <content type="html"><![CDATA[<p><code>sed</code>是stream editor（流式编辑器）的缩写，是一个非交互式的流编辑器，用于过滤或者转换文本。<br>未完待续…<br><a id="more"></a></p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>sed 选项…  [脚本]  [输入文件…]</p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p><code>sed</code>编辑器被称作流编辑器(stream editor)，和普通的交互式文本编辑器恰好相反。在交互式文本编辑器中(比如vim)，你可以用键盘命令来交互式地插入、删除或替换数据中的文本。流编辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。<br><code>sed</code>编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。sed编辑器会执行下列操作。<br>(1) 一次从输入中读取一行数据。<br>(2) 根据所提供的编辑器命令匹配数据。<br>(3) 按照命令修改流中的数据。<br>(4) 将新的数据输出到STDOUT。 在流编辑器将所有命令与一行数据匹配完毕后，它会读取下一行数据并重复这个过程。在流编辑器处理完流中的所有数据行后，它就会终止。 由于命令是按顺序逐行给出的，sed编辑器只需对数据流进行一遍处理就可以完成编辑操作。<br>这使得sed编辑器要比交互式编辑器快得多，你可以快速完成对数据的自动修改。</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>这个命令使用起来有些复杂，复杂在于功能强大，需要逐步消化。</p><h1 id="常见用例"><a href="#常见用例" class="headerlink" title="常见用例"></a>常见用例</h1><p><strong>实例</strong> 替换input.txt文件中所有的“hello”为“world”，并且输出到output.txt中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s/hello/world/&apos; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><p>这可能是最常用的例子了（至少在我工作这么多年的经验中），这里使用了<code>sed</code>的命令<code>s</code>。如果想输出到原文件的话，使用<code>-i</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;s/hello/world/&apos; input.txt</span><br></pre></td></tr></table></figure><p>这个在mac下表现会不一样，参考：<a href="https://blog.csdn.net/cuiaamay/article/details/49495885。" target="_blank" rel="noopener">https://blog.csdn.net/cuiaamay/article/details/49495885。</a></p><p>参考：<a href="https://www.gnu.org/software/sed/manual/sed.html。" target="_blank" rel="noopener">https://www.gnu.org/software/sed/manual/sed.html。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;sed&lt;/code&gt;是stream editor（流式编辑器）的缩写，是一个非交互式的流编辑器，用于过滤或者转换文本。&lt;br&gt;未完待续…&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.oxysun.cn/categories/linux/"/>
    
      <category term="shell" scheme="http://www.oxysun.cn/categories/linux/shell/"/>
    
    
      <category term="Linux" scheme="http://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例： awk</title>
    <link href="http://www.oxysun.cn/linux/shell-command-awk.html"/>
    <id>http://www.oxysun.cn/linux/shell-command-awk.html</id>
    <published>2018-07-01T02:00:00.000Z</published>
    <updated>2018-07-05T07:53:32.717Z</updated>
    
    <content type="html"><![CDATA[<p>awk命令在文件或字符串中基于指定规则浏览和抽取信息。<br><a id="more"></a></p><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>awk是一种小巧的编程语言及命令行工具。（其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母）。它非常适合服务器上的日志处理，主要是因为awk可以对文件进行操作，通常以可读文本构建行。<br>awk命令在文件或字符串中基于指定规则浏览和抽取信息。awk抽取信息后，才能进行其他文本操作，awk脚本通常用来格式化文本文件中的信息。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>有三种方式调用awk，第一种是命令行方式，例如：<br><code>awk [-F field-separator] &#39;commands&#39; input-file(s)</code><br>awk默认使用空格作为缺省的域分隔符。如果要浏览诸如passwd文件，此文件是以冒号作为分隔符，则必须指明-F选项。例如：<br><code>awk -F : &#39;commands&#39; input-file</code><br>第二种方式是将所有awk命令插入一个文件，并使awk程序可执行，然后用awk命令解释器作为脚本的首行，以便通过键入脚本名称来调用它。<br>第三种方式是将所有的awk命令插入一个单独文件，然后调用：<br><code>awl -f awk-script-file input-file(s)</code><br>-f选项指明在文件awk-script-file中的awk脚本，input_file(s)是使用awk进行浏览的文件名。</p><h2 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>awk脚本的代码结构很简单，就是一系列的模式（pattern）和动作（action）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># comment</span><br><span class="line">Pattern1 &#123; ACTIONS; &#125;</span><br><span class="line"># comment</span><br><span class="line">Pattern2 &#123; ACTIONS; &#125;</span><br><span class="line"># comment</span><br><span class="line">Pattern3 &#123; ACTIONS; &#125;</span><br><span class="line"># comment</span><br><span class="line">Pattern4 &#123; ACTIONS; &#125;</span><br></pre></td></tr></table></figure><p>扫描文档的每一行时都必须与每一个模式进行匹配比较，一次只匹配一个模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is line 1</span><br><span class="line">this is line 2</span><br></pre></td></tr></table></figure><p>this is line 1这行会先Pattern1进行匹配，如果匹配成功，就会执行ACTIONS。然后this is line 1会和Pattern2进行匹配，如果匹配失败，就调到Pattern3进行匹配，以此类推。<br>一旦所有的模式都匹配过了，this is line 2就会以同样的步骤进行匹配。其他的行也一样，直到读取完整个文件。这就是awk的运行模式。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>awk仅有两个主要的数据类型：字符串和数字，它们可以相互转换。<br>在ACTIONS部分使用=操作符给变量赋值，可以在任意时刻、任意地方声明和使用变量，也可以使用未初始化的变量，默认是空字符串。<br>awk有数组类型，并且它们是动态的一维关联数组。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式分为三大类：正则表达式、布尔表达式和特殊模式。</p><p>所有模式都是可选的，下面的脚本形式会对输入的每一行都会简单地执行ACRIONS。<br><code>{ ACTIONS }</code></p><h3 id="特殊的模式"><a href="#特殊的模式" class="headerlink" title="特殊的模式"></a>特殊的模式</h3><p>模式包括两个特殊字段：BEGIN和END。BEGIN在所有输入未被处理之前，即文本浏览动作之前进行匹配。可以初始化脚本变量和所有种类的状态的主要地方。END会在所有的输入都被处理完后，即完成文本浏览动作后进行匹配。可以在退出前进行清除工作和一些最后的输出。<br>最后一类模式，要把它进行归类有点困难。它处于变量和特殊值之间，我们通常称它们为域（Field）。而且名副其实。</p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># According to the following line</span><br><span class="line">#</span><br><span class="line"># $1 $2 $3</span><br><span class="line"># 00:34:23 GET /foo/bar.html</span><br><span class="line"># _____________ _____________/</span><br><span class="line"># $0</span><br><span class="line"> </span><br><span class="line"># Hack attempt?</span><br><span class="line">/admin.html$/ &amp;&amp; $2 == &quot;DELETE&quot; &#123;</span><br><span class="line">print &quot;Hacker Alert!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>域（默认地）由空格分隔。$0域代表了一整行的字符串。$1 域是第一块字符串（在任何空格之前），$2\$域是后一块，以此类推。<br>awk执行时，其浏览域标记为$1, $2, $3…$n。这种方式称为域标识。使用$1, $3标识表示第1和第3域。使用$0$标识表示所有域。<br>awk浏览到一新行时，即到达域的记录末尾，执行新记录下一行的读动作，重新设置域分隔。</p><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>最常用和最有用的行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $0; &#125; # prints $0. In this case, equivalent to &apos;print&apos; alone</span><br><span class="line">&#123; exit; &#125; # ends the program</span><br><span class="line">&#123; next; &#125; # skips to the next line of input</span><br><span class="line">&#123; a=$1; b=$0 &#125; # variable assignment</span><br><span class="line">&#123; c[$1] = $2 &#125; # variable assignment (array)</span><br><span class="line"> </span><br><span class="line">&#123; if (BOOLEAN) &#123; ACTION &#125;</span><br><span class="line">else if (BOOLEAN) &#123; ACTION &#125;</span><br><span class="line">else &#123; ACTION &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123; for (i=1; i&lt;x; i++) &#123; ACTION &#125; &#125;</span><br><span class="line">&#123; for (item in c) &#123; ACTION &#125; &#125;</span><br></pre></td></tr></table></figure><p>awk里的变量都是全局变量。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的<a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din" target="_blank" rel="noopener">通用文档(regular documentation)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; somecall($2) &#125;</span><br></pre></td></tr></table></figure><p>用户定义的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># function arguments are call-by-value</span><br><span class="line">function name (parameter-list) &#123;</span><br><span class="line">ACTIONS; #same actions as usual</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># return is valid keyword</span><br><span class="line">function add (val) &#123;</span><br><span class="line">return val+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：0. 新建测试文件</strong><br>描述：新建一个device文件，其中(1)为序号，(2)为Android版本，(3)为访问时间，(4)为IP，(5)为访问次数。本文大部分实例根据这一文件进行说明。<br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-origin.png" alt=""></p><p><strong>实例：1. 抽取域</strong><br>描述：打印第1个（序号）域和第2个（Android版本）域的内容。print用来输出其后跟着的内容，用大括号把print语句括起来，表示一个打印动作。<br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-partion-domain.png" alt=""></p><p><strong>实例：2. 打印所有记录</strong><br>描述：打印所有记录。$0代表所有域。<br>命令：<code>awk &#39;{print $0}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-$0.png" alt=""></p><p><strong>实例：3. 打印报告头</strong><br>描述：在序号和IP地址之间用一些空格使之更容易划分，也可以在域间使用tab键加以划分。本例中加入NO和IP两个信息头以及中划线，\n启动新行，并在\n下一行启动打印文本操作。打印信息头放置在BEGIN模式部分，因为打印信息头被界定为一个动作，必须用大括号括起来。在awk查看第一条记录前，信息头被打印。<br>命令：<code>awk &#39;BEGIN {print &quot;NO        IP\n------------------------&quot;} {print $1&quot;\t&quot;$4}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-Begin.png" alt=""></p><p><strong>实例：4. 打印信息尾</strong><br>描述：在末行加入end of report信息。END语句在所有文本处理动作执行完之后才被执行，在脚本中的位置是在主要动作之后。<br>命令：<code>awk &#39;BEGIN {print &quot;Version\n-------&quot;} {print $2} END {print &quot;end-of-report&quot;}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-End.png" alt=""></p><p><strong>实例：5. 错误信息提示</strong><br>描述：如果将在awk命令中缺少一个双引号，awk将返回错误提示信息。<br>命令：<code>awk &#39;BEGIN {print &quot;Version\n-------&quot;} {print $2} END {print &quot;end-of-report}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-error.png" alt=""></p><p>注意：在碰到awk错误时，应从以下几点进行排查：</p><ul><li>确保整个awk命令引用单引号括起来。</li><li>确保命令内所有引号成对出现。</li><li>确保用花括号括起动作语句，用圆括号括起条件语句。</li><li>可能忘记使用花括号。</li></ul><p>描述：如果查询的文件不存在，将得到以下错误信息：<br>命令：<code>awk &#39;END {print NR}&#39; device.txt</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-file-not-found.png" alt=""></p><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p><strong>实例：1. 匹配</strong><br>描述：如果field-4以数字4开头，打印它。如果条件满足，则打印匹配的记录行。符号~后紧跟正则表达式，使一域号匹配正则表达式，也可以使用if语句。awk的if后面的条件用()括起来。^尖角符号表示行首。<br>命令：<code>awk &#39;{ if ($4 ~ /^4/) print $0}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-if.png" alt=""></p><p>等同于：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-same-if.png" alt=""></p><p><strong>实例：2. 精确匹配</strong><br>描述：精确匹配访问次数为1次的记录，确保不匹配访问次数为15次的记录。使用等号==，并用单引号括起条件，也可以使用if语句。<br>命令：<code>awk &#39;$5==&quot;1&quot; {print $0}&#39; device</code><br>或者：<code>awk &#39;{if($5==/1/) print $0}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-==.png" alt=""></p><p><strong>实例：3. 不匹配</strong><br>描述：不匹配IP地址以4开头的记录。使用!~表示不匹配。<br>命令：<code>awk &#39;$4 !~ /^4/&#39; device</code><br>或者：<code>awk &#39;{ if ($4 !~ /^4/) print $0}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-!~.png" alt=""></p><p>注意这里不能用!=，因为用引号或者/括起了^4，将只匹配4而不匹配49.65.119.165等。如果查询非49.65.119.165的记录，可做如下操作：<br><code>awk &#39;$4 != &quot;49.65.119.165&quot;&#39; device</code></p><p><strong>实例：4. 小于，小于等于，大于，大于等于</strong><br>描述：匹配访问次数小于序号的记录。同样的有小于等于（&lt;=），大于（&gt;），大于等于（&gt;=）。<br>命令：<code>awk &#39;$4 !~ /^4/&#39; device</code><br>或者：<code>awk &#39;{ if ($4 !~ /^4/) print $0}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-less-than.png" alt=""></p><p><strong>实例：5. 设置大小写</strong><br>描述：匹配含有前面是i或I，后面是OS的记录。[]符号可匹配[]内任意字符或单词。<br>命令：<code>awk &#39;/[iI]OS/&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-i.png" alt=""></p><p><strong>实例：6. 任意字符</strong><br>描述：匹配Android版本，第八个字符是7，打印它。表达式/^…….7/表示行首前7个字符任务，第八个是7。<br>命令：<code>awk &#39;$2 ~ /^.......7/&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-dot.png" alt=""></p><p><strong>实例：7. 或关系匹配</strong><br>描述：匹配IP地址以4或者3开头的记录。竖线符|意为两边模式之一。可以得到与[]表达式相同的结果。<br>命令：<code>awk &#39;$4 ~ /^(4|3)/&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-or.png" alt=""></p><p>注意，在使用竖线符时，语句必须用圆括号括起来。另外，除了字符重复出现外，其他的正则表达式在awk中都是合法的。</p><p><strong>实例：8. AND</strong></p><p>描述：匹配Android版本在7.0以上，并且IP地址以4开头的记录。OR，非与之类似。<br>命令：<code>awk &#39;$2 ~ /^.......7/ &amp;&amp; $4 ~ /^4/&#39; device</code><br>等同于：<code>awk &#39;{ if ($2 ~ /^.......7/ &amp;&amp; $4 ~ /^4/) print $0} &#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-&amp;&amp;.png" alt=""></p><h3 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h3><p>awk内置变量如下：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-builtin-variable-table-1.png" alt=""></p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-builtin-variable-table-2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123; # Can be modified by the user</span><br><span class="line">FS = &quot;,&quot;; # Field Separator</span><br><span class="line">RS = &quot;n&quot;; # Record Separator (lines)</span><br><span class="line">OFS = &quot; &quot;; # Output Filed Separator</span><br><span class="line">ORS = &quot;n&quot;; # Output Record Separator (lines)</span><br><span class="line">&#125;</span><br><span class="line">&#123; # Can&apos;t be modified by the user</span><br><span class="line">NF # Number of Fileds in the current Record (lines)</span><br><span class="line">NR # Number of Records seen so far</span><br><span class="line">ARGV / ARGC # Script Arguments</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NF：支持记录域个数，在记录被读之后再设置。<br>NR：已读的记录数。<br>FILENAME：告知系统目前正在浏览的实际文件，因为awk可以同时处理许多文件。</p><p><strong>实例：1. NF、NR、FILENAME</strong></p><p>描述：所有记录被打印，并带有记录号（第二和第三列），并在最后输出文件名。使用NF变量显示每一条读记录中有多少个域（5个），使用NR显示已读的记录数，使用FILENAME显示正在处理的文件名。<br>命令：<code>awk &#39;{print NF,NR,$0} END {print FILENAME}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-builtin-variable.png" alt=""></p><p><strong>实例：2. 判断文件至少有一个记录</strong></p><p>描述：先检查文件中至少有一个记录时才查询IP地址。<br>命令：<code>awk &#39;NR &gt; 0 &amp;&amp; $4 ~ /^4/&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-NR.png" alt=""></p><p><strong>实例：3. 与echo结合使用</strong></p><p>描述：将变量$PWD的返回值传入awk并显示其目录。需要指定域分隔符/。<br>命令：<code>echo $PWD | awk -F / &#39;{print $NF}&#39;</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-echo.png" alt=""></p><p>描述：显示文件名。<br>命令：<code>echo &quot;/etc/vimrc&quot; | awk -F / &#39;{print $NF}&#39;</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-show-filename.png" alt=""></p><h3 id="awk操作符"><a href="#awk操作符" class="headerlink" title="awk操作符"></a>awk操作符</h3><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-operator.png" alt=""></p><p><strong>实例：1. 设置输入域到域变量名</strong><br>描述：赋值IP地址域为ip，版本域为version，查询版本大于7的记录，并打印IP地址和版本信息。<br>命令：<code>awk &#39;{ip=$4;version=$2; if (version ~ /*7*/) print ip&quot;&quot;version}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-set-variable.png" alt=""></p><p><strong>实例：2. 域值比较操作</strong><br>有两种方式测试数值域是否小于另一数值域。</p><ul><li>在BEGIN中给变量名赋值。</li><li>在关系操作中使用实际数值。</li></ul><p>描述：找出访问次数大于10次的所有记录。<br>命令：<code>awk &#39;{if ($5 &gt; 10) print $0}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-comparable.png" alt=""></p><p><strong>实例：3. 修改数值域的值</strong></p><p>当在awk中修改任何域时，实际输入文件是不可修改的，修改的只是保存在缓存里的awk副本，awk会在变量NR或NF变量中反映出修改痕迹。</p><p>描述：修改序号为6的记录，将其访问次数减一。<br>命令：<code>awk &#39;{if ($1==6) $5=$5-1; print $1, $2, $5 }&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-modify-copy-number-domain.png" alt=""></p><p><strong>实例：4. 修改文本域</strong></p><p>描述：修改序号为6的记录，将其版本修改为iOS11.2.3。修改文本域就是对其重新赋值。<br>命令：<code>awk &#39;{if ($1==6) ($2=&quot;iOS11.2.3&quot;); print $1, $2, $5 }&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-modify-text-copy-domain.png" alt=""></p><p><strong>实例：5. 只显示修改记录</strong></p><p>描述：只显示修改后序号为6的记录。<br>命令：<code>awk &#39;{if ($1==6) {$2=&quot;iOS11.2.3&quot;; print $2}; }&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-modify-and-only-show-modified.png" alt=""></p><p><strong>实例：6. 创建新的输出域</strong></p><p>描述：创建新域6保存目前访问次数大于序号的减法值，表达式为’{$6=$5-$1}’，只打印其值大于零的序号和其新域值。在BEGIN部分加入tab键以对齐报告头。也可以赋给新域更有意义的变量名。<br>命令：<code>awk &#39;BEGIN {print &quot;IP\t Difference&quot;} {if ($5 &gt; $1) {$6=$5-$1; print $1 &quot;\t&quot; $6}}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-add-new-domain.png" alt=""></p><p><strong>实例：7. 增加列值</strong></p><p>描述：使用+=累加访问次数的值。awk的每一个操作匹配时，如果没有说明打印记录，那默认会打印所有记录。<br>命令：<code>awk &#39;(total+=$5); END {print &quot;total visits : &quot; total}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-add-column-value.png" alt=""></p><p><strong>实例：8. 文件长度相加</strong></p><p>描述：查看当前目录中所有文件的长度及其综合，但要排除子目录，使用ls -l命令，然后管道输出到awk，awk首先剔除首字符d（/^[^d]/）的记录，然后将文件长度相加，并输出每一文件长度及在END部分输出所有文件的长度。<br>命令：<code>ls -l | awk &#39;/^[^d]/ {print $9&quot;\t&quot;$5} {total+=$5} END {print &quot;total KB: &quot; total}&#39;</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-acc-file-size.png" alt=""></p><h3 id="内置字符串函数"><a href="#内置字符串函数" class="headerlink" title="内置字符串函数"></a>内置字符串函数</h3><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-string-function.png" alt=""></p><p>gsub类似于sed查找和替换。它允许替换一个字符串或字符为另一个字符串或字符，并以正则表达式的形式执行，第一个函数作用于记录$0，第二个gsub函数允许指定目标，如果未指定，默认是$0。<br>index(s, t)函数返回目标字符串s中查询字符串t的首位置。<br>length函数返回字符串s字符长度。<br>match函数测试字符串s是否包含一个正则表达式r定义的匹配。<br>split函数使用域分隔符fs，将字符串s划分为指定序列a。<br>sprint函数类似于printf函数，返回基本输出格式fmt的结果字符串exp。<br>sub(r, s)函数将用s代替$0中最左边最长的子串，该子串被（r）匹配。<br>sub(s, p)返回字符串s在位置p后的后缀部分。<br>substr(s, p, n)函数返回字符串s在位置p后长度为n的后缀部分。</p><p><strong>实例：1. gsub</strong></p><p>描述：匹配记录中访问时间为11:35的记录，修改为11:40。注意要用双引号括起来。<br>命令：<code>awk &#39;gsub(/11:35/, &quot;11:40&quot;) {print $0}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-gsub.png" alt=""></p><p><strong>实例：2. index</strong><br>描述：匹配字符串Honey中，ney子串第一次出现的位置，即字符个数。<br>命令：<code>awk &#39;BEGIN {print index(&quot;Honey&quot;, &quot;ney&quot;)}&#39;</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-index.png" alt=""></p><p><strong>实例：3. length</strong></p><p>描述：匹配序号为6，第二个域的字符长度。也可以直接使用字符串。<br>命令：<code>awk &#39;$1==6 {print length($2) &quot;---&quot; $2}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-length.png" alt=""></p><p><strong>实例：4. match</strong></p><p>描述：match测试目标字符串是否包含查找字符的一部分，可以使用正则表达式。<br>命令：<br>在AWK中查找d，因其不存在，所以返回0。<br><code>awk &#39;BEGIN {print match(&quot;AWK&quot;, /d/)}&#39;</code><br>在AWK中查找K，因其存在，所有返回AWK中K出现的首位置字符数。<br><code>awk &#39;BEGIN {print match(&quot;AWK&quot;, /K/)}&#39;</code><br>在序号为6的记录中，查找Android的大版本号。<br><code>awk &#39;$1==6 {print match($2, &quot;7&quot;)}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-match.png" alt=""></p><p><strong>实例：5. split</strong></p><p>描述：如果域中具有分隔符形式的字符串，使用split函数将其分隔，并保存到一个数组中，最后将数组的第一个元素打印出来。<br>命令：<code>awk &#39;BEGIN {print split(&quot;123#456#789&quot;, myarray, &quot;#&quot;)}&#39;</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-split.png" alt=""></p><p><strong>实例：6. sub</strong></p><p>描述：匹配所有Android，替换为android。注意只在模式第一次出现时进行替换操作。<br>命令：<code>awk &#39;sub(/Android/, &quot;android&quot;)&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-sub.png" alt=""></p><p><strong>实例：7. substr</strong></p><p>描述：匹配第二个域版本信息中，打印从第一个字符开始到第七个字符。如果给定的长度值远大于字符串长度，awk将从起始位置返回所有字符。另一种形式是返回字符串后缀或指定位置后面的字符。<br>命令：<code>awk &#39;$1==5 {print substr($2,1,7)}&#39; device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-substr.png" alt=""></p><p><strong>实例：8. 从shell向awk传入字符串</strong><br>命令：<br>使用管道将字符串powerful传入awk，返回其长度。<br><code>echo &quot;powerful&quot; | awk &#39;{print length($0)}&#39;</code><br>设置文件名为一变量，管道输出到awk，但会不带扩展名的文件名。<br><code>STR=&quot;myawk.txt&quot; | echo $STR | awk &#39;{print substr($STR,1,5)}&#39;</code><br>设置文件名为一变量，管道输出到awk，只返回其扩展名。<br><code>TR=&quot;myawk.txt&quot; | echo $STR | awk &#39;{print substr($STR,7)}&#39;</code></p><p>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-shell.png" alt=""></p><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-escape.png" alt=""></p><h3 id="printf修饰符"><a href="#printf修饰符" class="headerlink" title="printf修饰符"></a>printf修饰符</h3><p>基本语法：<code>printf([格式控制符], 参数)</code><br>格式控制符通常在引号里。</p><p>awkprintf修饰符：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-printf-table.png" alt=""></p><p>awk printf格式：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-printf-format-table.png" alt=""></p><p><strong>实例：1. 字符转换</strong><br>描述：通过管道输出65到awk中，printf进行ASCII码字符转换。<br>命令：<br><code>echo &quot;65&quot; | awk &#39;{printf (&quot;%c\n&quot;, $0)}&#39;</code><br>或者<br><code>awk &#39;BEGIN {printf &quot;%c\n&quot;, 65}&#39;</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-char-convert.png" alt=""></p><p>描述：数字1024转换为浮点数之后，被加入了六个小数点。<br>命令：<br><code>awk &#39;BEGIN {printf &quot;%f\n&quot;, 1024}&#39;</code> </p><p>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-number-convert.png" alt=""></p><p><strong>实例：2. 格式化输出</strong></p><p>描述：BEGIN后的第一个花括号嵌入头信息，第二个花括号打印所有用户的IP地址和访问时间，要求IP地址左对齐，23个字符长度，后跟访问时间。<br>命令：<br><code>awk &#39;BEGIN {print &quot;IP\t\t\tTime&quot;} {printf &quot;%-23s %s\n&quot;, $4, $3}&#39; device</code> </p><p>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-printf-format.png" alt=""></p><p><strong>实例：3. 向一行awk命令传值</strong></p><p>描述：在命令行中设置VISITS等于10，然后传入awk中，查询访问次数大于10的所有记录。<br>命令：<code>awk &#39;{if($5 &gt; VISITS) print $0} &#39; VISITS=10 device</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-command-line-pass-to-awk.png" alt=""></p><p>描述：用管道将df -k传入awk，然后抽出第四列，即剩余可利用空间容量。使用$4 ~ /^[0-9]/取得容量数值，最后对命令行if($4 &lt; TRIGGER)上变量TRIGGER的值进行查询。<br>查看文件系统空间容量，观察其是否达到一定水平。因为要监视的已使用空间容量不断在变化，所以需要再命令行指定一个触发值。<br>命令：<code>df -k | awk &#39;($4 ~ /^[0-9]/) {if ($4 &lt; TRIGGER) printf &quot;%-15s %s\n&quot;,$6,$4}&#39; TRIGGER=930000</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-df.png" alt=""></p><p>描述：打印当前注册用户，并加入一定信息。<br>命令：<code>who | awk &#39;{print $1 &quot; is logged on&quot;}&#39;</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-who.png" alt=""></p><p>描述：传入环境变量LOGNAME，显示当前用户名。<br>命令：<code>who | awk &#39;{if ($1 == user) print $1&quot; you are connected to &quot; $2}&#39; user=$LOGNAME&quot;}&#39;</code><br>输出：</p><p><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-env-variable.png" alt=""></p><p><strong>实例：4. awk脚本文件</strong></p><p>描述：第一行#! /usr/bin/awk -f告知脚本系统awk命令的位置。在脚本文件后键入文件名之前，需要先对脚本文件加入可执行权限。<br>命令：<code>chmod u+x user_tot.awk</code><br>user_tot.awk脚本文件：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-user-tot.png" alt=""></p><p>描述：执行user_tot.awk脚本文件。<br>命令：<code>./user_tot.awk device</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-run-user-tot.png" alt=""></p><p><strong>实例：5. 在awk中使用FS变量</strong></p><p>描述：从/etc/passwd文件中抽取第1和第5域，通过FS变量，指定冒号:分隔passwd文件域。第1域时账号名，第5域是账号所有者。<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-passwd-file.png" alt=""><br>命令：<code>chmod u+x passwd.awk | ./passwd.awk /etc/passwd</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-run-passwd.png" alt=""></p><p><strong>实例：6. 向awk脚本传值</strong></p><p>向awk脚本传值与向awk一行命令传值的方式大体相同，格式为：<br><code>awk script_file var=value input_file</code></p><p>描述：对比检查文件中域号和指定数字。注意不要忘了增加脚本的可执行权限。<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-fieldcheck-file.png" alt=""><br>命令：<code>chmod u+x fieldcheck.awk | ./fieldcheck.awk MAX=7 FS=&quot;:&quot; /etc/passwd</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-run-fieldcheck.png" alt=""></p><p>描述：从du命令获得输入，并输出块和字节数。<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-duawk-file.png" alt=""><br>命令：<code>chmod u+x duawk.awk | du /root | ./duawk.awk</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-run-duawk.png" alt=""></p><p><strong>实例：9. awk数组</strong></p><p>描述：用split将123#456#789划分开，并存入myarray数组，再使用循环打印各数组元素。<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-array-file.png" alt=""><br>命令：<code>chmod u+x duawk.awk | du /root | ./duawk.awk</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-script-run-array.png" alt=""></p><p><strong>实例：10. 处理由通配符指定的多个文件名</strong></p><p>描述：打印当前目录中以.txt结尾的文件。nextfile告诉awk停止处理当前的输入文件。下一个输入记录读取来自下一个输入文件。<br>命令：<br><code>awk &#39;{ print FILENAME; nextfile } &#39; *.txt</code><br><code>awk &#39;BEGIN{ print &quot;Starting...&quot;} { print FILENAME; nextfile }END{ print &quot;....DONE&quot;} &#39; *.txt</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/awk/awk-multiple-filename.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;awk命令在文件或字符串中基于指定规则浏览和抽取信息。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.oxysun.cn/categories/linux/"/>
    
      <category term="shell" scheme="http://www.oxysun.cn/categories/linux/shell/"/>
    
    
      <category term="Linux" scheme="http://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB：创建数据集合</title>
    <link href="http://www.oxysun.cn/mongodb/mongodb-collection-create.html"/>
    <id>http://www.oxysun.cn/mongodb/mongodb-collection-create.html</id>
    <published>2018-06-30T07:53:48.000Z</published>
    <updated>2018-06-30T10:18:39.724Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB如何创建数据集合（collection）。<br><a id="more"></a></p><p>官网地址：<a href="https://docs.mongodb.com/manual/reference/method/db.createCollection/#db.createCollection。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/method/db.createCollection/#db.createCollection。</a></p><p>这节有点混乱，也有点尴尬，因为原本MongoDB就有些“没有规矩”。</p><p>快速创建一个集合，参考<a href="https://blog.csdn.net/chaiyu2002/article/details/80862002" target="_blank" rel="noopener">插入</a>这一节。</p><p>集合不存在的情况下，插入一条记录就会创建集合。</p><p>稍微啰嗦一点，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.test.insert(&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080199&quot;),</span><br><span class="line">    &quot;meta&quot; : &#123;</span><br><span class="line">        &quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">        &quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;a&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;b&quot; : &quot;1&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure><p>这样即会创建集合test，又会给这个集合插入一条记录。</p><p>非要规矩地创建（其实是可以设置一些选项），那么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&lt;name&gt;, &#123; capped: &lt;boolean&gt;,</span><br><span class="line">                              autoIndexId: &lt;boolean&gt;,</span><br><span class="line">                              size: &lt;number&gt;,</span><br><span class="line">                              max: &lt;number&gt;,</span><br><span class="line">                              storageEngine: &lt;document&gt;,</span><br><span class="line">                              validator: &lt;document&gt;,</span><br><span class="line">                              validationLevel: &lt;string&gt;,</span><br><span class="line">                              validationAction: &lt;string&gt;,</span><br><span class="line">                              indexOptionDefaults: &lt;document&gt;,</span><br><span class="line">                              viewOn: &lt;string&gt;,</span><br><span class="line">                              pipeline: &lt;pipeline&gt;,</span><br><span class="line">                              collation: &lt;document&gt;,</span><br><span class="line">                              writeConcern: &lt;document&gt;&#125; )</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>字符串</td><td>要创建的集合的名称。</td></tr><tr><td>options</td><td>文档</td><td>可选。一大堆选项，暂时没用到，将来再补充了。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB如何创建数据集合（collection）。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB：创建数据库</title>
    <link href="http://www.oxysun.cn/mongodb/mongodb-dababase-create.html"/>
    <id>http://www.oxysun.cn/mongodb/mongodb-dababase-create.html</id>
    <published>2018-06-30T07:53:48.000Z</published>
    <updated>2018-06-30T10:15:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB如何创建数据库。<br><a id="more"></a></p><p>官网位置：<a href="https://docs.mongodb.com/manual/mongo/。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/mongo/。</a></p><p>初衷：MongoDB的使用还是有一定难度的，官网讲解的一环牵扯一环，不容易一下子把握住重点，也不利于快速查询操作，所以整理一下。</p><p>进入mongo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# mongo</span><br><span class="line">MongoDB shell version: 2.6.10</span><br><span class="line">connecting to: test</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>如果没有mongo这个命令，表示路径没有配置好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use &lt;database&gt;</span><br></pre></td></tr></table></figure><p>尖括号表示需要你替换的变量，别完全照搬，当年我是犯过这种很<code>猪头</code>的错误的，你不要证明你也<code>猪头</code>了。</p><p>如果数据库存在，这条命令会切换到该数据库，如果不存在，则创建并切换到该数据库。</p><p><strong>实例</strong>：创建一个数据库，名字为my_test。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use my_test</span><br><span class="line">switched to db my_test</span><br></pre></td></tr></table></figure><p>好，创建成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB如何创建数据库。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
</feed>
