<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老兵驿站</title>
  
  <subtitle>一个IT老兵的驿站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.oxysun.cn/"/>
  <updated>2018-07-23T13:34:13.622Z</updated>
  <id>https://www.oxysun.cn/</id>
  
  <author>
    <name>荒于嬉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB的基本操作：删除记录（删）</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-collection-delete.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-collection-delete.html</id>
    <published>2018-07-23T13:29:48.000Z</published>
    <updated>2018-07-23T13:34:13.622Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的基本操作：删除记录（删）。<br><a id="more"></a></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>删除记录有两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.2版本之前</span><br><span class="line">db.collection.remove() //</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.2版本之后</span><br><span class="line"> - db.collection.deleteMany() //删除匹配条件的多条记录</span><br><span class="line"> - db.collection.deleteOne() //删除匹配条件的单条记录</span><br></pre></td></tr></table></figure><p>括号里面的参数是查询过滤器。</p><h1 id="查询过滤器："><a href="#查询过滤器：" class="headerlink" title="查询过滤器："></a><a href="https://docs.mongodb.com/v3.6/core/document/#document-query-filter" target="_blank" rel="noopener">查询过滤器</a>：</h1><p>查询过滤器用来设定查询条件。</p><p>格式<code>&lt;field&gt;:&lt;value&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &lt;field1&gt;: &lt;value1&gt;,</span><br><span class="line">  &lt;field2&gt;: &#123; &lt;operator&gt;: &lt;value&gt; &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>实例：</strong>删除前文test数据库中所有记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.deleteMany(&#123;&#125;);</span><br></pre></td></tr></table></figure><p><code>{}</code>表示没有约束条件。</p><p><strong>实例：</strong>删除前文test数据库中_id为5abb3b5bce69c048be080199的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.deleteMany(&#123;_id: ObjectId(&quot;5abb3b5bce69c048be080199&quot;)&#125;);</span><br></pre></td></tr></table></figure><p>笔记整理到这里，发现之前的记录有点问题，因为对MongoDB的官网的结构没有完全搞清楚，所以，之前的基本操作更多偏向于参考手册的层面，可能还需要修改和调整一下。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://docs.mongodb.com/manual/tutorial/remove-documents/。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/remove-documents/。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB的基本操作：删除记录（删）。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>JS：逻辑操作符“||”、“&amp;&amp;”和“!”</title>
    <link href="https://www.oxysun.cn/js/js-logical-operator.html"/>
    <id>https://www.oxysun.cn/js/js-logical-operator.html</id>
    <published>2018-07-19T15:00:00.000Z</published>
    <updated>2018-07-22T08:48:34.239Z</updated>
    
    <content type="html"><![CDATA[<p>JS：逻辑操作符“||”、“&amp;&amp;”和“!”。<br><a id="more"></a></p><table><thead><tr><th>Operator</th><th>Usage</th><th>Description</th></tr></thead><tbody><tr><td>Logical AND (&amp;&amp;)</td><td>expr1 &amp;&amp; expr2</td><td>Returns expr1 if it can be converted to false; otherwise, returns expr2. Thus, when used with Boolean values, &amp;&amp; returns true if both operands are true; otherwise, returns false.</td></tr><tr><td>Logical OR (&#124;&#124;)</td><td>expr1 &#124;&#124; expr2</td><td>Returns expr1 if it can be converted to true; otherwise, returns expr2. Thus, when used with Boolean values, &#124;&#124; returns true if either operand is true.</td></tr><tr><td>Logical NOT (!)</td><td>!expr</td><td>Returns false if its single operand can be converted to true; otherwise, returns true.</td></tr></tbody></table><p>翻译一下：</p><table><thead><tr><th>操作符</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>逻辑和 (&amp;&amp;)</td><td>expr1 &amp;&amp; expr2</td><td>如果expr1可以被转换为false，那么返回expr1，否则，返回expr2。 如果使用的是布尔值，那么仅当两个操作数都为真时，返回true；否则，返回false</td></tr><tr><td>逻辑或 (&#124;&#124;)</td><td>expr1 &#124;&#124; expr2</td><td>如果expr1可以被转换为true，返回expr1；否则，返回expr2。如果是布尔值，则两个操作数中有一个位true就返回true。</td></tr><tr><td>逻辑非 (!)</td><td>!expr</td><td>如果这个操作数可以转换为true，返回false，否则，返回true</td></tr></tbody></table><p>以下这些表达式都可以转换为false：</p><ul><li>null;</li><li>NaN;</li><li>0;</li><li>empty string (“” or ‘’); </li><li>undefined.</li></ul><p><br><br>这样就比较清楚了。</p><p>需要注意的是：操作符有一个优先级的规定，可以参考：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence。" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence。</a></p><p>参考：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators。" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS：逻辑操作符“||”、“&amp;amp;&amp;amp;”和“!”。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.oxysun.cn/categories/JavaScript/"/>
    
    
      <category term="JS,逻辑操作符" scheme="https://www.oxysun.cn/tags/JS-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>程序员晋升之路：生存意识、服务意识--IT老兵的心得</title>
    <link href="https://www.oxysun.cn/thinking%20in%20programmer%20life/full-stack-programmer.html"/>
    <id>https://www.oxysun.cn/thinking in programmer life/full-stack-programmer.html</id>
    <published>2018-07-18T15:15:33.000Z</published>
    <updated>2018-07-22T07:27:09.079Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>这篇文章原载于新浪博客，写于2017-06-06<br>23:15:33，现在因为建立了自己的博客，所以迁过来，也转载在CSDN上，同时又加上“时过境迁”，又会有一些新的思考，所以修改一下，修改的地方以备注的形式展示出来，可以看出一些心态的不同来。</p></blockquote><p>有一个程序员，学过前端、学过iOS，或者这么说，他喜欢研究技术，而且能把所研究的技术都搞得明明白白，但是他做项目，从来不排期，不汇报，也从来不怎么理会产品设计，结果他什么好的产品都做不出来。</p><blockquote><p>这些是在厦门遇到了一个程序员所发出的感想，到了今时今日，据我了解，他还是什么都没有做出来</p></blockquote><p>做不出好的产品来，是一个好的程序员吗？</p><p>技术都会过时的，最新的技术也不见得是最好的技术，那么技术人员的使命是什么呢？</p><p>掌握了那么复杂的C++就算是好的程序员了吗？</p><blockquote><p>实际上，很多年了，C++程序员都缺乏用武之地了—-直到今天的区块链的火热，才又唤起市场对C++程序员的需求。</p></blockquote><p>或者说，现在所鼓吹的全栈，你成为全栈了，就是好的程序员了吗？</p><p>我觉得都不是。</p><p>你用你的能力，掌握了技术，能够很好服务于你的公司，服务于社会，这才是好的程序员。</p><p>技术是为人类服务的，脱离了服务，再尖端的技术又有什么用呢？脱离了服务，掌握了再尖端的技术的程序员，又有什么用呢？</p><p>要使用你的技术，去提供服务，换取你的合理报酬，这就是生存意识。</p><p>掌握社会服务所需要的，或者是将要需要的技术，去提供服务，换取更好的报酬，这就是生存意识。</p><p>固守于一门很复杂的语言，为自己掌握了它而别人没有掌握而沾沾自喜，却不思考这门语言对于提供服务的价值和意义，这就已经完全走偏了，惑于技巧的层面，而忽略了根本的初衷，我们不是为了学技术而学技术的，技术也从来不是为了让你学而产生的。如果一门技术，已经不能很好地服务于社会，那怕它再难，学习起来再有挑战性，对你来说只能是满足征服的快乐，而不是满足你谋生、立业的人生目标。</p><p>放下心中自己围起来的那道技术的篱笆，不拘一格地去掌握那些需要你掌握的技术，做出好的产品来提供你的服务。</p><p>不要太在意这个技术是你新学的，也许掌握的还没有那么扎实，也许写出来的代码还没有那么漂亮，这些都会慢慢变好的，因为你写的代码，做出的产品有人在使用，这就要比那些写的很漂亮，但是没人用，只能束之高阁的代码要强太多了。代码不被使用，再漂亮，也缺乏生命力。</p><blockquote><p>代码也是有生命的，这是我的感觉，所以，我们需要好好去维护她，不断去调整她。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章原载于新浪博客，写于2017-06-06&lt;br&gt;23:15:33，现在
      
    
    </summary>
    
      <category term="程序人生" scheme="https://www.oxysun.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Git：checkout的用法（1）</title>
    <link href="https://www.oxysun.cn/git/git-checkout-1.html"/>
    <id>https://www.oxysun.cn/git/git-checkout-1.html</id>
    <published>2018-07-17T15:00:00.000Z</published>
    <updated>2018-07-18T11:09:55.838Z</updated>
    
    <content type="html"><![CDATA[<p>Git的checkout的用法。<br><a id="more"></a></p><h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p><code>checkout</code>是<code>Git</code>最常用的命令之一，但又是有些复杂的命令，总会感觉有些用不明白，用不明白的原因应该是没有深度地、全面地理解一下，所以要对它好好整理一下。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>checkout</code>在<code>CVS</code>和<code>SVN</code>中都是检出的意思，从版本库检出一个版本，在<code>Git</code>中就不是这么简单了。手册上是这样介绍的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-checkout - Switch branches or restore working tree files</span><br></pre></td></tr></table></figure><p>在<code>Git</code>里面，<code>checkout</code>用于切换分支或者恢复工作树的文件。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>问题：</strong>线上分支出现了一个问题，急需要修复（可以参看Git Flow一章）。<br><strong>步骤：</strong></p><ol><li>需要创建一个hotfix分支，参考语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;]</span><br></pre></td></tr></table></figure></li></ol><p>实际语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hotfix-1.2.1 master</span><br></pre></td></tr></table></figure></p><p>这个时候分支是本地分支，并没有提交到服务器上去，如果这个分支已经被创建，这个命令会失败，这个时候，如果想要重置这个分支，需要使用<code>-B</code>参数。</p><ol start="2"><li>查看分支：<code>git branch -av</code></li><li>进行修改工作</li><li>……</li></ol><p><strong>问题：</strong>本地发生了一些修改，但是想放弃这些修改，回退到获取这个版本初始时的状态。<br>参考语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br></pre></td></tr></table></figure></p><p>实际语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout 26a2e80 # 26a2e80 是一个commit号，这个命令会把index区域和工作区域的内容都更新</span><br><span class="line">git checkout -- README # README是想恢复的文件名，恢复成index区域里面的内容，为什么要加“--”呢，这个是为了告诉Git，这是一个文件而不是一个分支</span><br><span class="line">Git checkout . # 从index区域恢复所有文件</span><br></pre></td></tr></table></figure></p><p>这个命令很灵活，既可以带一个<code>commit</code>号，又可以带着一个路径，<code>tree-ish</code> 可以理解成一个<code>commit</code>号，就是恢复到某一个<code>commit</code>号，<code>index</code>就是暂存区，这里要理解<code>Git</code>的三个区域，如果这个还不明白，那需要单开一篇文章去讲了。</p><p>以上是checkout比较常用的两个用法，逐步整理其他的用法。</p><p>参考：<a href="https://git-scm.com/docs/git-checkout。" target="_blank" rel="noopener">https://git-scm.com/docs/git-checkout。</a><br><a href="https://stackoverflow.com/questions/14460595/git-checkout-with-dot。" target="_blank" rel="noopener">https://stackoverflow.com/questions/14460595/git-checkout-with-dot。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git的checkout的用法。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：top</title>
    <link href="https://www.oxysun.cn/linux/shell-command-top.html"/>
    <id>https://www.oxysun.cn/linux/shell-command-top.html</id>
    <published>2018-07-13T14:20:23.000Z</published>
    <updated>2018-07-18T11:09:55.845Z</updated>
    
    <content type="html"><![CDATA[<p><code>top</code>命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的使用工具。<code>top</code>命令提供了互动式的界面，用热键管理。这个命令是一个非常重要和常用的命令，但是同时也有点复杂，参数较多，怎么能够掌握好呢？用了这么多年，也都一直没有用好。老老实实读一遍手册，总体了解一下都有什么才好去做整理，有的时候可能连它都有什么功能都不知道。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>top [选项]</code></p><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p><code>top</code>命令用来显示<code>Linux</code>的处理器活动和内核实时管理的任务。它会显示正在使用的处理器和内存以及运行进程等其他信息。</p><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul><li>-b：以批处理模式操作。</li><li>-c：显示完整的命令。</li><li>-d：屏幕刷新间隔时间。</li><li>-I：忽略失效过程。</li><li>-s：保密模式。</li><li>-S：累积模式。</li><li>-i&lt;时间&gt;：设置间隔时间。</li><li>-u&lt;用户名&gt;：指定用户名。</li><li>-p&lt;进程号&gt;：指定进程。</li><li>-n&lt;次数&gt;：循环显示的次数。</li></ul><h2 id="top交互命令"><a href="#top交互命令" class="headerlink" title="top交互命令"></a><code>top</code>交互命令</h2><p>在<code>top</code>命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。</p><ul><li>h：显示帮助画面，给出一些简短的命令总结说明。</li><li>k：终止一个进程。</li><li>i：忽略闲置和僵死进程，这是一个开关式命令。</li><li>q：退出程序。</li><li>r：重新安排一个进程的优先级别。</li><li>S：切换到累计模式。</li><li>s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s。</li><li>f或者F：从当前显示中添加或者删除项目。</li><li>o或者O：改变显示项目的顺序。</li><li>l：切换显示平均负载和启动时间信息。</li><li>m：切换显示内存信息。</li><li>t：切换显示进程和CPU状态信息。</li><li>c：显示进程启动时的完整路径和程序名。</li><li>M：根据驻留内存大小进行排序。</li><li>P：根据CPU使用百分比大小进行排序。</li><li>T：根据时间/累计时间进行排序。</li><li>w：将当前设置写入~/.toprc文件中。</li></ul><h2 id="界面解释"><a href="#界面解释" class="headerlink" title="界面解释"></a>界面解释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 21:52:52 up 247 days,  6:23,  2 users,  load average: 0.09, 0.12, 0.13</span><br><span class="line">Tasks: 126 total,   1 running, 125 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  4.0 us,  2.3 sy,  0.0 ni, 93.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  3881808 total,   153396 free,  3577588 used,   150824 buff/cache</span><br><span class="line">KiB Swap:  4063228 total,  1206484 free,  2856744 used.    86344 avail Mem</span><br></pre></td></tr></table></figure><p>统计信息区前五行是系统整体的统计信息。<br><strong>系统运行时间和平均负载</strong><br>第一行是任务队列信息，同uptime命令的执行结果，可以使用l命令切换uptime的显示。其内容如下：</p><ul><li>21:52:52：当前时间。</li><li>up 247 days, 6:23：系统运行时间。</li><li>2 users：当前登录用户数。</li><li>load average: 0.09, 0.12, 0.13：系统负载，即任务队列平均长度。分别为1、5、15min前到现在平均值。</li></ul><p><strong>进程</strong><br>第二行为进程信息。内容如下：</p><ul><li>126 total：进程总数[键入H可查看线程数]。</li><li>1 running：正在运行的进程。</li><li>125 sleeping：睡眠进程。</li><li>0 stopped：停止的进程。</li><li>0 zombie：僵尸进程数。</li></ul><p><strong>CPU状态</strong><br>第三行为CPU状态信息，当有多个CPU时，这些内容可能会超过两行。内容如下：</p><ul><li>us, user：运行(未调整优先级的) 用户进程的CPU百分比。</li><li>sy，system：运行内核进程的CPU百分比。</li><li>ni，niced：运行已调整优先级的用户进程的CPU百分比。</li><li>wa，IO wait：用于等待IO完成的CPU百分比。</li><li>hi：处理硬件中断的CPU百分比。</li><li>si：处理软件中断的CPU百分比。</li><li>st：这个虚拟机被hypervisor偷去的CPU百分比。（译注：如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）。</li></ul><p><strong>内存使用</strong><br>倒数第2、3行为内存相关信息，内存显示可以用m命令切换：</p><ul><li>KiB Mem: 3881808 total,   153396 free：分别是物理内存总量、空闲内存总量。</li><li>3577588 used,   150824 buff/cache：使用物理内存总量、用作内核缓存内存量。</li><li>KiB Swap: 4063228 total,  1206484 free：分别是交换分区总量、使用交换分区剩余量。</li><li>2856744 used.    86344 avail Mem：可用来启动应用的内存（有些复杂，以后解释，恶意参考<a href="https://unix.stackexchange.com/questions/390518/what-do-the-buff-cache-and-avail-mem-fields-in-top-mean" target="_blank" rel="noopener">这里</a>）。</li></ul><p><strong>字段/列</strong><br>最后一行则是进程相关的资源占用信息：</p><ul><li>PID：进程的ID，进程的唯一标识符。</li><li>USER：进程所有者的实际用户名。</li><li>PR：进程的优先级别，范围0-39，越小越优先被执行。</li><li>NI：nice值。范围-20-19，负值表示高优先级，正值表示低优先级。在top里，PR-NI=20，默认启动一个进程，nice是0。</li><li>VIRT：进程占用的虚拟内存。</li><li>RES：进程占用的物理内存。</li><li>SHR：进程使用的共享内存。</li><li>S：进程的状态。<ul><li>D：表示不可终端的睡眠状态。</li><li>R：表示正在运行。</li><li>S：表示休眠。</li><li>T：表示作业控制信号下已停止。</li><li>t：表示在调试状态的停止。</li><li>Z：表示僵死状态。</li></ul></li><li>%CPU：自从上一次更新到现在任务所使用的CPU使用率。</li><li>%MEM：进程使用的物理内存和总内存的百分比。</li><li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值，精确到百分之一秒。</li><li>COMMAND：进程启动命令名称。</li></ul><h2 id="交互命令实例"><a href="#交互命令实例" class="headerlink" title="交互命令实例"></a>交互命令实例</h2><p><strong>实例：<code>h</code>：帮助</strong><br>描述：在<code>top</code>状态下，按<code>h</code>键或者<code>?</code>键显示交互命令的帮助菜单。<br>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Help for Interactive Commands - procps-ng version 3.3.10</span><br><span class="line">Window 1:Def: Cumulative mode Off.  System: Delay 3.0 secs; Secure mode Off.</span><br><span class="line"></span><br><span class="line">  Z,B,E,e   Global: &apos;Z&apos; colors; &apos;B&apos; bold; &apos;E&apos;/&apos;e&apos; summary/task memory scale</span><br><span class="line">  l,t,m     Toggle Summary: &apos;l&apos; load avg; &apos;t&apos; task/cpu stats; &apos;m&apos; memory info</span><br><span class="line">  0,1,2,3,I Toggle: &apos;0&apos; zeros; &apos;1/2/3&apos; cpus or numa node views; &apos;I&apos; Irix mode</span><br><span class="line">  f,F,X     Fields: &apos;f&apos;/&apos;F&apos; add/remove/order/sort; &apos;X&apos; increase fixed-width</span><br><span class="line"></span><br><span class="line">  L,&amp;,&lt;,&gt; . Locate: &apos;L&apos;/&apos;&amp;&apos; find/again; Move sort column: &apos;&lt;&apos;/&apos;&gt;&apos; left/right</span><br><span class="line">  R,H,V,J . Toggle: &apos;R&apos; Sort; &apos;H&apos; Threads; &apos;V&apos; Forest view; &apos;J&apos; Num justify</span><br><span class="line">  c,i,S,j . Toggle: &apos;c&apos; Cmd name/line; &apos;i&apos; Idle; &apos;S&apos; Time; &apos;j&apos; Str justify</span><br><span class="line">  x,y     . Toggle highlights: &apos;x&apos; sort field; &apos;y&apos; running tasks</span><br><span class="line">  z,b     . Toggle: &apos;z&apos; color/mono; &apos;b&apos; bold/reverse (only if &apos;x&apos; or &apos;y&apos;)</span><br><span class="line">  u,U,o,O . Filter by: &apos;u&apos;/&apos;U&apos; effective/any user; &apos;o&apos;/&apos;O&apos; other criteria</span><br><span class="line">  n,#,^O  . Set: &apos;n&apos;/&apos;#&apos; max tasks displayed; Show: Ctrl+&apos;O&apos; other filter(s)</span><br><span class="line">  C,...   . Toggle scroll coordinates msg for: up,down,left,right,home,end</span><br><span class="line"></span><br><span class="line">  k,r       Manipulate tasks: &apos;k&apos; kill; &apos;r&apos; renice</span><br><span class="line">  d or s    Set update interval</span><br><span class="line">  W,Y       Write configuration file &apos;W&apos;; Inspect other output &apos;Y&apos;</span><br><span class="line">  q         Quit</span><br><span class="line">          ( commands shown with &apos;.&apos; require a visible task display window ) </span><br><span class="line">Press &apos;h&apos; or &apos;?&apos; for help with Windows,</span><br><span class="line">Type &apos;q&apos; or &lt;Esc&gt; to continue</span><br></pre></td></tr></table></figure><p><strong>实例：显示各个CPU负载</strong><br>描述：在<code>top</code>状态下，按下“1”，可以显示每个CPU的负载情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 22:30:09 up 247 days,  7:00,  2 users,  load average: 0.16, 0.14, 0.14</span><br><span class="line">Tasks: 126 total,   1 running, 125 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.3 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu2  :  0.3 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu3  :  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  3881808 total,   141164 free,  3578540 used,   162104 buff/cache</span><br><span class="line">KiB Swap:  4063228 total,  1206756 free,  2856472 used.    79768 avail Mem</span><br></pre></td></tr></table></figure><p><strong>实例：手动刷新</strong><br>描述：在<code>top</code>状态下，按空格或者回车进行手动刷新。top命令默认在一个特定间隔（3秒）后刷新显示。</p><p><strong>实例：<code>A</code>：切换交替显示模式</strong></p><p>描述：在<code>top</code>状态下，按<code>A</code>键，可以在全屏和交替模式间切换。在交替模式下会显示4个窗口。</p><ul><li>Def（默认字段组）</li><li>Job（任务字段组）</li><li>Mem（内存字段组）</li><li>Usr（用户字段组）</li></ul><p>这四组字段共有一个独立的可配置的概括区域和它自己的可配置任务区域。4个窗口中只有一个窗口是当前窗口。当前窗口的名称显示在左上方。只有当前窗口才会接受你键盘交互命令。<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-A.png" alt=""><br>可以用<code>a</code>和<code>w</code>在4个窗口间切换，<code>a</code>移到后一个窗口，<code>w</code>移到前一个窗口。用<code>g</code>命令可以输入一个数字来选择当前窗口。<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-switch.png" alt=""></p><p><strong>实例：<code>B</code>：粗体显示</strong><br>描述：在<code>top</code>状态下，按<code>B</code>键，会将一些重要信息会以加粗字体显示。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-B.png" alt=""></p><p><strong>实例：<code>d</code>或<code>s</code>：设置显示的刷新间隔</strong><br>描述：在<code>top</code>状态下，按<code>d</code>键或者<code>s</code>键，设置显示的刷新间隔为1秒。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-d-s.png" alt=""></p><p><strong>实例：<code>f</code>：字段管理</strong><br>描述：在<code>top</code>状态下，按<code>f</code>键进入字段管理界面。d键选择要显示的字段，用*标记的是已选择的。上下光标键在字段内导航，左光标键可以选择字段，右光标键进入排序状态，此时按上下光标键可以进行上下移动，回车确认。s键设置当前排序的字段，q或Esc键退出。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-f.png" alt=""></p><p><strong>实例：<code>R</code>：反向排序</strong><br>描述：在<code>top</code>状态下，按<code>R</code>键切换反向/常规排序。</p><p><strong>实例：<code>c</code>：切换显示命令名称和完整命令行</strong><br>描述：在<code>top</code>状态下，按<code>c</code>键，切换是否显示进程启动时的完整路径和程序名。也可以使用如下命令行。<br>命令：<code>top -c</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-c.png" alt=""></p><p><strong>实例：<code>i</code>：空闲任务</strong><br>描述：在<code>top</code>状态下，按i键，切换显示空闲任务。<br>输出：<br>不显示空闲任务：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-i.png" alt=""></p><p><strong>实例：<code>V</code>：树视图</strong><br>描述：在<code>top</code>状态下，按V键，切换树视图。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-V.png" alt=""></p><p><strong>实例：<code>z</code>：切换彩色显示</strong><br>描述：在<code>top</code>状态下，按<code>z</code>键，切换彩色，即打开或关闭彩色显示。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-z-normal.png" alt=""></p><p><strong>实例：<code>Z</code>：改变配色</strong><br>描述：在<code>top</code>状态下，按<code>Z</code>键，显示一个改变<code>top</code>命令的输出颜色的屏幕。可以为8个任务区域选择8种颜色。<br>输出：<br>设置修改：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-Z.png" alt=""><br>显示效果：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-Z-show.png" alt=""></p><p><strong>实例：按照内存使用大小排序</strong><br>描述：在<code>top</code>状态下，按shift+m，可以按照内存使用大小排序进程。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-M.png" alt=""></p><p><strong>实例：<code>x、y</code>：切换高亮信息</strong><br>描述：在<code>top</code>状态下，按<code>x</code>键将排序字段高亮显示（纵列）；按<code>y</code>键将运行进程高亮显示（横行）。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-x-y.png" alt=""></p><p><strong>实例：<code>u</code>：特定用户的进程</strong><br>描述：在<code>top</code>状态下，按u键将会提示输入用户名，输入首显示特定用户的进程。空白将会显示全部用户。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-u.png" alt=""></p><p><strong>实例：<code>n或#</code>：任务的数量</strong><br>描述：在<code>top</code>状态下，按n键或者<code>#</code>键可以设置最大显示的任务数量。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-n-#.png" alt=""></p><p><strong>实例：<code>k</code>：结束任务</strong><br>描述：在<code>top</code>状态下，按<code>k</code>键输入<code>PID</code>后，发送信号给任务（通常是结束任务）。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-k.png" alt=""></p><p><strong>实例：<code>r</code>：重新设置优先级</strong><br>描述：在<code>top</code>状态下，按<code>r</code>键输入-20~19范围中的数字后，重新设置一个任务的调度优先级（nice值）。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-k.png" alt=""></p><h2 id="命令行实例"><a href="#命令行实例" class="headerlink" title="命令行实例"></a>命令行实例</h2><p><strong>实例：<code>-p</code>：监控特定的PID</strong><br>描述：-p选项监控指定的PID。PID的值为0将被作为top命令自身的PID。<br>命令：<code>top -p 0</code></p><p><strong>实例：<code>-u或-U</code>: 用户名或者UID</strong><br>描述：可以用这些选项浏览特定用户的进程。用户名或者UID可以在选项中指定。-p、-u和-U选项是互斥的，同时只可以使用这其中一个选项。试图组合使用这些选项时，会得到一个错误:<br>命令：<code>top -p 1248 -u root</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-U-p-u-error.png" alt=""></p><p><strong>实例：<code>-b</code>：批处理模式</strong><br>描述：-b选项以批处理模式启动top命令，在文件中保存输出时是很有用的。</p><p><strong>实例：<code>-c</code>：命令/程序名 触发:</strong><br>描述：显示进程启动时的完整路径和程序名。</p><p><strong>实例：<code>-d</code>：设置延迟间隔</strong><br>描述：设置top的显示间隔(以秒计)。<br>命令：<code>top -d 1</code></p><p><strong>实例：<code>-i</code>：切换显示空闲进程</strong><br>命令：<code>top -i</code></p><p><strong>实例：<code>-n</code>：特定重复次数后退出</strong><br>描述：top输出保持刷新，直到按q键或者到达指定次数。下面的命令将在10次重复之后自动退出。<br>命令：<code>top -n 10</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;top&lt;/code&gt;命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的使用工具。&lt;code&gt;top&lt;/code&gt;命令提供了互动式的界面，用热键管理。这个命令是一个非常重要和常用的命令，但是同时也有点复杂，参数较多，怎么能够掌握好呢？用了这么多年，也都一直没有用好。老老实实读一遍手册，总体了解一下都有什么才好去做整理，有的时候可能连它都有什么功能都不知道。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Shell" scheme="https://www.oxysun.cn/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git：Git merge的--ff和--no-ff</title>
    <link href="https://www.oxysun.cn/git/git-git-merge-ff-no-ff.html"/>
    <id>https://www.oxysun.cn/git/git-git-merge-ff-no-ff.html</id>
    <published>2018-07-12T14:07:00.000Z</published>
    <updated>2018-07-18T11:09:55.840Z</updated>
    
    <content type="html"><![CDATA[<p>Git：Git merge的–ff和–no-ff。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git merge最容易糊涂的地方就是这个<code>--ff</code>参数和<code>--no-ff</code> 参数，通过本文，把这个整理清楚。</p><p>其实官网讲的非常清楚，不过可能因为是英文的，所以大家阅读起来会有一些障碍。（PS：其实还是应该逐步逐步提高自己阅读英文文档的能力，想达到一个更高的高度，是需要客服自己本身很多的弱点的）</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>假设合并前的分支是这样，这个一个非常常见的场景，如果不明白，可以参考另外一篇文章Git Flow工作流：<br><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="这里写图片描述"><br>这是一个很常见的用例，功能开发分支是<code>iss53</code>，在开发新功能，<code>master</code>分支是线上分支，出现了问题，开辟了<code>hotfix</code>分支进行修复，修复完成，进行合并，需要把<code>hotfix</code>合并回<code>master</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>步骤如下：</p><ol><li>切换回master分支。</li><li>将hotfix分支合并会master分支。<br>然后看到了<code>Fast-forward</code> 的字样，这个词组的意思就是快进，播放电影的时候，可以注意一下，快进按钮上面就是这个词组。<br>那么实际变成了什么样呢？<br><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt="这里写图片描述"><br>仅仅是<code>master</code>指针指向了这个提交<code>C4</code>。这样是一种比较快的合并方式，轻量级，简单。<br>这个时候，我们往往会删掉<code>hotfix</code>分支，因为它的历史作用已经结束，这个时候，我们的<code>iss53</code>这个功能又向前开发，进行了一次提交，到了<code>C5</code>，那么变成了这样：<br><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="这里写图片描述"><br>然后，我们要把<code>iss53</code> 这个分支合并回<code>master</code>，就变成了这样：<br><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="这里写图片描述"><br>这个时候生成了一个新的<code>commit</code>号，这种提交就不是<code>fast-forward</code>（这个时候也无法生成<code>fast-forward</code>提交，因为要将两个版本的内容进行合并，只有在没有需要合并内容的时候，会有这个<code>fast-forward</code> 方式的提交）。<br>如果我们对第一次合并，使用了<code>--no-ff</code>参数，那么也会产生这样的结果，生成一个新的提交，实际上等于是对<code>C4</code> 进行一次复制，创建一个新的<code>commit</code>，这就是<code>--no-ff</code>的作用。<br><img src="https://i.stack.imgur.com/FMD5h.png" alt="这里写图片描述"></li></ol><p>参考：<a href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging，这里讲了原理。" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging，这里讲了原理。</a><br>参考：<a href="https://git-scm.com/docs/git-merge，这里是参考。" target="_blank" rel="noopener">https://git-scm.com/docs/git-merge，这里是参考。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git：Git merge的–ff和–no-ff。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu：新增和删除用户</title>
    <link href="https://www.oxysun.cn/linux/ubuntu-user-add-delete.html"/>
    <id>https://www.oxysun.cn/linux/ubuntu-user-add-delete.html</id>
    <published>2018-07-12T03:15:00.000Z</published>
    <updated>2018-07-18T11:09:55.846Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu：新增和删除用户，修改用户组信息。<br><a id="more"></a><br>参考：<a href="https://www.digitalocean.com/community/tutorials/how-to-add-and-delete-users-on-ubuntu-16-04#how-to-delete-a-user。" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-add-and-delete-users-on-ubuntu-16-04#how-to-delete-a-user。</a></p><p><code>Linux</code>上root用户是权力最大的用户，但是也非常危险，处于安全考虑，增加个人用户是必要的方法，下文讲了讲在<code>Ubuntu</code>上如何新增和删除用户。</p><h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><p><strong>实例：</strong> <code>root</code>用户新增用户<code>chenming</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# adduser chenming</span><br><span class="line">Adding user `chenming&apos; ...</span><br><span class="line">Adding new group `chenming&apos; (1000) ...</span><br><span class="line">Adding new user `chenming&apos; (1000) with group `chenming&apos; ...</span><br><span class="line">Creating home directory `/home/chenming&apos; ...</span><br><span class="line">Copying files from `/etc/skel&apos; ...</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for chenming</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">Full Name []: </span><br><span class="line">Room Number []: </span><br><span class="line">Work Phone []: </span><br><span class="line">Home Phone []: </span><br><span class="line">Other []: </span><br><span class="line">Is the information correct? [Y/n] y</span><br></pre></td></tr></table></figure></p><p>首先创建了一个新的用户组<code>chenming</code>。<br>在这个组内新建了用户<code>chenming</code>。<br>要求你输入密码。<br>要求输入一些其他信息，可以按回车略过。<br>最后按下<code>y</code>对以上信息进行确认。</p><p><strong>实例：</strong>非<code>root</code>用户新增用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo adduser chenming</span><br></pre></td></tr></table></figure><h1 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h1><p><strong>实例：</strong>把<code>chenming</code>加到<code>sudo</code>组里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# groups chenming</span><br><span class="line">chenming : chenming</span><br></pre></td></tr></table></figure><p>可以看到，<code>chenming</code>只在<code>chenming</code>的组里面（前面是用户名，冒号后面是组名）。在这个组里面，可能很多命令你都不能执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# usermod -aG sudo chenming</span><br></pre></td></tr></table></figure><p>再来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# groups chenming</span><br><span class="line">chenming : chenming sudo</span><br></pre></td></tr></table></figure><p>look，进入了sudo组了，这下你可以臭屁了。</p><p>还有一种方法可以加入<code>sodu</code>组。<br>如果是<code>root</code>用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# visudo</span><br></pre></td></tr></table></figure></p><p>这个时候会打开一个文本编辑器，去编辑<code>/etc/sudoer</code>这个文件，可能是<code>vim</code>，也可能是<code>nano</code>。<br>找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>在下面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chenming ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>保存（vim下是<code>:x</code>，<code>nano</code>下是<code>ctrl+x</code>），退出，这样<code>chenming</code>这个用户就加入了<code>sudo</code>组。</p><h1 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h1><p>仅仅删除用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# deluser chenming</span><br><span class="line">Removing user `chenming&apos; ...</span><br><span class="line">Warning: group `chenming&apos; has no more members.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure></p><p>将用户的目录也删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# deluser --remove-home chenming</span><br></pre></td></tr></table></figure></p><p>但这个时候，这个已经被删除的用户还是在<code>sudo</code>组里面。<br>参照上面的过程，使用visudo命令，删掉增加的那一行即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu：新增和删除用户，修改用户组信息。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Ubuntu" scheme="https://www.oxysun.cn/categories/Linux/Ubuntu/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JS：NPM依赖包版本号脱字符&quot;^&quot;</title>
    <link href="https://www.oxysun.cn/js/js-npm-symbol-caret.html"/>
    <id>https://www.oxysun.cn/js/js-npm-symbol-caret.html</id>
    <published>2018-07-11T15:07:00.000Z</published>
    <updated>2018-07-18T11:09:55.841Z</updated>
    
    <content type="html"><![CDATA[<p>JS：NPM依赖包版本号脱字符”^”。<br><a id="more"></a></p><p>参考官网：<a href="https://github.com/npm/node-semver#functions。" target="_blank" rel="noopener">https://github.com/npm/node-semver#functions。</a></p><blockquote><p>Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4<br>Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple. In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for versions 0.X &gt;=0.1.0, and no updates for versions 0.0.X.<br><br>Many authors treat a 0.x version as if the x were the major “breaking-change” indicator.</p></blockquote><p>大概意思是：允许的改变不能发生在最左侧非零的数字上，NPM采用的是3元组的版本控制，[major，minor，patch]。换句话说，对于版本<code>1.0.0</code>，允许变更的是<code>minor</code>和<code>patch</code>，对于<code>0.X</code>的，<code>patch</code>可以变更，而对于<code>0.0.X</code>，啥都不能变了。<br>这里说的改变是说，npm在自动安装时去获取的这个包的版本，如果使用了脱字符或者波浪线等符号，它可以去获取的版本就是在一个范围之内，而不是固定的，这两个符号就是去约束这个范围的。这里还涉及一个版本锁定的概念，涉及yarn的一些理念，回头再讨论。</p><blockquote><p>Caret ranges are ideal when an author may make breaking changes between 0.2.4 and 0.3.0 releases, which is a common practice. However, it presumes that there will not be breaking changes between 0.2.4 and 0.2.5. It allows for changes that are presumed to be additive (but non-breaking), according to commonly observed practices.</p></blockquote><p>“^”这个符号叫做脱字符（caret），这好像是原来打字机的一个功能，现在叫这个名字感觉是有些陌生的。<br>以下是一些例子，感觉也没有太多可讲的。</p><blockquote><ul><li>^1.2.3 := &gt;=1.2.3 &lt;2.0.0（解释：如果是^1.2.3，那么获取包的范围就是版本&gt;=1.2.3，并且&lt;2.0.0。）</li><li>^0.2.3 := &gt;=0.2.3 &lt;0.3.0</li><li>^0.0.3 := &gt;=0.0.3 &lt;0.0.4</li><li>^1.2.3-beta.2 := &gt;=1.2.3-beta.2 &lt;2.0.0 Note that prereleases in the 1.2.3 version will be allowed, if they are greater than or equal to beta.2. So, 1.2.3-beta.4 would be allowed, but 1.2.4-beta.2 would not, because it is a prerelease of a different [major, minor, patch] tuple.</li><li>^0.0.3-beta := &gt;=0.0.3-beta &lt;0.0.4 Note that prereleases in the 0.0.3 version only will be allowed, if they are greater than or equal to beta. So, 0.0.3-pr.2 would be allowed.</li></ul></blockquote><blockquote><p>When parsing caret ranges, a missing patch value desugars to the number 0, but will allow flexibility within that value, even if the major and minor versions are both 0.</p></blockquote><blockquote><ul><li>^1.2.x := &gt;=1.2.0 &lt;2.0.0</li><li>^0.0.x := &gt;=0.0.0 &lt;0.1.0</li><li>^0.0 := &gt;=0.0.0 &lt;0.1.0</li></ul></blockquote><blockquote><p>A missing minor and patch values will desugar to zero, but also allow flexibility within those values, even if the major version is zero.</p></blockquote><blockquote><ul><li>^1.x := &gt;=1.0.0 &lt;2.0.0</li><li>^0.x := &gt;=0.0.0 &lt;1.0.0</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS：NPM依赖包版本号脱字符”^”。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.oxysun.cn/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS：NPM依赖包版本号波浪字符&quot;~&quot;</title>
    <link href="https://www.oxysun.cn/js/js-npm-symbol-tilde.html"/>
    <id>https://www.oxysun.cn/js/js-npm-symbol-tilde.html</id>
    <published>2018-07-11T15:07:00.000Z</published>
    <updated>2018-07-18T11:09:55.842Z</updated>
    
    <content type="html"><![CDATA[<p>JS：NPM依赖包版本号波浪字符”~”。<br><a id="more"></a></p><p>参考官网：<a href="https://github.com/npm/node-semver#functions。" target="_blank" rel="noopener">https://github.com/npm/node-semver#functions。</a></p><blockquote><p>Tilde Ranges ~1.2.3 ~1.2 ~1<br>Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.</p></blockquote><p>如果minor被指定，则允许patch被改变；如果没有，允许minor被改变。（个别知识需要参考前面的帖子）</p><blockquote><p>~1.2.3 := &gt;=1.2.3 &lt;1.(2+1).0 := &gt;=1.2.3 &lt;1.3.0<br>~1.2 := &gt;=1.2.0 &lt;1.(2+1).0 := &gt;=1.2.0 &lt;1.3.0 (Same as 1.2.x)<br>~1 := &gt;=1.0.0 &lt;(1+1).0.0 := &gt;=1.0.0 &lt;2.0.0 (Same as 1.x)<br>~0.2.3 := &gt;=0.2.3 &lt;0.(2+1).0 := &gt;=0.2.3 &lt;0.3.0<br>~0.2 := &gt;=0.2.0 &lt;0.(2+1).0 := &gt;=0.2.0 &lt;0.3.0 (Same as 0.2.x)<br>~0 := &gt;=0.0.0 &lt;(0+1).0.0 := &gt;=0.0.0 &lt;1.0.0 (Same as 0.x)<br>~1.2.3-beta.2 := &gt;=1.2.3-beta.2 &lt;1.3.0 Note that prereleases in the 1.2.3 version will be allowed, if they are greater than or equal to beta.2. So, 1.2.3-beta.4 would be allowed, but 1.2.4-beta.2 would not, because it is a prerelease of a different [major, minor, patch] tuple.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS：NPM依赖包版本号波浪字符”~”。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.oxysun.cn/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：tar</title>
    <link href="https://www.oxysun.cn/linux/shell-command-tar.html"/>
    <id>https://www.oxysun.cn/linux/shell-command-tar.html</id>
    <published>2018-07-10T15:06:00.000Z</published>
    <updated>2018-07-18T11:09:55.844Z</updated>
    
    <content type="html"><![CDATA[<p>tar命令用来归档多个文件或目录到单个归档文件中，并且归档文件可以进一步使用gzip或者bzip2等技术进行压缩。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>tar [OPTION...] [FILE]...</code></p><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>Tar（Tape ARchive，磁带归档的缩写，最初设计用于将文件打包到磁带上，现在大都使用它来实现备份某个分区或者某些重要的目录）是类Unix系统中使用最广泛的命令，用于归档多个文件或目录到单个归档文件中，并且归档文件可以进一步使用gzip或者bzip2等技术进行压缩，还能保留其文件权限。换言之，tar命令也可以用于备份：先是归档多个文件和目录到一个单独的tar文件或归档文件，然后在需要之时将tar文件中的文件和目录释放出来。</p><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">-A或–catenate</td><td style="text-align:left">新增文件到以存在的备份文件</td></tr><tr><td style="text-align:left">-B</td><td style="text-align:left">设置区块大小</td></tr><tr><td style="text-align:left">-c或–create</td><td style="text-align:left">建立新的备份文件</td></tr><tr><td style="text-align:left">-C&lt;目录&gt;</td><td style="text-align:left">这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项</td></tr><tr><td style="text-align:left">-d</td><td style="text-align:left">记录文件的差别</td></tr><tr><td style="text-align:left">-x或–extract或–get</td><td style="text-align:left">从备份文件中还原文件</td></tr><tr><td style="text-align:left">-t或–list</td><td style="text-align:left">列出备份文件的内容</td></tr><tr><td style="text-align:left">-z或–gzip或–ungzip</td><td style="text-align:left">通过gzip指令处理备份文件</td></tr><tr><td style="text-align:left">-Z或–compress或–uncompress</td><td style="text-align:left">通过compress指令处理备份文件</td></tr><tr><td style="text-align:left">-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;</td><td style="text-align:left">指定备份文件</td></tr><tr><td style="text-align:left">-v或–verbose</td><td style="text-align:left">显示指令执行过程</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">添加文件到已经压缩的文件</td></tr><tr><td style="text-align:left">-u</td><td style="text-align:left">添加改变了和现有的文件到已经存在的压缩文件</td></tr><tr><td style="text-align:left">-j</td><td style="text-align:left">支持bzip2解压文件</td></tr><tr><td style="text-align:left">-v</td><td style="text-align:left">显示操作过程</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">文件系统边界设置</td></tr><tr><td style="text-align:left">-k</td><td style="text-align:left">保留原有文件不覆盖</td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">保留文件不被覆盖</td></tr><tr><td style="text-align:left">-w</td><td style="text-align:left">确认压缩文件的正确性</td></tr><tr><td style="text-align:left">-p或–same-permissions</td><td style="text-align:left">用原来的文件权限还原文件</td></tr><tr><td style="text-align:left">-P或–absolute-names</td><td style="text-align:left">文件名使用绝对名称，不移除文件名称前的“/”号</td></tr><tr><td style="text-align:left">-N</td><td style="text-align:left">&lt;日期格式&gt;或–newer=&lt;日期时间&gt;只将较指定日期更新的文件保存到备份文件里</td></tr><tr><td style="text-align:left">–exclude=&lt;范本样式&gt;</td><td style="text-align:left">排除符合范本样式的文件</td></tr></tbody></table><h2 id="什么是“文件压缩”？"><a href="#什么是“文件压缩”？" class="headerlink" title="什么是“文件压缩”？"></a>什么是“文件压缩”？</h2><p>我们知道，在计算机系统中文件的内容是信息，信息实际上就是一个由值0和值1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。一般来说，一个字节的8位是没有被全部利用起来的，这些没有被利用的位占据了一个文件的大部分空间，而“文件压缩”就是利用复杂的计算方式，将这些没有利用的空间腾出来，以让文件占用的空间变小。</p><p>简单来说，「压缩」就是把文件中没有完全填满的空间填满。压缩过的文件不能直接被操作系统所使用，因此，「解压缩」就是指把文件「还原」为未压缩之前的模样。压缩前与压缩后的文件所占用的磁盘空间大小之比就是「压缩比」。</p><!-- more --><h2 id="常见的压缩格式"><a href="#常见的压缩格式" class="headerlink" title="常见的压缩格式"></a>常见的压缩格式</h2><p>Linux 中常见的压缩格式有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*.Z：compress 程序压缩的文件。</span><br><span class="line">*.gz：gzip 程序压缩的文件。</span><br><span class="line">*.bz2：bzip2 程序压缩的文件。</span><br><span class="line">*.tar：tar 程序打包的数据，没有被压缩过。</span><br><span class="line">*.tar.gz（简写为 .tgz）：tar 程序打包的数据，经过 gzip 的压缩。</span><br><span class="line">*.tar.bz2（简写为 .tbz2）：tar 程序打包的数据，经过 bzip2 的压缩。</span><br></pre></td></tr></table></figure><p>上面的压缩格式中，主要是gzip和bzip2两个压缩命令，它们是GNU计划的中的一部分，在此之前是compress命令，但它已经不再流行了。bzip2比gzip的压缩比很好，不过bzip2通常只能针对一个文件来压缩和解压缩。如果是这样的话，压缩整个开发环境目录就太繁琐了。</p><p>因此tar命令就出现了，tar不是一个 “压缩命令”，而是一个“打包命令”。也就是说，tar可以把很多文件「打包」成一个文件，甚至连目录也可以进行打包。一开始tar命令的确是不支持压缩的功能，后来GNU计划为了提供给使用者更方便并且更加强大的压缩与打包功能，就把整个tar与压缩的功能结合在一起了。</p><p>仅仅打包起来的tar文件俗称tarfile文件，经过压缩的tar文件叫做tarball文件。</p><h2 id="全能的-tar-命令"><a href="#全能的-tar-命令" class="headerlink" title="全能的 tar 命令"></a>全能的 tar 命令</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>tar可以将多个目录或文件打成一个大文件，同时支持gzip/bzip2</p><p>归档：tar {-c} [option…] -f destination source<br>追加归档：tar {-r | -u} -f source [option…] destination<br>解压：tar {-t | -x} -f source [option…] -C destination</p><p>最简单的使用 tar 只要记住下面的方式：</p><ul><li>压缩：tar -jcv -f filename.tar.bz2 被压缩的文件或目录名称</li><li>查看文件：tar -jtv -f filename.tar.bz2 </li><li>解压缩：tar -jxv -f filename.tar.gz -C 解压到哪里</li></ul><p>filename.tar.bz2 既然tar不是一个压缩命令，是个打包命令，那么是如何做到打包并压缩的呢？我们先来看一下tar命令的常用参数：</p><h3 id="模式参数"><a href="#模式参数" class="headerlink" title="模式参数"></a>模式参数</h3><ul><li>-c（–create）：创建新的归档文件。</li><li>-r（–append）：与-c一样创建新的归档文件，但这是以追加的模式，只能往未压缩过的归档文件中追加，要求指定-f参数。</li><li>-t：查看归档文件的内容含有哪些文件，可以看到包括文件名在内的详细信息。</li><li>-u：与-r一样，但是只往归档文件添加更新的文件。</li><li>-x：解压缩归档文件。如果一个归档文件里有相同文件名的多个文件，那么会先将每个文件解压，最新的文件将覆盖旧的文件。</li></ul><p>tar分为三种模式，-c，-r，-u三个一类，为归档/压缩模式，在该模式下，tar会递归遍历指定目录下的所有目录和文件，并创建归档文件。-x表示为去归档/解压模式，-t表示为打印列表模式。</p><h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3><ul><li>-j：使用bzip2的支持进行压缩和解压缩，文件名最好为*.tar.bz2。</li><li>-z：使用gzip的支持进行压缩和解压缩，文件名最好为*.tar.gz。</li><li>-v：在压缩/解压缩的过程中，将正在处理的文件名显示出来。</li><li>-f：后面接被处理的文件名，最好把-f单独出来写一个参数。</li><li>-C：指定解压的目录。</li><li>-p：保留文件的原始信息，权限等等</li><li>-P：解压时保留绝对路径。</li><li>–exclude=FILE：在打包压缩的时候，不要将FILE打包。</li></ul><h3 id="打包并创建归档文件"><a href="#打包并创建归档文件" class="headerlink" title="打包并创建归档文件"></a><strong>打包并创建归档文件</strong></h3><p>示例：打包一个目录。<br>描述：将/home/test这个目录打包，生成文件名为command-18-06-02.tar的归档文件，保存在当前目录下。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -cv -f command-18-06-02.tar /home/test</span><br><span class="line">/home/test/.bash_logout</span><br><span class="line">/home/test/.bashrc</span><br><span class="line">/home/test/apache-tomcat-9.0.7.tar.gz</span><br><span class="line">/home/test/.bash_profile</span><br><span class="line">/home/test/nginx-1.10.1.tar.gz</span><br></pre></td></tr></table></figure></p><p>-c（–create的简写）参数，这表示为指定的文件或者目录创建新的归档文件。使用-f指定读取或者写入的归档文件，可以用-表示标准输入或者标准输出，-f可以与其他参数连起来写，必须保证f参数后面跟的是文件名。但不推荐这样写，因为参数调换顺序是允许的，如果写成-cfv就会导致压缩后的文件名变成了v。</p><p>使用-v表示生成详细的输出，在压缩或者解压的模式中，会列出正在向归档文件读或者写的文件名字。</p><h3 id="创建tar-gz归档文件"><a href="#创建tar-gz归档文件" class="headerlink" title="创建tar.gz归档文件"></a><strong>创建tar.gz归档文件</strong></h3><p>示例：打包并且使用gzip压缩。<br>描述：将/home/test/images目录下的所有文件以及目录中的文件打包，并用gzip进行压缩，生成名为MyImages-18-06-02.tar.gz的归档文件，放在当前目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -zcv -f MyImages-18-06-02.tar.gz /home/test/images</span><br><span class="line">OR</span><br><span class="line"><span class="meta">#</span> tar -zcv -f MyImages-18-06-02.tar.tgz /home/test/images</span><br><span class="line">/home/test/images/alejandro-gonzalez-17189.jpg</span><br><span class="line">/home/test/images/brooke-lark-275181.jpg</span><br><span class="line">/home/test/images/brenda-godinez-228181.jpg</span><br><span class="line">/home/test/images/artur-rutkowski-97622.jpg</span><br><span class="line">/home/test/images/ben-white-138743.jpg</span><br></pre></td></tr></table></figure><p>-z表示要使用gzip支持来压缩或者解压文件，注意gzip的压缩的文件格式最好写成tar.gz。（注：tar.gz 和 tgz 是同一个意思）</p><h3 id="打包压缩排除某些文件"><a href="#打包压缩排除某些文件" class="headerlink" title="打包压缩排除某些文件"></a><strong>打包压缩排除某些文件</strong></h3><p>示例：打包压缩并排除某些文件。<br>描述：将/home/test/images目录下，排除brooke-lark-275181.jpg和ben-white-138743.jpg之外的所有文件打包，并用gzip进行压缩，生成名为MyImages-18-06-02.tar.gz的归档文件，放在当前目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -czv -f MyImages-18-06-02.tar.gz --exclude=./brooke-lark-275181.jpg --exclude=./ben-white-138743.jpg /home/test/images</span><br><span class="line">/home/test/images/alejandro-gonzalez-17189.jpg</span><br><span class="line">/home/test/images/brenda-godinez-228181.jpg</span><br><span class="line">/home/test/images/artur-rutkowski-97622.jpg</span><br></pre></td></tr></table></figure><h3 id="解压归档文件（默认）"><a href="#解压归档文件（默认）" class="headerlink" title="解压归档文件（默认）"></a><strong>解压归档文件（默认）</strong></h3><p>示例：解压，默认解压。<br>描述：将名为MyImages-18-06-02.tar的归档文件解压至当前目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -xvf MyImages-18-06-02.tar</span><br><span class="line">home/test/images/alejandro-gonzalez-17189.jpg</span><br><span class="line">home/test/images/brenda-godinez-228181.jpg</span><br><span class="line">home/test/images/artur-rutkowski-97622.jpg</span><br></pre></td></tr></table></figure><p>其中，-x参数表示去解压一个归档文件，如果归档文件中有两个相同名字的文件，那么每一个文件都会被解压出来，然后最新的会覆盖旧的文件。注意这里没有指定-j参数，因为tar看到指定了-x参数，就知道这是解压操作，会自动判断该解压包的压缩类型。</p><h3 id="解压归档文件并指定目录"><a href="#解压归档文件并指定目录" class="headerlink" title="解压归档文件并指定目录"></a><strong>解压归档文件并指定目录</strong></h3><p>示例：解压到一个指定目录。<br>描述：将名为MyImages-18-06-02.tar.gz的归档文件解压至一个指定的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -xv -f MyImages-18-06-02.tar -C /home/test/public_images</span><br><span class="line">home/test/public_images/alejandro-gonzalez-17189.jpg</span><br><span class="line">home/test/public_images/brenda-godinez-228181.jpg</span><br><span class="line">home/test/public_images/artur-rutkowski-97622.jpg</span><br></pre></td></tr></table></figure><h3 id="查看压缩包文件信息"><a href="#查看压缩包文件信息" class="headerlink" title="查看压缩包文件信息"></a><strong>查看压缩包文件信息</strong></h3><p>示例：查看压缩包文件信息。<br>描述：列出MyImages-18-06-02.tar.bz2中的文件信息，-v参数，会生成与ls(1)命令相近的输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -tv -f MyImages-18-06-02.tar.gz</span><br><span class="line">OR</span><br><span class="line"><span class="meta">#</span> tar -tv -f MyImages-18-06-02.tar.bz2</span><br><span class="line">-rw-r--r-- root/root   2176861 2018-06-02 21:26 home/test/images/alejandro-gonzalez-17189.jpg</span><br><span class="line">-rw-r--r-- root/root   8452524 2018-06-02 21:26 home/test/images/brenda-godinez-228181.jpg</span><br><span class="line">-rw-r--r-- root/root   1131986 2018-06-02 21:26 home/test/images/artur-rutkowski-97622.jpg</span><br></pre></td></tr></table></figure><h3 id="解压单个文件"><a href="#解压单个文件" class="headerlink" title="解压单个文件"></a><strong>解压单个文件</strong></h3><p>示例：解压单个文件。<br>描述：将home/test/.bashrc这一个文件从归档文件中提取出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -xv -f command-18-06-02.tar home/test/.bashrc</span><br><span class="line">home/test/.bashrc</span><br></pre></td></tr></table></figure><h3 id="解压多个指定的文件"><a href="#解压多个指定的文件" class="headerlink" title="解压多个指定的文件"></a><strong>解压多个指定的文件</strong></h3><p>示例：解压多个指定的文件。<br>描述：将file1、file2等多个文件从归档文件中提取出来，可以用空格隔开多个文件，也可以用通配符的形式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -zxv -f MyImages-18-06-02.tar.gz "file 1" "file 2"</span><br><span class="line">OR</span><br><span class="line"><span class="meta">#</span> tar -zxv -f MyImages-18-06-02.tar.gz --wildcards '*b*.jpg'</span><br><span class="line">home/test/images/brooke-lark-275181.jpg</span><br><span class="line">home/test/images/brenda-godinez-228181.jpg</span><br><span class="line">home/test/images/ben-white-138743.jpg</span><br><span class="line">home/test/images/aleks-dahlberg-274646.jpg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tar命令用来归档多个文件或目录到单个归档文件中，并且归档文件可以进一步使用gzip或者bzip2等技术进行压缩。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Shell" scheme="https://www.oxysun.cn/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CSS：文档流</title>
    <link href="https://www.oxysun.cn/css/css-normal-flow.html"/>
    <id>https://www.oxysun.cn/css/css-normal-flow.html</id>
    <published>2018-07-09T15:24:00.000Z</published>
    <updated>2018-07-18T11:09:55.837Z</updated>
    
    <content type="html"><![CDATA[<p>CSS的文档流介绍。<br><a id="more"></a></p><p>官网：<a href="https://www.w3.org/TR/2016/WD-CSS22-20160412/visuren.html#normal-flow。" target="_blank" rel="noopener">https://www.w3.org/TR/2016/WD-CSS22-20160412/visuren.html#normal-flow。</a></p><h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><p>文档流其实应该叫正常流，英文是<code>Normal flow</code>，我的理解呢，就是接收到的文档的内容，因为这些内容一直从服务端传输过来，边传输边需要处理，就像水流一样，所以称为流。</p><p>在文档流中的盒子是需要归属于一个上下文的，块级盒子参与到块格式化上下文中，内联级盒子参与到内联格式化上下文中，还有表格格式化上下文。</p><h2 id="块格式化上下文（Block-formatting-contexts）"><a href="#块格式化上下文（Block-formatting-contexts）" class="headerlink" title="块格式化上下文（Block formatting contexts）"></a>块格式化上下文（Block formatting contexts）</h2><p>块格式化上下文，简称<code>BFC</code>，是按照从上到下，一个一个垂直排列的，块之间的间距是靠<code>margin</code>来控制的。</p><blockquote><p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p></blockquote><p>翻译：在块格式化上下文中，框从一个包含块的顶部开始一个接一个地垂直排列。 两个兄弟盒子之间的垂直距离由“margin”属性决定。 块格式化上下文中相邻块级盒子之间的垂直<code>margin</code>会折叠。</p><p>##内联格式化上下文（Inline formatting contexts）<br>内联格式化上下文，简称<code>IFC</code>，主要是水平排列的，水平对齐是由一些参数来控制的。</p><blockquote><p>An inline formatting context is established by a block container box that contains no block-level boxes. In an inline formatting context, boxes are laid out horizontally, one after the other, beginning at the top of a containing block. Horizontal margins, borders, and padding are respected between these boxes. The boxes may be aligned vertically in different ways: their bottoms or tops may be aligned, or the baselines of text within them may be aligned. The rectangular area that contains the boxes that form a line is called a line box.</p></blockquote><p>翻译：内联格式化上下文由不包含块级框的块容器盒子建立。 在内联格式化上下文中，盒子从一个接一个地开始，从一个包含块的顶部开始。 这些框之间会考虑水平边距，边框和填充。 盒子可以以不同的方式垂直对齐：它们的底部或顶部可以对齐，或者它们内的文本的基线可以对齐。 包含形成一条线的框的矩形区域称为线盒子<code>line box</code>。</p><p>这里面有一些父容器和子布局的一些关系，需要梳理。</p><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>相对定位是根据这个盒子原本在文档流中的位置或者floated进行一些偏移。</p><p>未完，待续……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS的文档流介绍。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://www.oxysun.cn/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>Java：Tomcat的部署实例之资源目录</title>
    <link href="https://www.oxysun.cn/java/java-deploy-resource-folder.html"/>
    <id>https://www.oxysun.cn/java/java-deploy-resource-folder.html</id>
    <published>2018-07-07T11:55:00.000Z</published>
    <updated>2018-07-18T11:09:55.840Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat上部署应用后，原本目录是否会被移除。<br><a id="more"></a></p><p><strong>实例：</strong><br>一个项目的资源放在了WebContent下面，这样每次打包，都会将这些文件打包进去，这样在打包时，导致打出来的war包有好几百兆，这样上传Git也非常不方便。</p><p>方案1：<br>分析：如果删除掉本地WebContent下的资源文件，再部署到服务器上，war包其实是一个压缩包，加压后覆盖原本目录下的相同内容，因为新上传的war包没有相同的资源文件，这样就不会覆盖原本的资源文件。<br>结果：加压后的项目目录也不存在资源文件了，看来这个部署过程，是会删掉原本的项目目录的。</p><p>方案2：<br>分析：因为webapps是web服务根目录，那么把资源文件从项目目录移到webapps下面，这样应该也可以被访问到。<br>结果：成功，可以被访问到。</p><p>为了验证这个，上网查了很多帖子，众说纷纭，最后还是在<a href="https://tomcat.apache.org/tomcat-8.0-doc/deployer-howto.html" target="_blank" rel="noopener">官网</a>找到这么一段话：</p><blockquote><p>The following deployment sequence will occur on Tomcat startup in that case:</p><ol><li>Any Context Descriptors will be deployed first.</li><li>Exploded web applications not referenced by any Context Descriptor will then be deployed. If they have an associated .WAR file in the appBase and it is newer than the exploded web application, the exploded directory will be removed and the webapp will be redeployed from the .WAR</li><li>.WAR files will be deployed</li></ol></blockquote><p>注意这里<code>the exploded directory will be removed and the webapp will be redeployed from the .WAR</code>，原本的解压目录会被移除，应用会被重新从<code>war</code>文件中部署。</p><p>寻根究底，而不人云亦云，这样才是端正的学习的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat上部署应用后，原本目录是否会被移除。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.oxysun.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Git：工作流程Git Flow</title>
    <link href="https://www.oxysun.cn/git/git-git-flow.html"/>
    <id>https://www.oxysun.cn/git/git-git-flow.html</id>
    <published>2018-07-06T13:22:00.000Z</published>
    <updated>2018-07-18T11:09:55.839Z</updated>
    
    <content type="html"><![CDATA[<p>Git的工作流程Git Flow介绍。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考：<a href="https://nvie.com/posts/a-successful-git-branching-model/，" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/，</a> 这篇帖子是10年发表的，而我大概是08、09年接触的Git，当时因为刚刚花了好大气力研究明白SVN的流程，所以对Git很排斥，这也是我工作中一直以来的一个问题，因为在一项老技术上花了太多气力，而导致对新技术的出现本能地产生很大的排斥。如果当时仔细去研究一下Git，应该会发现Git不是来革我们这些SVN拥趸的命，而是提供完善和丰富了SVN的功能。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从CVS到SVN，再从SVN到Git。<br>从中心化到去中心化的中心化（Decentralized but centralized），这句话挺有挺有深意。</p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h2><p>项目存在两个长期分支：</p><ul><li>主分支master。</li><li>开发分支develop或者dev。</li></ul><blockquote><p>We consider origin/master to be the main branch where the source code of HEAD always reflects a production-ready state.<br>We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. This is where any automatic nightly builds are built from.</p></blockquote><p>这里的HEAD是Git的一个指针，指向当前的分支上。<br>上面的话的意思大概是master分支总是指向“等待上生产”状态的代码。develop分支往往是最近交付的开发修改。这个过程是和原本的SVN工作流是很接近的，一个开发分支，一个线上分支。开发完，测试后，发布到线上。SVN流程推荐在测试时分叉一个branch出来进行测试，这个时候不影响trunk上业务的继续开发，这个工作流没有这么明说，但是因为Git的灵活性，建立一个临时的测试分支也是没有问题的。Git好就好在非常灵活，不过也正是因为如此，导致了一些问题，之前有一个小朋友，把所有的功能分支都保存了下来，还说这样会更加方便，我很难理解，这样怎么会方便呢？每个人分支都需要不断同步。灵活也应该是相对的，在一个相对固定的流程下，适当的灵活，是可以提高效率的。</p><p><img src="https://nvie.com/img/main-branches@2x.png" width="50%" height="50%"></p><h2 id="支持分支"><a href="#支持分支" class="headerlink" title="支持分支"></a>支持分支</h2><p>原文叫做supporting branches。这里面的每一个分支都有指定的目的和约束的规则，如何产生和如何合并。</p><ul><li>Feature branches</li><li>Release branches</li><li>Hotfix branches</li></ul><h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>可以产生于:<br>develop<br>必须合并到:<br>develop<br>分支命名约定:<br>除了master, develop, release-<em>, or hotfix-</em> 都可以，前面几个作为保留。</p><p>功能分支用于开发未来的一项功能，目标的发布此时可能还不确定。这个分支最终会被合并回develop（采用了）或者被抛弃掉（不采用）。<br>功能分支更多存在于用户仓库，而不是origin仓库。<br><img src="https://nvie.com/img/merge-without-ff@2x.png" width="50%" height="50%"></p><p><strong>创建：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b myfeature develop</span><br><span class="line">Switched to a new branch &quot;myfeature&quot;</span><br></pre></td></tr></table></figure></p><p><strong>合并回develop：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git branch -d myfeature</span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure><p>对于–no-ff，参考：<a href="https://git-scm.com/docs/git-merge，有待更进一步的解释。" target="_blank" rel="noopener">https://git-scm.com/docs/git-merge，有待更进一步的解释。</a></p><h3 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h3><p>可以产生于:<br>develop<br>必须合并到:<br>develop和master分支<br>分支命名约定:<br>release-*</p><p>我理解的，这里主要用于准备一个发布版的功能已经开发完成，等待一些信息最后的确认，为了不影响下一个开发版的正常进行，打出一个发布分支。</p><p><strong>创建一个发布分支</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop</span><br><span class="line">Switched to a new branch &quot;release-1.2&quot;</span><br><span class="line">$ ./bump-version.sh 1.2</span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2&quot;</span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure></p><p><strong>结束一个发布分支</strong><br>合并回master分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git tag -a 1.2</span><br></pre></td></tr></table></figure></p><p>合并回develop分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure></p><p>删除原分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d release-1.2</span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure></p><h3 id="热修复分支"><a href="#热修复分支" class="headerlink" title="热修复分支"></a>热修复分支</h3><p>可以产生于:<br>master<br>必须合并到:<br>develop和master分支<br>分支命名约定:<br>hotfix-*</p><p>主要用于对线上代码进行热修复用，线上代码出现了问题，开出一个分支进行修复，等修复完成，合并回master和develop分支。</p><p><strong>创建</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line">Switched to a new branch &quot;hotfix-1.2.1&quot;</span><br><span class="line">$ ./bump-version.sh 1.2.1</span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;</span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p><strong>提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;Fixed severe production problem&quot;</span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed severe production problem</span><br><span class="line">5 files changed, 32 insertions(+), 17 deletions(-)</span><br></pre></td></tr></table></figure><p><strong>结束</strong><br>合并回master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git tag -a 1.2.1</span><br></pre></td></tr></table></figure></p><p>合并回develop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure></p><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix-1.2.1</span><br><span class="line">Deleted branch hotfix-1.2.1 (was abbe5d6).</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git的工作流程Git Flow介绍。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：netstat</title>
    <link href="https://www.oxysun.cn/linux/shell-command-netstat.html"/>
    <id>https://www.oxysun.cn/linux/shell-command-netstat.html</id>
    <published>2018-07-05T07:14:47.000Z</published>
    <updated>2018-07-18T11:09:55.843Z</updated>
    
    <content type="html"><![CDATA[<p>netstat命令用来查看系统中所有的网络套接字连接情况。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>netstat [选项]</p><p>参考：<a href="https://linux.die.net/man/8/netstat。" target="_blank" rel="noopener">https://linux.die.net/man/8/netstat。</a></p><p><code>netstat</code>命令用来查看系统中所有的网络套接字连接情况。</p><!-- more --><h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>netstat</code> [选项]</p><p>参考：<a href="https://linux.die.net/man/8/netstat。" target="_blank" rel="noopener">https://linux.die.net/man/8/netstat。</a></p><p><code>netstat</code>命令用来查看系统中所有的网络套接字连接情况。</p><!-- more --><h2 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>netstat</code> [选项]</p><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p><code>netstat</code>命令用来查看系统中所有的网络套接字连接情况，包括TCP、UDP和Unix套接字。也可以显示路由表，接口状态，masquerade 连接，多播成员（Multicast Memberships）等等。另外，它还可以列出处于监听状态（等待接入请求）的套接字，比如想确认系统中的web服务是否起来，就可以查看80端口有没有打开。</p><h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul><li>-a或–all：显示所有选项，默认不显示LISTEN相关。</li><li>-t或–tcp：(TCP)仅显示TCP相关选项。</li><li>-u或–udp：(UDP)仅显示UDP相关选项。</li><li>-x或–unix：此参数的效果和指定”-A unix”参数相同。</li><li>-n或–numeric：拒绝显示别名，能显示数字的全部转化成数字。</li><li>-l或–listening：仅列出有在Listen(监听)的服务状态。</li><li>-g或–groups：显示多重广播功能群组组员名单。</li><li>-p或–programs：显示建立相关链接的程序名和PID。</li><li>-r或–route：显示路由信息，路由表。</li><li>-e或–extend：显示扩展信息，例如UID等。</li><li>-s或–statistics：按各个协议进行统计。</li><li>-c或–continuous：每隔一个固定时间，执行该netstat命令。</li><li>-g或–groups：显示多重广播功能群组组员名单。</li></ul><p>提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到。</p><h2 id="输出信息含义"><a href="#输出信息含义" class="headerlink" title="输出信息含义"></a>输出信息含义</h2><p><code>netstat</code>的输出结构可以分为两个部分：<br>一个是Active Internet connections，称为有源TCP连接。其中”Recv-Q”和”Send-Q”指的是接收队列和发送队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 VM01.root:ssh           61.149.11.230:21859     ESTABLISHED</span><br><span class="line">tcp        0      0 localhost:51476         localhost:27017         ESTABLISHED</span><br><span class="line">tcp        0      0 VM01.root:ssh           61.149.11.230:50883     ESTABLISHED</span><br><span class="line">tcp        0      0 VM01.root:58300         47.89.193.173:3666      ESTABLISHED</span><br></pre></td></tr></table></figure></p><p>另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。Proto显示连接使用的协议，RefCnt表示连接到本套接口上的进程号，Types显示套接口的类型，State显示套接口当前的状态，Path表示连接到套接口的其它进程使用的路径名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    15049    /run/user/0/systemd/notify</span><br><span class="line">unix  3      [ ]         DGRAM                    13640    /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    13645    /run/systemd/journal/syslog</span><br><span class="line">unix  8      [ ]         DGRAM                    13660    /run/systemd/journal/socket</span><br><span class="line">unix  25     [ ]         DGRAM                    10467    /run/systemd/journal/dev-log</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>实例：</strong>列出当前所有的连接（-a）<br>命令：<code>netstat -a</code><br>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# netstat -a</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 *:8838                  *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:27017         *:*                     LISTEN     </span><br><span class="line">tcp        0      0 *:8330                  *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:submission    *:*                     LISTEN </span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>列出所有TCP端口（-t）<br>命令：<code>netstat -at</code><br>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# netstat -at</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 *:8838                  *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:27017         *:*                     LISTEN     </span><br><span class="line">tcp        0      0 *:8330                  *:*                     LISTEN     </span><br><span class="line">tcp        0      0 localhost:submission    *:*                     LISTEN</span><br></pre></td></tr></table></figure><p><strong>示例：</strong>列出所有监听TCP的端口，数字显示<br>描述：查看本机监听的（-l）TCP连接（-t）的IP地址的数字显示（-n）。不适用-n的话，就会用端口的约定名称来显示，例如80端口，会显示成http。<br>命令：<code>netstat -tnl</code><br>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# netstat -tnl</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:8838            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:27017         0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:8330            0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure><p><strong>示例：</strong>获取本机的所有的TCP连接的进程名、进程号以及用户ID<br>描述：使用-p选项查看进程信息，-ep选项可以同时查看进程名和用户名。另外，-n和-e选项一起使用，User列的属性就是用户ID，而不是用户名。<br>查看本机所有的（al）TCP连接的（t）进程名（p）和用户名ID（ne）。<br>命令：<code>netstat -altpen</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ayeZ:~# netstat -altpen</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8838            0.0.0.0:*               LISTEN      0          11863750    31212/bnewd     </span><br><span class="line">tcp        0      0 127.0.0.1:27017         0.0.0.0:*               LISTEN      110        2945745     18546/mongod    </span><br><span class="line">tcp        0      0 0.0.0.0:8330            0.0.0.0:*               LISTEN      0          22250263    13550/btnd      </span><br><span class="line">tcp        0      0 127.0.0.1:587           0.0.0.0:*               LISTEN      0          12285119    11792/sendmail: MTA</span><br></pre></td></tr></table></figure><p>这个可能是最屌的命令了，也可能是最常用的命令了。</p><p>还有一些实例，暂时不常用，有待完善。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;netstat命令用来查看系统中所有的网络套接字连接情况。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Shell" scheme="https://www.oxysun.cn/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB：聚合之累加操作符</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-collection-aggregator-accumulate-operator.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-collection-aggregator-accumulate-operator.html</id>
    <published>2018-07-04T15:29:00.000Z</published>
    <updated>2018-07-18T11:09:55.847Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的聚合之累加操作符。<br><a id="more"></a></p><p>官网：<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#considerations。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/group/#considerations。</a></p><h1 id="累加操作符"><a href="#累加操作符" class="headerlink" title="累加操作符"></a>累加操作符</h1><p>感觉这个没有太多可说的，简单翻译一下。</p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$avg</td><td>Returns an average of numerical values. Ignores non-numeric values.（返回平均值）</td></tr><tr><td>$first</td><td>Returns a value from the first document for each group. Order is only defined if the documents are in a defined order.（返回第一个）</td></tr><tr><td>$last</td><td>Returns a value from the last document for each group. Order is only defined if the documents are in a defined order.（返回最后一个）</td></tr><tr><td>$max</td><td>Returns the highest expression value for each group.（返回最大值）</td></tr><tr><td>$min</td><td>Returns the lowest expression value for each group.（返回最小值）</td></tr><tr><td>$push</td><td>Returns an array of expression values for each group.</td></tr><tr><td>$addToSet</td><td>Returns an array of unique expression values for each group. Order of the array elements is undefined.（）</td></tr><tr><td>$stdDevPop</td><td>Returns the population standard deviation of the input values.</td></tr><tr><td>$stdDevSamp</td><td>Returns the sample standard deviation of the input values.</td></tr><tr><td>$sum</td><td>Returns a sum of numerical values. Ignores non-numeric values.（返回总和）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB的聚合之累加操作符。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB：聚合之介绍</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-collection-aggregation-introduction.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-collection-aggregation-introduction.html</id>
    <published>2018-07-04T15:24:00.000Z</published>
    <updated>2018-07-18T11:09:55.847Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的聚合功能介绍。<br><a id="more"></a></p><p>官网：<a href="https://docs.mongodb.com/manual/aggregation/#single-purpose-agg-operations。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/aggregation/#single-purpose-agg-operations。</a></p><p>初衷：MongoDB的使用还是有一定难度的，官网讲解的一环牵扯一环，不容易一下子把握住重点，也不利于快速查询操作，所以整理一下。</p><p>聚合函数是对记录集（data records）进行操作，是把多条记录集合（group）在一起，进行处理，与此相对应的是sql的group by等操作，这是数据处理的一个方面。</p><p>MongoDB提供三种聚合方法：</p><ol><li>聚合管道。</li><li>map-reduce函数。</li><li>单一功能的聚合方法。</li></ol><h1 id="聚合管道"><a href="#聚合管道" class="headerlink" title="聚合管道"></a>聚合管道</h1><p>接触过<code>linux shell</code>的人应该对管道不会陌生，管道就是对输入的数据进行一系列的处理、转换，变成新的数据。</p><p>这里的聚合管道是对记录集进行多阶段的转换，产出新聚合结果，例如：<br><img src="https://docs.mongodb.com/manual/_images/aggregation-pipeline.bakedsvg.svg" alt="这里写图片描述"></p><p>解释一下：</p><ol><li>数据集合：<code>orders</code>，共有4条记录，这里省略了<code>_id</code> 这个域。</li><li>需求：查找所有<code>status=&quot;A&quot;</code> 的记录，根据cust_id进行分组，计算每个组的<code>amount</code>的和。</li><li>分析：<br><code>{$match: {status: &quot;A&quot;}}</code>，第一个阶段，匹配阶段，查找所有<code>status=&quot;A&quot;</code> 的记录。<br><code>{$group: {_id: &quot;$cust_id&quot;, total: {$sum: &quot;$amount&quot;}}}</code>，第二个阶段，分组计算，根据<code>cust_id</code>进行分组，对每个组的<code>amount</code>进行求和。这里涉及<code>$group</code> 的语法，如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $group: &#123; _id: &lt;expression&gt;, &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;, ... &#125; &#125;</span><br></pre></td></tr></table></figure><p>其中，_id是强制的，后面是可选的。<br><code>&lt;accumulator1&gt;</code>是累加操作符，参考<a href="/mongodb/mongodb-collection-aggregator-accumulate-operator.html">这里</a>，例如这里的<code>$sum</code>，注意，这里必须要加<code>$</code>。<br><code>&lt;expression1&gt;</code>是表达式，<a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#aggregation-expressions" target="_blank" rel="noopener">有待补充</a>， <code>&quot;$amount&quot;</code> , 表示是去取上一个结果中的<code>amount</code> 这个域，对其进行累加，并把结果存入新的域<code>total</code>中。</p><p>这个例子看明白了，聚合就基本明白了。</p><h1 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h1><p>map-reduce操作分为两个阶段：map阶段，处理每一条记录，产出一个或多个对象；reduce阶段，合并map阶段的输出。作为可选，map-reduce可以有一个最终阶段来对结果进行最终的操作。map-reduce也可以进行查询、排序和限制输出结果。<br><img src="https://docs.mongodb.com/manual/_images/map-reduce.bakedsvg.svg" alt="这里写图片描述"></p><h1 id="单一功能的聚合方法"><a href="#单一功能的聚合方法" class="headerlink" title="单一功能的聚合方法"></a>单一功能的聚合方法</h1><p>MongoDB也提供<code>db.collection.count()</code>（求和）和<code>db.collection.distinct()</code>（去重）函数。<br><img src="https://docs.mongodb.com/manual/_images/distinct.bakedsvg.svg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB的聚合功能介绍。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB集合的基本操作：查找记录（查）</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-collection-find-1.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-collection-find-1.html</id>
    <published>2018-07-02T13:03:00.000Z</published>
    <updated>2018-07-23T14:18:52.063Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB集合的基本操作：查找记录（查）。<br><a id="more"></a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure><p>在集合或者视图的文档中进行选择，并且返回一个指向被选中的文档的游标。（原文是：Selects documents in a collection or view and returns a cursor to the selected documents.）<br>参数|类型|描述<br>-|-|-<br>query|文档型|可选。使用查询操作符(<a href="https://www.oxysun.cn/mongodb/mongodb-collection-find-projection-operator.html">参考这里</a>)，指定了查询过滤器。 想要返回集合中所有的文档，忽略这个参数，或者传一个空的文档({})。<br>projection|文档型|可选。制定了匹配查询过滤器，要返回的文档的域。想要返回匹配的文档中的所有域，忽略这个参数。 </p><p>projection参数决定了哪些域需要被返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; field1: &lt;value&gt;, field2: &lt;value&gt; ... &#125;</span><br></pre></td></tr></table></figure><p><code>&lt;value&gt;</code>可以是:</p><ul><li>1 或 true 表示要在返回文档中包含这个域。</li><li>0 或 false 表示不包含这个域。</li><li>表达式使用了投影操作符（有待解释）。</li></ul><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>基本的查找参考上面的语法即可，下面也有实例，其实较为难以掌握的是组合查找，例如逻辑关系是<code>AND</code>的，或者是<code>OR</code>的，还有<code>IN</code>的，这几个需要梳理一下。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>实例</strong> 查找<a href="https://blog.csdn.net/chaiyu2002/article/details/80862002" target="_blank" rel="noopener">上文</a>test集合中的所有文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080199&quot;),</span><br><span class="line">    &quot;meta&quot; : &#123;</span><br><span class="line">        &quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">        &quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;a&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;b&quot; : &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080120&quot;),</span><br><span class="line">    &quot;meta&quot; : &#123;</span><br><span class="line">        &quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">        &quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;a&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;b&quot; : &quot;3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>pretty()</code>是用来让展示更加舒适。</p><p><strong>实例</strong> 查找test集合中的<code>b=&quot;3&quot;</code>的记录，这里要注意<code>“3”</code>和<code>3</code>是不一样的，这里是要符合js的语法，字符串和数字表示方式是不同的。做一个好的程序员，一定要严谨，而做到了严谨，可以帮你更快地提高，更快地产出，更好地规避错误，其实加快了你的职场发展节奏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find(&#123;b: &quot;3&quot;&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080120&quot;),</span><br><span class="line">&quot;meta&quot; : &#123;</span><br><span class="line">&quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">&quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">&#125;,</span><br><span class="line">&quot;a&quot; : &quot;1&quot;,</span><br><span class="line">&quot;b&quot; : &quot;3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这次只查出了一条符合条件的记录。</p><p><strong>实例</strong> 查找test集合中的<code>b=&quot;3&quot;</code>的记录a和b两个域，不要其它域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find(&#123;b: &quot;3&quot;&#125;, &#123;a: 1, b: 1&#125;).pretty()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080120&quot;), &quot;a&quot; : &quot;1&quot;, &quot;b&quot; : &quot;3&quot; &#125;</span><br></pre></td></tr></table></figure><p>可以看到，没有涉及的域就没有再获取出来，这样在一些情况下是可以节省网络开销和分析成本的，在《高性能MySQL》也是讲过类似的原理，不要大而全地去把所有内容获取回来，对于资源的使用，应该是有规划的、经济地去使用。</p><p><strong>实例</strong> 查找test集合中的<code>b=&quot;3&quot;</code> 并且<code>a=&quot;4&quot;</code>的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find(&#123;b: &quot;3&quot;, a: &quot;4&quot;&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure></p><p>可以看到，在第一个<code>{}</code> 中逗号分隔开的是<code>AND</code>的查询关系。</p><p><strong>实例</strong> 查找test集合中的<code>b=&quot;3&quot;</code> 或者<code>b=&quot;4&quot;</code>的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find(&#123;b: &#123;$in: [&quot;3&quot;, &quot;4&quot;]&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure></p><p>这个语法的原则是操作符<code>$in</code>在前，作为JSON名值对的名，<code>[&quot;3&quot;, &quot;4&quot;]</code>是它的值，然后整个<code>{$in: [&quot;3&quot;, &quot;4&quot;]}</code>作为b的值，从JSON语法的角度去思考和记忆这个语法，就容易一些了。</p><p><strong>实例</strong> 修改一下上面的例子，查找test集合中的<code>b=&quot;3&quot;</code> 或者<code>a=&quot;4&quot;</code>的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find(&#123;$or: [&#123;b: &quot;3&quot;&#125;, &#123;a: &quot;4&quot;&#125;]&#125;).pretty()</span><br></pre></td></tr></table></figure></p><p>这个语法和<code>IN</code> 的道理是一样的，其实<code>AND</code>也可以这么用，上面那种是隐式的用法，显式的用法是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find(&#123;$and: [&#123;b: &quot;3&quot;&#125;, &#123;a: &quot;4&quot;&#125;]&#125;).pretty()</span><br></pre></td></tr></table></figure></p><p>查询操作符还有一些大于、小于等操作，具体参考查询操作符一节。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/method/db.collection.find/。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB集合的基本操作：查找记录（查）。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB：查询和投影操作符</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-collection-find-projection-operator.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-collection-find-projection-operator.html</id>
    <published>2018-07-02T13:03:00.000Z</published>
    <updated>2018-07-18T11:09:55.851Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB查询和投影操作符。<br><a id="more"></a></p><p>官网：<a href="https://docs.mongodb.com/manual/reference/operator/query/。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query/。</a></p><p>这一章节都是很简单的英语，就做一个很简单的备注，如果连这个英语都看不懂，那就需要提高了，程序员看不懂基本的英语是很难提高的。<br>这一章节还需要完善一些样例，这个有待补充。</p><h1 id="查询选择器"><a href="#查询选择器" class="headerlink" title="查询选择器"></a>查询选择器</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$eq</td><td>Matches values that are equal to a specified value.（判断相等）</td></tr><tr><td>$gt</td><td>Matches values that are greater than a specified value.（判断大于）</td></tr><tr><td>$gte</td><td>Matches values that are greater than or equal to a specified value.（判断大于等于）</td></tr><tr><td>$in</td><td>Matches any of the values specified in an array.（判断在其中）</td></tr><tr><td>$lt</td><td>Matches values that are less than a specified value.（判断小于）</td></tr><tr><td>$lte</td><td>Matches values that are less than or equal to a specified value.（判断小于等于）</td></tr><tr><td>$ne</td><td>Matches all values that are not equal to a specified value.（判断所有值都不等于指定值）</td></tr><tr><td>$nin</td><td>Matches none of the values specified in an array.（判断不在其中）</td></tr></tbody></table><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$and</td><td>Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.（与）</td></tr><tr><td>$not</td><td>Inverts the effect of a query expression and returns documents that do not match the query expression.（非）</td></tr><tr><td>$nor</td><td>Joins query clauses with a logical NOR returns all documents that fail to match both clauses.（异或）</td></tr><tr><td>$or</td><td>Joins query clauses with a logical OR returns all documents that match the conditions of either clause.（或）</td></tr></tbody></table><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$exists</td><td>Matches documents that have the specified field.</td></tr><tr><td>$type</td><td>Selects documents if a field is of the specified type.</td></tr></tbody></table><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$expr</td><td>Allows use of aggregation expressions within the query language.</td></tr><tr><td>$jsonSchema</td><td>Validate documents against the given JSON Schema.</td></tr><tr><td>$mod</td><td>Performs a modulo operation on the value of a field and selects documents with a specified result.</td></tr><tr><td>$regex</td><td>Selects documents where values match a specified regular expression.</td></tr><tr><td>$text</td><td>Performs text search.</td></tr><tr><td>$where</td><td>Matches documents that satisfy a JavaScript expression.</td></tr></tbody></table><h2 id="地理空间"><a href="#地理空间" class="headerlink" title="地理空间"></a>地理空间</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$geoIntersects</td><td>Selects geometries that intersect with a GeoJSON geometry. The 2dsphere index supports <code>$geoIntersects</code>.</td></tr><tr><td>$geoWithin</td><td>Selects geometries within a bounding GeoJSON geometry. The 2dsphere and 2d indexes support <code>$geoWithin</code>.</td></tr><tr><td>$near</td><td>Returns geospatial objects in proximity to a point. Requires a geospatial index. The 2dsphere and 2d indexes support <code>$near</code>.</td></tr><tr><td>$nearSphere</td><td>Returns geospatial objects in proximity to a point on a sphere. Requires a geospatial index. The 2dsphere and 2d indexes support <code>$nearSphere</code>.</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$all</td><td>Matches arrays that contain all elements specified in the query.</td></tr><tr><td>$elemMatch</td><td>Selects documents if element in the array field matches all the specified <code>$elemMatch</code> conditions.</td></tr><tr><td>$size</td><td>Selects documents if the array field is a specified size.</td></tr></tbody></table><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$bitsAllClear</td><td>Matches numeric or binary values in which a set of bit positions all have a value of 0.</td></tr><tr><td>$bitsAllSet</td><td>Matches numeric or binary values in which a set of bit positions all have a value of 1.</td></tr><tr><td>$bitsAnyClear</td><td>Matches numeric or binary values in which any bit from a set of bit positions has a value of 0.</td></tr><tr><td>$bitsAnySet</td><td>Matches numeric or binary values in which any bit from a set of bit positions has a value of 1.</td></tr></tbody></table><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$comment</td><td>Adds a comment to a query predicate.</td></tr></tbody></table><h1 id="投影操作"><a href="#投影操作" class="headerlink" title="投影操作"></a>投影操作</h1><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>Projects the first element in an array that matches the query condition.</td></tr><tr><td>$elemMatch</td><td>Projects the first element in an array that matches the specified <code>$elemMatch</code> condition.</td></tr><tr><td>$meta</td><td>Projects the document’s score assigned during <code>$text</code> operation.</td></tr><tr><td>$slice</td><td>Limits the number of elements projected from an array. Supports skip and limit slices.</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB查询和投影操作符。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB集合的基本操作：插入记录（增）</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-collection-insert-1.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-collection-insert-1.html</id>
    <published>2018-07-02T07:46:48.000Z</published>
    <updated>2018-07-23T13:29:57.438Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB集合的基本操作：插入记录（增）。<br><a id="more"></a></p><h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>MongoDB的使用还是有一定难度的，官网讲解的一环牵扯一环，不容易一下子把握住重点，也不利于快速查询操作，所以整理一下，便于快速查找。另外，做一做笔记，对于记忆和理解也是有好处的，同时可以方便一些英语暂时不好的同学用来参考。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.2版本之后</span><br><span class="line">db.collection.insertOne()</span><br><span class="line">db.collection.insertMany()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.2版本之前</span><br><span class="line">db.collection.insert()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert(</span><br><span class="line">   &lt;document or array of documents&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.collection.insertOne(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.collection.insertMany(</span><br><span class="line">   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;,</span><br><span class="line">      ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th style="text-align:center">类型</th><th style="text-align:right">描述 </th></tr></thead><tbody><tr><td> document</td><td style="text-align:center">文档或者数组</td><td style="text-align:right">将要插入集合的文档或者文档数组。</td></tr><tr><td> writeConcern</td><td style="text-align:center">文档</td><td style="text-align:right">可选。待解释和细化。</td></tr><tr><td> ordered</td><td style="text-align:center">布尔型</td><td style="text-align:right">可选。插入数组时是否要按照顺序，默认为true。</td></tr></tbody></table><p><strong>实例</strong>：<br>数据库：my_test，之前文章创建的数据库，创建数据库，<a href="https://blog.csdn.net/chaiyu2002/article/details/80861839" target="_blank" rel="noopener">参看这里</a>。<br>集合：test。<br>插入记录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080199&quot;),</span><br><span class="line">    &quot;meta&quot; : &#123;</span><br><span class="line">        &quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">        &quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;a&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;b&quot; : &quot;1&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.test.insert(&#123;</span><br><span class="line">    &quot;meta&quot; : &#123;</span><br><span class="line">        &quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">        &quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;a&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;b&quot; : &quot;1&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure><p>看到最后这句，表示插入一条记录成功。<br>馈赠一条，为之后的例子做一个铺垫：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.test.insert(&#123;</span><br><span class="line">    &quot;meta&quot; : &#123;</span><br><span class="line">        &quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">        &quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;a&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;b&quot; : &quot;3&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure></p><p>查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080199&quot;),</span><br><span class="line">&quot;meta&quot; : &#123;</span><br><span class="line">&quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">&quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">&#125;,</span><br><span class="line">&quot;a&quot; : &quot;1&quot;,</span><br><span class="line">&quot;b&quot; : &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;5abb3b5bce69c048be080120&quot;),</span><br><span class="line">&quot;meta&quot; : &#123;</span><br><span class="line">&quot;createAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;),</span><br><span class="line">&quot;updateAt&quot; : ISODate(&quot;2018-03-28T06:51:07.579Z&quot;)</span><br><span class="line">&#125;,</span><br><span class="line">&quot;a&quot; : &quot;1&quot;,</span><br><span class="line">&quot;b&quot; : &quot;3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了两条记录，查询的语法请参考关于查询的文档。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.mongodb.com/manual/tutorial/insert-documents/。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/insert-documents/。</a><br><a href="https://docs.mongodb.com/manual/reference/method/db.collection.insert/#db.collection.insert。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/method/db.collection.insert/#db.collection.insert。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB集合的基本操作：插入记录（增）。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：touch</title>
    <link href="https://www.oxysun.cn/linux/shell-command-touch.html"/>
    <id>https://www.oxysun.cn/linux/shell-command-touch.html</id>
    <published>2018-07-01T06:28:00.000Z</published>
    <updated>2018-07-18T11:09:55.846Z</updated>
    
    <content type="html"><![CDATA[<p>touch命令用来创建文件，也可以更改和修改一个文件的时间戳。<br><a id="more"></a></p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p><code>touch [选项]... 文件...</code></p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>touch命令用来创建文件，也可以更改和修改一个文件的时间戳。Linux中的每个文件都与时间戳相关联，而且每个文件都存储上次访问时间，上次修改时间，上次更改时间的信息。因为，无论何时创建一个新文件，访问或者修改现有文件，时间戳都会被自动更新。<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-man.png" alt=""></p><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><p>Linux中的文件有三个时间：</p><ul><li>access time（atime）：访问时间，对一次文件的内容就会更新。例如cat，vi/vim，cp，touch命令。</li><li>modification time（mtime）：修改时间，对文件内容修改一次就会更新。例如touch，vi/vim命令。</li><li>status time（ctime）：状态改动时间。通过chmod/chown/chgrp等命令更改一次文件属性，通过touch准确地修改时间等，这个时间就会更新。例如mv，touch，chmod/chown/chgrp，vi/vim等命令。</li></ul><p>touch命令选项：</p><ul><li>-a，只改变访问时间。</li><li>-c，如果文件不存在，那就不创建。</li><li>-d，更新访问时间和修改时间。</li><li>-m，只改变修改时间。</li><li>-r，将参照文件ref_file相应的时间戳作为指定文件file时间戳的新值。</li><li>-t，用指定的时间创建文件，格式是[[CC]YY]MMDDhhmm[.SS]。CCYY的范围在1969~2068之内。SS为秒数，范围在0~61之间，这样可以处理闰秒。由于系统的限制，早于1970年1月1日的时间是错误的。</li></ul><h3 id="示例：1-创建空文件"><a href="#示例：1-创建空文件" class="headerlink" title="示例：1. 创建空文件"></a>示例：1. 创建空文件</h3><p>描述：若文件不存在，使用touch命令可以轻松地创建一个空文件，或是创建多个。如果文件已存在，那么文件的3个时间：修改时间（mtime）、状态改动时间（ctime）和访问时间（atime）都会被更新为当前时间。stat命令可以查看文件时间。<br>命令：<br><code>touch my_one</code><br><code>stat my_one</code><br><code>touch my_one my_two my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch.png" alt=""></p><h3 id="示例：2-只改变文件的修改时间（mtime）和状态改动时间（ctime）"><a href="#示例：2-只改变文件的修改时间（mtime）和状态改动时间（ctime）" class="headerlink" title="示例：2. 只改变文件的修改时间（mtime）和状态改动时间（ctime）"></a>示例：2. 只改变文件的修改时间（mtime）和状态改动时间（ctime）</h3><p>描述：只改变my_three文件的修改时间为当前时间，同时状态改动时间会在命令执行后更新为当前时间。这个操作并不需要修改文件内容。-m选项只更改文件的修改时间。<br>命令：<code>touch -m my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-m.png" alt=""></p><h3 id="示例：3-只改变文件访问时间（atime）和状态改动时间（ctime）"><a href="#示例：3-只改变文件访问时间（atime）和状态改动时间（ctime）" class="headerlink" title="示例：3. 只改变文件访问时间（atime）和状态改动时间（ctime）"></a>示例：3. 只改变文件访问时间（atime）和状态改动时间（ctime）</h3><p>描述：只改变my_three文件的访问时间为当前时间，同时状态改动时间会在命令执行后更新为当前时间。如果文件不存在，会创建新的空文件。-a选项只更改文件的访问时间。<br>命令：<code>touch -a my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-a.png" alt=""></p><h3 id="示例：4-指定文件的访问时间和修改时间"><a href="#示例：4-指定文件的访问时间和修改时间" class="headerlink" title="示例：4. 指定文件的访问时间和修改时间"></a>示例：4. 指定文件的访问时间和修改时间</h3><p>描述：同时设置文件的访问时间和修改时间为指定时间，同时会更新状态改变时间为当前命令执行后的时间。如果文件不存在，会创建新的空文件。-d选项同时改变文件的访问时间和修改时间。<br>命令：<code>touch -d &quot;2018-06-14 14:00:00&quot; my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-d.png" alt=""></p><p>描述：将my_three文件的访问时间和修改时间修改成两天前。touch还支持像date命令那样修改文件的时间。<br>命令：<code>touch -d &quot;2 days ago&quot; my_three</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-d-date.png" alt=""></p><h3 id="示例：5-避免创建新文件"><a href="#示例：5-避免创建新文件" class="headerlink" title="示例：5. 避免创建新文件"></a>示例：5. 避免创建新文件</h3><p>描述：更新atime、ctime、mtime，如果文件不存在，-c选项不会创建新的文件。<br>命令：<code>touch -c leena</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-a.png" alt=""></p><h3 id="示例：6-使用另一个文件的时间戳"><a href="#示例：6-使用另一个文件的时间戳" class="headerlink" title="示例：6. 使用另一个文件的时间戳"></a>示例：6. 使用另一个文件的时间戳</h3><p>描述：-r选项将my_three的时间戳作为my_two文件的时间戳的新值，这两个文件有相同的时间戳。<br>命令：<code>touch -r my_three my_two</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-r.png" alt=""></p><h3 id="示例：7-使用指定的时间戳创建一个文件"><a href="#示例：7-使用指定的时间戳创建一个文件" class="headerlink" title="示例：7. 使用指定的时间戳创建一个文件"></a>示例：7. 使用指定的时间戳创建一个文件</h3><p>描述：将my_four文件的时间戳指定为1997年6月14日17点00分55秒。时间格式是[[CC]YY]MMDDhhmm[.SS]。<br>命令：<code>touch -t 199706141700.55 my_four</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/touch/touch-t.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;touch命令用来创建文件，也可以更改和修改一个文件的时间戳。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Shell" scheme="https://www.oxysun.cn/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
