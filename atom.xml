<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT老兵驿站</title>
  
  <subtitle>一个IT老兵的驿站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.oxysun.cn/"/>
  <updated>2018-08-18T13:45:33.265Z</updated>
  <id>https://www.oxysun.cn/</id>
  
  <author>
    <name>荒于嬉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB学习笔记之一</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-study-note-1.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-study-note-1.html</id>
    <published>2018-08-18T13:37:00.000Z</published>
    <updated>2018-08-18T13:45:33.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。"><a href="#原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。" class="headerlink" title="原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。"></a>原帖位于<a href="https://www.oxysun.cn/mongodb/mongodb-study-note-1.html">IT老兵博客</a>，沉淀着一个IT老兵对于这个行业的多年的认知。</h2><p>MongoDB学习笔记。<br><a id="more"></a></p><!--提纲第一部分总结一下之前大概的学习情况，三段的学习历程，存在的问题，浪费了好多时间，写作这篇文章的目的。第二部分怎么开始的。选择学习的书籍。记录学习的过程。学习的态度，抨击速成的理念。中心思想？--><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先介绍一下学习MongoDB的历程。</p><p>对于MongoDB，是从14年听说的，当时大概地看了一下，没有仔细研究，</p><p>说实话，当时心里其实是有点排斥的。因为“浸淫”SQL多年（花了好些年去研究和使用MySQL、Oracle，研究各种范式，做的项目都是基于SQL的），突然出来一种<code>NoSQL</code>和<code>反范式设计</code>的概念，尤其是，突然有一堆刚毕业的，完全不懂范式，没有用范式做过系统的小朋友，跟你说“SQL已经过时”的时候，内心是非常排斥的，“你们连范式都还没有搞明白，都没有做出什么有点规模的系统，居然跟我奢谈说SQL已经过时”。</p><p>此外，还有一个因素，那就是一个老程序员，对于新技术的冲击，本能的有些排斥。新技术似乎会降低我们自身的价值，这个时候，我们就变成了保守派，想捍卫一些东西—-这是不可取的。</p><p>16年，在一家小公司任职，带领着团队研究新技术（小公司往往有机会去研究和使用新技术），大概看了看（看了一本好像是国人写的MongoDB的书），自以为大体是掌握了—-自以为是了。</p><p>18年，开始真正要用MongoDB做一个项目，才发现之前掌握的，完全不到位。这个时候，端正了心态，踏踏实实地开始学习，到现在有了一些小的心得。</p><p>这个时候回想，如果当初不要那么浮光绿影地看书，而是踏踏实实地，结合着书籍，写一些实例应用，可能会掌握得更加清楚。这样，总共加起来，花费的学习时间应该会缩短很多，有的时候，要把有的事情做到位才会有效果，正是“纸上得来终觉浅，绝知此事要躬行”。</p><p>所以，为了总结这一个过程，记录笔记来跟踪整个学习的过程，到现在为止，已经总结了几篇MongoDB的使用方式，感觉还是不足以完整地记录整个学习过程，所以，再用这种方式记录一下，串联起来。</p><p>这个笔记，计划是花一个多月的时间，争取每周输出几篇，每一篇的篇幅不会太长，根据一个统一的原则来进行每篇内容的拆分，最终达到对MongoDB的外围和内延的认识达到一个深度。总共的篇幅，暂时还不确定，达到了最终的目的为止，最后输出一个可以对学习MongoDB很有帮助的系列性的笔记。</p><p>本篇笔记，稍微啰嗦一下，现在可以理解很多书籍的前言了，这个时候总想表达一下写作的目的，中间的经历和艰辛，很多心得和感悟，从这个角度来说，本篇其实就是前言了。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>“工欲善其事必先利其器”，想学好MongoDB，先得选择好的学习资料。从从业十多年的经验中，我得到一个认知，“因快得慢”。举一个例子，当年快毕业，准备出去面试，需要学习linux的一些基本原理，这个时候，摆在面前的有几种资料，一种是《Linux与unix shell编程指南》，这是当时很经典的书籍，但是篇幅较长；另外一种是，速成的教程（原谅我连名字都不记得了，因为实在是没有太多的价值）。当时我果断的选择了后者，结果因为这种速成的教程往往只是讲了一些最没有价值的东西，就像快餐一样，真正有营养的东西，需要慢慢去吸收和消化。后来，其实又花了很多气力，踏踏实实地重来一遍，这样算来，第一遍花费的时间，一点都没有意义，所以，这就是计算机学习，为什么要去读经典的原理，这才是最节省时间的方式，走得越扎实，其实才是走的最快的方式。</p><p>官网，<a href="https://docs.mongodb.com/，" target="_blank" rel="noopener">https://docs.mongodb.com/，</a> 永远是学习的第一选择，MongoDB的手册官网做的稍微有些复杂，但是它的例子比较丰富，这对于学习起来，帮助很大。不过，官网是英文的，对于很多人来说，是有些困难的（当然，如果想成为一个好的程序员，这个困难是需要客服的）。</p><p>Stack Overflow网站，<a href="https://stackoverflow.com/，" target="_blank" rel="noopener">https://stackoverflow.com/，</a> 寻找某些问题答案最好的网站，从10年开始，我已经把它看做是和官网差不多比重的资料网站了。</p><p>《MongoDB权威指南》，O’REILLY的书一般质量都还不错，当然，在京东上看看评论，找一本其他评价高的书来作为资料都是可以的。</p><p>好了，神器在手，天下我有，准备启程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。&quot;&gt;&lt;a href=&quot;#原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。&quot; class=&quot;headerlink&quot; title=&quot;原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。&quot;&gt;&lt;/a&gt;原帖位于&lt;a href=&quot;https://www.oxysun.cn/mongodb/mongodb-study-note-1.html&quot;&gt;IT老兵博客&lt;/a&gt;，沉淀着一个IT老兵对于这个行业的多年的认知。&lt;/h2&gt;&lt;p&gt;MongoDB学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/tags/MongoDB/"/>
    
      <category term="学习笔记" scheme="https://www.oxysun.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《6 Rules of Thumb for MongoDB Schema Design》 Part 1 翻译和笔记</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-schema-design-note.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-schema-design-note.html</id>
    <published>2018-08-17T07:29:48.000Z</published>
    <updated>2018-08-18T00:08:05.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。"><a href="#原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。" class="headerlink" title="原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。"></a>原帖位于<a href="https://www.oxysun.cn/mongodb/mongodb-schema-design-note.html">IT老兵博客</a>，沉淀着一个IT老兵对于这个行业的多年的认知。</h2><p>MongoDB如何设计数据模型。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中遇到了要使用MongoDB，学习MongoDB，肯定不能仅仅停留于对一些指令的简单操作的掌握，就像当初学习MySQL一样，要了解一下如何使用MongoDB来设计数据库。这里，找到一篇很好的文章，转载在下面，配上一定的翻译和学习笔记，原文也不是很复杂，贴上原文，是为了不误导读者，也不误导自己，将来可以不断再纠正其中理解不准确的地方。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>By William Zola, Lead Technical Support Engineer at MongoDB</p></blockquote><blockquote><p>“I have lots of experience with SQL, but I’m just a beginner with MongoDB. How do I model a one-to-N relationship?” This is one of the more common questions I get from users attending MongoDB office hours.</p></blockquote><blockquote><p>I don’t have a short answer to this question, because there isn’t just one way, there’s a whole rainbow’s worth of ways. MongoDB has a rich and nuanced vocabulary for expressing what, in SQL, gets flattened into the term “One-to-N”. Let me take you on a tour of your choices in modeling One-to-N relationships.</p></blockquote><p><strong>笔记：</strong> MongoDB的新手往往会遇到一个问题，我应该怎么去定义一个one-to-N的关系呢？“there’s a whole rainbow’s worth of ways. ”这句应该怎么理解呢？</p><blockquote><p>There’s so much to talk about here, I’m breaking this up into three parts. In this first part, I’ll talk about the three basic ways to model One-to-N relationships. In the second part I’ll cover more sophisticated schema designs, including denormalization and two-way referencing. And in the final part, I’ll review the entire rainbow of choices, and give you some suggestions for choosing among the thousands (really – thousands) of choices that you may consider when modeling a single One-to-N relationship.</p></blockquote><p><strong>笔记：</strong> 这里有很多需要讨论，笔记会将它分为三个部分来讨论。第一部分，也就是本篇文章，来讨论三种建立One-to-N关系模型的基本的方法；第二部分，讨论更复杂的模型设计，包括反范式（denormalization）和双向参考（two-way referencing）；最后一部分，将会复习整个选择的过程，并且给你们一些建立，来在上千的建立一个One-to-N关系的选择中做出判断。</p><blockquote><p>Many beginners think that the only way to model “One-to-N” in MongoDB is to embed an array of sub-documents into the parent document, but that’s just not true. Just because you can embed a document, doesn’t mean you should embed a document.</p></blockquote><p><strong>笔记：</strong> 很多初学者会认为在MongoDB中建立一个“One-to-N”的模型只有一种方法，就是嵌入一个子文档的数组（array），这不是事实。确实是这样，看到的很多帖子就是这么去误导别人。</p><blockquote><p>When designing a MongoDB schema, you need to start with a question that you’d never consider when using SQL: what is the cardinality of the relationship? Put less formally: you need to characterize your “One-to-N” relationship with a bit more nuance: is it “one-to-few”, “one-to-many”, or “one-to-squillions”? Depending on which one it is, you’d use a different format to model the relationship.</p></blockquote><p><strong>笔记：</strong> 在开始设计一个MongoDB的模式时，你需要考虑一个在使用SQL从来不需要考虑的问题：关系的基数是什么？具体来说，就是要考虑“one-to-few”，“one-to-many”, 或者“one-to-squillions”，这个基数不同，设计的格式也不同。</p><blockquote><p>Basics: Modeling One-to-Few</p></blockquote><blockquote><p>An example of “one-to-few” might be the addresses for a person. This is a good use case for embedding – you’d put the addresses in an array inside of your Person object:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.person.findOne()</span><br><span class="line">&#123;</span><br><span class="line">  name: &apos;Kate Monster&apos;,</span><br><span class="line">  ssn: &apos;123-456-7890&apos;,</span><br><span class="line">  addresses : [</span><br><span class="line">     &#123; street: &apos;123 Sesame St&apos;, city: &apos;Anytown&apos;, cc: &apos;USA&apos; &#125;,</span><br><span class="line">     &#123; street: &apos;123 Avenue Q&apos;, city: &apos;New York&apos;, cc: &apos;USA&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>This design has all of the advantages and disadvantages of embedding. The main advantage is that you don’t have to perform a separate query to get the embedded details; the main disadvantage is that you have no way of accessing the embedded details as stand-alone entities.</p></blockquote><p><strong>笔记：</strong> 上面这是一个常见One-to-Few的例子，个人信息和地址的关系。好处在于你不用单独执行一个查询去获取嵌入的信息；坏处在于你无法根据作为一个单独的条目去访问一个嵌入的内容。这个例子很形象，在那本MySQL实例中，也涉及到人和地址的关系处理。就是说大千世界的一对多的关系其实不是那么一刀切的，而SQL对这个的处理能力是有限的，或者说SQL原本的设计是没有太多考虑这个因素的。这个应该结合那本书一起来讨论，待完成……</p><blockquote><p>For example, if you were modeling a task-tracking system, each Person would have a number of Tasks assigned to them. Embedding Tasks inside the Person document would make queries like “Show me all Tasks due tomorrow” much more difficult than they need to be. I will cover a more appropriate design for this use case in the next post.</p></blockquote><blockquote><p>Basics: One-to-Many</p></blockquote><blockquote><p>An example of “one-to-many” might be parts for a product in a replacement parts ordering system. Each product may have up to several hundred replacement parts, but never more than a couple thousand or so. (All of those different-sized bolts, washers, and gaskets add up.) This is a good use case for referencing – you’d put the ObjectIDs of the parts in an array in product document. (For these examples I’m using 2-byte ObjectIDs because they’re easier to read: real-world code would use 12-byte ObjectIDs.)</p></blockquote><blockquote><p>Each Part would have its own document:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.parts.findOne()</span><br><span class="line">&#123;</span><br><span class="line">    _id : ObjectID(&apos;AAAA&apos;),</span><br><span class="line">    partno : &apos;123-aff-456&apos;,</span><br><span class="line">    name : &apos;#4 grommet&apos;,</span><br><span class="line">    qty: 94,</span><br><span class="line">    cost: 0.94,</span><br><span class="line">    price: 3.99</span><br></pre></td></tr></table></figure><blockquote><p>Each Product would have its own document, which would contain an array of ObjectID references to the Parts that make up that Product:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.products.findOne()</span><br><span class="line">&#123;</span><br><span class="line">    name : &apos;left-handed smoke shifter&apos;,</span><br><span class="line">    manufacturer : &apos;Acme Corp&apos;,</span><br><span class="line">    catalog_number: 1234,</span><br><span class="line">    parts : [     // array of references to Part documents</span><br><span class="line">        ObjectID(&apos;AAAA&apos;),    // reference to the #4 grommet above</span><br><span class="line">        ObjectID(&apos;F17C&apos;),    // reference to a different Part</span><br><span class="line">        ObjectID(&apos;D2AA&apos;),</span><br><span class="line">        // etc</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><blockquote><p>You would then use an application-level join to retrieve the parts for a particular product:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Fetch the Product document identified by this catalog number</span><br><span class="line">product = db.products.findOne(&#123;catalog_number: 1234&#125;);</span><br><span class="line">// Fetch all the Parts that are linked to this Product</span><br><span class="line">product_parts = db.parts.find(&#123;_id: &#123; $in : product.parts &#125; &#125; ).toArray() ;</span><br></pre></td></tr></table></figure><p><strong>笔记：</strong> 这个例子是产品和配件的关系，是One-to-Many的关系。产品会有很多的配件，所以这里使用ObjectID来关联，这是一个单项关联。这个例子也是很常见的用来描述One-to-Many关系的。</p><blockquote><p>For efficient operation, you’d need to have an index on ‘products.catalog_number’. Note that there will always be an index on ‘parts._id’, so that query will always be efficient.</p></blockquote><blockquote><p>This style of referencing has a complementary set of advantages and disadvantages to embedding. Each Part is a stand-alone document, so it’s easy to search them and update them independently. One trade off for using this schema is having to perform a second query to get details about the Parts for a Product. (But hold that thought until we get to denormalizing in part 2.)</p></blockquote><p><strong>笔记：</strong> 好处在于每一个配件都有一个独立的文档，很容易查询和更新。交换就是需要单独执行一个查询去获取配件信息。</p><blockquote><p>As an added bonus, this schema lets you have individual Parts used by multiple Products, so your One-to-N schema just became an N-to-N schema without any need for a join table!</p></blockquote><blockquote><p>Basics: One-to-Squillions</p></blockquote><blockquote><p>An example of “one-to-squillions” might be an event logging system that collects log messages for different machines. Any given host could generate enough messages to overflow the 16 MB document size, even if all you stored in the array was the ObjectID. This is the classic use case for “parent-referencing” – you’d have a document for the host, and then store the ObjectID of the host in the documents for the log messages.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.hosts.findOne()</span><br><span class="line">&#123;</span><br><span class="line">    _id : ObjectID(&apos;AAAB&apos;),</span><br><span class="line">    name : &apos;goofy.example.com&apos;,</span><br><span class="line">    ipaddr : &apos;127.66.66.66&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.logmsg.findOne()</span><br><span class="line">&#123;</span><br><span class="line">    time : ISODate(&quot;2014-03-28T09:42:41.382Z&quot;),</span><br><span class="line">    message : &apos;cpu is on fire!&apos;,</span><br><span class="line">    host: ObjectID(&apos;AAAB&apos;)       // Reference to the Host document</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>You’d use a (slightly different) application-level join to find the most recent 5,000 messages for a host:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// find the parent ‘host’ document</span><br><span class="line">host = db.hosts.findOne(&#123;ipaddr : &apos;127.66.66.66&apos;&#125;);  // assumes unique index</span><br><span class="line">// find the most recent 5000 log message documents linked to that host</span><br><span class="line">last_5k_msg = db.logmsg.find(&#123;host: host._id&#125;).sort(&#123;time : -1&#125;).limit(5000).toArray()</span><br></pre></td></tr></table></figure><p><strong>笔记：</strong> 主机和日志的关系来体现One-to-Squillions，区别在于关系建立在了孩子身上，孩子指向了父亲。</p><blockquote><p>Recap</p></blockquote><blockquote><p>So, even at this basic level, there is more to think about when designing a MongoDB schema than when designing a comparable relational schema. You need to consider two factors:</p></blockquote><blockquote><p>Will the entities on the “N” side of the One-to-N ever need to stand alone?<br>What is the cardinality of the relationship: is it one-to-few; one-to-many; or one-to-squillions?</p></blockquote><p><strong>笔记：</strong></p><p>在设计关系时，你需要考虑两个因素：</p><p>One-to-N的“N”这边需要单独作为一个条目吗？<br>关系的基数是什么：one-to-few；one-to-many；或者 one-to-squillions？<br>Based on these factors, you can pick one of the three basic One-to-N schema designs:</p><blockquote><p>Embed the N side if the cardinality is one-to-few and there is no need to access the embedded object outside the context of the parent object<br>Use an array of references to the N-side objects if the cardinality is one-to-many or if the N-side objects should stand alone for any reasons<br>Use a reference to the One-side in the N-side objects if the cardinality is one-to-squillions<br>笔记：</p></blockquote><p>基于这些因素，你可以考虑这三个基本模式设计：</p><p>如果基数是one-to-few，并且在父对象的上下文之外没有访问嵌入的对象的需求，那么嵌入N边。<br>如果基数是one-to-many，或者N边的对象基于一些原因需要单独展示，那么使用一个数组来指向N边的对象。<br>如果基数是one-to-squillions，使用一个参考去指向One那边。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习和梳理了这篇文章，感觉思路清晰了很多，MongoDB是在One-to-N这个领域做了很多设计，这可能也是跟当前的One-to-N的需求越来越多，而SQL对这个支持有限有关系。</p><p>待办的事情，配合总结一下MySQL的设计模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。&quot;&gt;&lt;a href=&quot;#原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。&quot; class=&quot;headerlink&quot; title=&quot;原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的多年的认知。&quot;&gt;&lt;/a&gt;原帖位于&lt;a href=&quot;https://www.oxysun.cn/mongodb/mongodb-schema-design-note.html&quot;&gt;IT老兵博客&lt;/a&gt;，沉淀着一个IT老兵对于这个行业的多年的认知。&lt;/h2&gt;&lt;p&gt;MongoDB如何设计数据模型。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/tags/MongoDB/"/>
    
      <category term="schema" scheme="https://www.oxysun.cn/tags/schema/"/>
    
  </entry>
  
  <entry>
    <title>Java：Shiro的架构学习笔记</title>
    <link href="https://www.oxysun.cn/java/java-shiro-note.html"/>
    <id>https://www.oxysun.cn/java/java-shiro-note.html</id>
    <published>2018-08-17T02:38:00.000Z</published>
    <updated>2018-08-18T00:08:05.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的认知。"><a href="#原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的认知。" class="headerlink" title="原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的认知。"></a>原帖位于<a href="https://www.oxysun.cn/java/java-shiro-note.html">IT老兵博客</a>，沉淀着一个IT老兵对于这个行业的认知。</h2><p>Java：Shiro的架构学习笔记。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>张开涛的第一章 Shiro简介——《跟我学Shiro》，其实是解读了一下<a href="https://shiro.apache.org/architecture.html" target="_blank" rel="noopener">Shiro的架构</a>这篇文章，本着寻根究底的态度，我再一次去阅读这篇文章。为什么说是再一次呢？因为之前读过好几次了，不过就是没有完全理解明白，自己也说不好卡在哪里了，包括张开涛的文章，我也读过两遍了，这次第三遍读，一下子豁然开朗，然后不明白之前为啥就没读明白。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="3个主要的概念：Subject-SecurityManager和Realms。"><a href="#3个主要的概念：Subject-SecurityManager和Realms。" class="headerlink" title="3个主要的概念：Subject, SecurityManager和Realms。"></a>3个主要的概念：<code>Subject</code>, <code>SecurityManager</code>和<code>Realms</code>。</h2><p><img src="https://shiro.apache.org/assets/images/ShiroBasicArchitecture.png" alt="这里写图片描述"></p><p><code>Subject</code>可以是一个用户，但不仅仅可以代表一个用户，所有对这个系统的外部请求的主体都可以看成是一个<code>Subject</code>，例如一个<code>service</code>，这里是做了一个抽象概括的设计，这个我能理解，如果你理解不了的话，那说明你还没有接触过相关的业务，例如<code>SSO</code>，那就先把它理解成一个用户，也没有关系。将来总有一天，你会明白，会回来和我一起唱这首《当当当》。</p><p><code>SecurityManager</code> Shiro设计的核心的逻辑都在这里面，但是，我们应该可以先不理会它是怎么工作的，先把它当做一个黑匣子，它有它自己运行的逻辑。</p><p><code>Realms</code> 这个单词的意思是领域，范围。原文这么说：</p><blockquote><p>Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application.</p></blockquote><blockquote><p>In this sense a Realm is essentially a security-specific DAO: it encapsulates connection details for data sources and makes the associated data available to Shiro as needed. When configuring Shiro, you must specify at least one Realm to use for authentication and/or authorization. The SecurityManager may be configured with multiple Realms, but at least one is required.</p></blockquote><p>就是说和安全相关数据（<code>security-specific</code>）打交道的是这个对象，有关认证、授权都是通过它来打交道，或者说，通过不同的realm来和相关的“机构”（打个比方）打交道，每个机构有自己的<code>realm</code>，再或者说，<code>realm</code>可以理解成<code>DAO</code>，去访问相关的数据。</p><h2 id="更具体的分析："><a href="#更具体的分析：" class="headerlink" title="更具体的分析："></a>更具体的分析：</h2><p><img src="https://shiro.apache.org/assets/images/ShiroArchitecture.png" alt="这里写图片描述"></p><blockquote><p>Subject：A security-specific ‘view’ of the entity (user, 3rd-party service, cron job, etc) currently interacting with the software.</p></blockquote><p>一个实体的安全相关的<code>view</code>–这个概念还需要好好理解一下，怎么被称为一个<code>view</code>呢？</p><p>SecurityManager又分为了一些子模块：</p><blockquote><p>Authenticator (org.apache.shiro.authc.Authenticator)<br>The Authenticator is the component that is responsible for executing and reacting to authentication (log-in) attempts by users. When a user tries to log-in, that logic is executed by the Authenticator. The Authenticator knows how to coordinate with one or more Realms that store relevant user/account information. The data obtained from these Realms is used to verify the user’s identity to guarantee the user really is who they say they are.<br><br><br>Authentication Strategy (org.apache.shiro.authc.pam.AuthenticationStrategy)<br>If more than one Realm is configured, the AuthenticationStrategy will coordinate the Realms to determine the conditions under which an authentication attempt succeeds or fails (for example, if one realm succeeds but others fail, is the attempt successful? Must all realms succeed? Only the first?).</p></blockquote><p>Authenticator：认证器，用来负责用户登录认证，它对应着一个或者多个<code>Realm</code>。<br>Authentication Strategy：认证策略，如果多个<code>Realm</code> 被配置，那么<code>Authentication Strategy</code>来负责协调这些<code>Realm</code> 产生矛盾的时候，该如何处理，例如一个<code>realm</code>成功，而其它的失败了，改怎么办，等等。在这一点上，张开涛的文章解释的不是太准确。</p><p>Authrizer：授权器，负责确认用户的访问权限。</p><blockquote><p>SessionManager (org.apache.shiro.session.mgt.SessionManager)<br>The SessionManager knows how to create and manage user Session lifecycles to provide a robust Session experience for users in all environments. This is a unique feature in the world of security frameworks - Shiro has the ability to natively manage user Sessions in any environment, even if there is no Web/Servlet or EJB container available. By default, Shiro will use an existing session mechanism if available, (e.g. Servlet Container), but if there isn’t one, such as in a standalone application or non-web environment, it will use its built-in enterprise session management to offer the same programming experience. The SessionDAO exists to allow any datasource to be used to persist sessions.<br><br><br>SessionDAO (org.apache.shiro.session.mgt.eis.SessionDAO)<br>The SessionDAO performs Session persistence (CRUD) operations on behalf of the SessionManager. This allows any data store to be plugged in to the Session Management infrastructure.</p></blockquote><p><code>SessionManager</code>：<code>session</code>管理器，<code>Shiro</code>没有完全依赖<code>HTTP</code>的<code>session</code>，而是设计了一个独立的<code>session</code>。<br><code>SessionDAO</code>：<code>session</code>的<code>DAO</code>，用来处理session数据的保存。</p><p><code>CacheManager</code>：缓存管理器。</p><p><code>Cryptography</code>：加密模块。</p><p><code>Realms：</code>上面介绍过。</p><h2 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h2><p>这个是核心，需要反复理解的是这个，下面又用了一些篇幅来介绍这个，不过在没有完全实践之前，总还是不明白，所以就先不总结了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又阅读了一遍架构这篇文章，结合着张开涛的文章，感觉明白了不少，现在感觉<code>Shiro</code> 还是挺简单的，有个两三天应该就大体理解了，不明白当时怎么就堵住了，陷入了思维的死胡同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的认知。&quot;&gt;&lt;a href=&quot;#原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的认知。&quot; class=&quot;headerlink&quot; title=&quot;原帖位于IT老兵博客，沉淀着一个IT老兵对于这个行业的认知。&quot;&gt;&lt;/a&gt;原帖位于&lt;a href=&quot;https://www.oxysun.cn/java/java-shiro-note.html&quot;&gt;IT老兵博客&lt;/a&gt;，沉淀着一个IT老兵对于这个行业的认知。&lt;/h2&gt;&lt;p&gt;Java：Shiro的架构学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.oxysun.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.oxysun.cn/tags/Java/"/>
    
      <category term="shiro" scheme="https://www.oxysun.cn/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-reflog的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-reflog.html"/>
    <id>https://www.oxysun.cn/git/git-reflog.html</id>
    <published>2018-08-17T02:15:00.000Z</published>
    <updated>2018-08-18T00:08:05.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-reflog.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>git-reflog的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>git-reflog是用来恢复本地错误操作很重要的一个命令，所以在这里对它进行一下整理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>管理reflog信息。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog &lt;subcommand&gt; &lt;options&gt;</span><br></pre></td></tr></table></figure><p>具体的用法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reflog [show] [log-options] [&lt;ref&gt;]</span><br><span class="line">git reflog expire [--expire=&lt;time&gt;] [--expire-unreachable=&lt;time&gt;] [--rewrite] [--updateref] [--stale-fix] [--dry-run | -n] [--verbose] [--all | &lt;refs&gt;…​]</span><br><span class="line">git reflog delete [--rewrite] [--updateref] [--dry-run | -n] [--verbose] ref@&#123;specifier&#125;…​</span><br><span class="line">git reflog exists &lt;ref&gt;</span><br></pre></td></tr></table></figure><p>Reference logs, or “reflogs”, record when the tips of branches and other references were updated in the local repository.</p><p>这句话怎么理解呢，记录了“when”，时间？</p><p>翻译：Reference logs（参考日志），或者叫做”reflogs”，记录了分支的tips（提示信息？）或者其他参考在本地仓库被更新的时间（when）。</p><p>问题来了，这个参考日志的作用是什么，和日志又有什么区别呢？</p><p>找到了这篇<a href="https://stackoverflow.com/questions/17857723/whats-the-difference-between-git-reflog-and-log" target="_blank" rel="noopener">帖子</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log shows the current HEAD and its ancestry. That is, it prints the commit HEAD points to, then its parent, its parent, and so on. It traverses back through the repo&apos;s ancestry, by recursively looking up each commit&apos;s parent.</span><br><span class="line"></span><br><span class="line">(In practice, some commits have more than one parent. To see a more representative log, use a command like git log --oneline --graph --decorate.)</span><br><span class="line"></span><br><span class="line">git reflog doesn&apos;t traverse HEAD&apos;s ancestry at all. The reflog is an ordered list of the commits that HEAD has pointed to: it&apos;s undo history for your repo. The reflog isn&apos;t part of the repo itself (it&apos;s stored separately to the commits themselves) and isn&apos;t included in pushes, fetches or clones; it&apos;s purely local.</span><br><span class="line"></span><br><span class="line">Aside: understanding the reflog means you can&apos;t really lose data from your repo once it&apos;s been committed. If you accidentally reset to an older commit, or rebase wrongly, or any other operation that visually &quot;removes&quot; commits, you can use the reflog to see where you were before and git reset --hard back to that ref to restore your previous state. Remember, refs imply not just the commit but the entire history behind it.</span><br></pre></td></tr></table></figure><p>上面就讲的比较清楚了，总结一下：</p><p><code>git log</code>是显示当前的<code>HEAD</code>和它的祖先的，递归是沿着当前指针的父亲，父亲的父亲，……，这样的原则。<br><code>git reflog</code>根本不遍历<code>HEAD</code>的祖先。它是<code>HEAD</code>所指向的一个顺序的提交列表：它的<code>undo</code>历史。<code>reflog</code>并不是<code>repo</code>（仓库）的一部分，它单独存储，而且不包含在<code>pushes</code>，<code>fetches</code>或者<code>clones</code>里面，它纯属是本地的。<br><code>reflog</code>可以很好地帮助你恢复你误操作的数据，例如你错误地<code>reset</code>了一个旧的提交，或者<code>rebase</code>，……，这个时候你可以使用<code>reflog</code>去查看在误操作之前的信息，并且使用<code>git reset --hard</code> 去恢复之前的状态。<br>下面研究一下这个命令的具体用法。</p><p>先了解一下<code>git</code>的版本表示方法：</p><blockquote><p>HEAD@{2} means “where HEAD used to be two moves ago”, master@{one.week.ago}means “where master used to point to one week ago in this local repository”</p></blockquote><p><code>HEAD@{2}</code>表示<code>HEAD</code>指针在两次移动之前的情况；而 <code>master@{one.week.ago}</code>表示<code>master</code>在本地仓库一周之前的情况。</p><p>“show”子命令显示所指定的参考的日志。</p><p><strong>实例：</strong> 显示<code>HEAD</code>的<code>reflog</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog show</span><br><span class="line">ef64f10 (HEAD -&gt; BlueLake_theme) HEAD@&#123;0&#125;: commit: 新增ethereum-programming-intr                                                                                      oduction</span><br><span class="line">122e0ec (origin/BlueLake_theme) HEAD@&#123;1&#125;: commit: 移除了冗余的ethereum-rationale                                                                                      文章</span><br><span class="line">c17fbbb HEAD@&#123;2&#125;: commit: 新增git-change-server-password文章</span><br><span class="line">1603d1a HEAD@&#123;3&#125;: pull: Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line">0ce1e93 HEAD@&#123;4&#125;: commit: 新增了以太坊原理</span><br><span class="line">c73503c HEAD@&#123;5&#125;: commit: 修改了-X-Frame-Options的关键字</span><br><span class="line">6af02f6 HEAD@&#123;6&#125;: commit: 新增了git-tag的文章；修改了git其他的文章，规范了名字、                                                                                      关键字</span><br><span class="line">9087fbd HEAD@&#123;7&#125;: commit: 新增了gti-reset文章</span><br><span class="line">039d95c HEAD@&#123;8&#125;: commit: 移除了没用的目录</span><br><span class="line">ff72601 HEAD@&#123;9&#125;: commit: 修改成了next主题</span><br><span class="line">ef64f10 (HEAD -&gt; BlueLake_theme) HEAD@&#123;0&#125;: commit: 新增ethereum-programming-intr                                                                                      oduction</span><br></pre></td></tr></table></figure><p>从上图可以看到，几乎所有的操作都记录在其中，这个就像MySQL，随时可以回滚。</p><p>“expire”子命令会删除掉更老的reflog条目。 </p><p>“delete”子命令从reflog中删除一个条目。 </p><p>“exists”子命令检查一个ref是否有一个reflog。 </p><p>这几个命令就相对比较简单了，以后再尝试了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/docs/git-reflog" target="_blank" rel="noopener">https://git-scm.com/docs/git-reflog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-reflog.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;git-reflog的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="git reflog" scheme="https://www.oxysun.cn/tags/git-reflog/"/>
    
  </entry>
  
  <entry>
    <title>区块链：教程 | 以太坊智能合约编程之菜鸟教程及学习笔记</title>
    <link href="https://www.oxysun.cn/blockchain/ethereum-programming-introduction.html"/>
    <id>https://www.oxysun.cn/blockchain/ethereum-programming-introduction.html</id>
    <published>2018-08-10T08:53:00.000Z</published>
    <updated>2018-08-18T00:08:05.863Z</updated>
    
    <content type="html"><![CDATA[<p>区块链：教程 | 以太坊智能合约编程之菜鸟教程及学习笔记。<br><a id="more"></a></p><blockquote><p>这篇介绍以太坊合约的文章写得很好，在查找了这么多资料，进行对比之后，感觉阅读这一篇就可以大体理解以太坊编程的原理，如果对个别的知识点还有点含糊，可以相应地去查一查，就是以这篇为主干，别的资料为辅。稍微整理了一下格式，以及修改了一些半角符号。</p></blockquote><p><em>译注：<a href="http://consensys.github.io/developers/articles/101-noob-intro/" target="_blank" rel="noopener">原文</a>首发于ConsenSys开发者博客，原作者为Eva以及ConsenSys的开发团队。如果您想要获取更多及时信息，可以访问<a href="https://consensys.net/" target="_blank" rel="noopener">ConsenSys</a>首页点击左下角Newsletter订阅邮件。本文的翻译获得了ConsenSys创始人Lubin先生的授权。</em></p><p>有些人说以太坊太难对付，于是我们(译注：指<a href="http://consensys.net" target="_blank" rel="noopener">Consensys</a>, 下同)写了这篇文章来帮助大家学习如何利用以太坊编写智能合约和应用。这里所用到的工具，钱包，应用程序以及整个生态系统仍处于开发状态，它们将来会更好用！</p><ul><li><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.%20%E6%A6%82%E8%BF%B0">第一部分</a>概述，讨论了关键概念，几大以太坊客户端以及写智能合约用到的编程语言。</li><li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.%20DApp%E6%A1%86%E6%9E%B6,%20%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">第二部分</a>讨论了总体的工作流程，以及目前流行的一些DApp框架和工具。</li><li><a href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86.%20%E7%BC%96%E7%A8%8B">第三部分</a>主要关于编程，我们将学习如何使用Truffle来为智能合约编写测试和构建DApp。</li></ul><h2 id="第一部分-概述"><a href="#第一部分-概述" class="headerlink" title="第一部分 概述"></a>第一部分 概述</h2><p>如果你对诸如比特币以及其工作原理等密码学货币的概念完全陌生，我们建议你先看看Andreas Antonopoulos所著的<a href="https://github.com/aantonop/bitcoinbook" target="_blank" rel="noopener">Bitcoin Book</a>的头几章，然后读一下<a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="noopener">以太坊白皮书</a>。(译注：以太坊白皮书中文版请看 <a href="http://ethfans.org/posts/ethereum-whitepaper" target="_blank" rel="noopener">http://ethfans.org/posts/ethereum-whitepaper</a>)</p><p>如果你觉得白皮书中的章节太晦涩，也可以直接动手来熟悉以太坊。在以太坊上做开发并不要求你理解所有那些“密码经济计算机科学”(crypto economic computer science)，而白皮书的大部分是关于以太坊想对于比特币架构上的改进。</p><h3 id="新手教程"><a href="#新手教程" class="headerlink" title="新手教程"></a>新手教程</h3><p><a href="http://ethereum.org" target="_blank" rel="noopener">ethereum.org</a>提供了官方的新手入门教程，以及一个代币合约和众筹合约的教程。合约语言Solidity也有<a href="https://ethereum.github.io/solidity/" target="_blank" rel="noopener">官方文档</a>。学习智能合约的另一份不错的资料（也是我的入门资料）是<a href="https://dappsforbeginners.wordpress.com/" target="_blank" rel="noopener">dappsForBeginners</a>，不过现在可能有些过时了。</p><p>这篇文章的目的是成为上述资料的补充，同时介绍一些基本的开发者工具，使入门以太坊，智能合约以及构建DApps(decentralized apps, 分布式应用)更加容易。我会试图按照我自己(依然是新手)的理解来解释工作流程中的每一步是在做什么，我也得到了ConsenSys酷酷的开发者们的许多帮助。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>了解这些名词是一个不错的开始：</p><p><strong>公钥加密系统。</strong> Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的<code>0xdf...5f</code>地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。过来人表示：通过踩坑学习到这一点是非常痛苦的…</p><p><strong>点对点网络。</strong> 就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。(未来会有半中心化的混合型服务出现为用户和开发者提供方便，这我们后面会讲到。)</p><p><strong>区块链。</strong> 区块链就像是一个全球唯一的帐簿，或者说是数据库，记录了网络中所有交易历史。</p><p><strong>以太坊虚拟机(EVM)。</strong> 它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。</p><p><strong>节点。</strong> 你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。</p><p><strong>矿工。</strong> 挖矿，也就是处理区块链上的区块的节点。这个网页可以看到当前活跃的一部分以太坊矿工：<a href="http://stats.ethdev.com" target="_blank" rel="noopener">stats.ethdev.com</a>。</p><p><strong>工作量证明。</strong> 矿工们总是在竞争解决一些数学问题。第一个解出答案的(算出下一个区块)将获得以太币作为奖励。然后所有节点都更新自己的区块链。所有想要算出下一个区块的矿工都有与其他节点保持同步，并且维护同一个区块链的动力，因此整个网络总是能达成共识。(注意：以太坊正计划转向没有矿工的权益证明系统(POS)，不过那不在本文讨论范围之内。)</p><p><strong>以太币。</strong> 缩写ETH。一种你可以购买和使用的真正的数字货币。这里是可以交易以太币的其中一家交易所的<a href="https://poloniex.com/exchange#usdt_eth" target="_blank" rel="noopener">走势图</a>。在写这篇文章的时候，1个以太币价值65美分。</p><p><strong>Gas。(汽油)</strong> 在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。</p><p><strong>DApp。</strong> 以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。(花一分钟思考一下：与一般的网站不同，DApp不能跑在普通的服务器上。他们需要提交交易到<strong>区块链</strong>并且从<strong>区块链</strong>而不是中心化数据库读取<strong>重要</strong>数据。相对于典型的用户登录系统，用户有可能被表示成一个钱包地址而其它用户数据保存在本地。许多事情都会与目前的web应用有不同架构。)</p><p>如果想看看从另一个新手视角怎么理解这些概念，请读<a href="https://medium.com/@user1/time-sure-does-fly-ed4518792679" target="_blank" rel="noopener">Just Enough Bitcoin for Ethereum</a>。</p><h3 id="以太坊客户端，智能合约语言"><a href="#以太坊客户端，智能合约语言" class="headerlink" title="以太坊客户端，智能合约语言"></a>以太坊客户端，智能合约语言</h3><p>编写和部署智能合约并不要求你运行一个以太坊节点。下面有列出<a href="#browser_ides">基于浏览器的IDE和API</a>。但如果是为了学习的话，还是应该运行一个以太坊节点，以便理解其中的基本组件，何况运行节点也不难。</p><h4 id="运行以太坊节点可用的客户端"><a href="#运行以太坊节点可用的客户端" class="headerlink" title="运行以太坊节点可用的客户端"></a>运行以太坊节点可用的客户端</h4><p>以太坊有许多不同语言的客户端实现（即多种与以太坊网络交互的方法），包括C++, Go, Python, Java, Haskell等等。为什么需要这么多实现？不同的实现能满足不同的需求（例如Haskell实现的目标是可以被数学验证），能使以太坊更加安全，能丰富整个生态系统。</p><p>在写作本文时，我使用的是Go语言实现的客户端geth (<a href="http://ethereum.github.io/go-ethereum/" target="_blank" rel="noopener">go-ethereum</a>)，其他时候还会使用一个叫testrpc的工具, 它使用了Python客户端<a href="https://github.com/ethereum/pyethereum" target="_blank" rel="noopener">pyethereum</a>。后面的例子会用到这些工具。</p><p>注: 我曾经使用过C++的客户端，现在仍然在用其中的ethminer组件和geth配合挖矿，因此这些不同的组件是可以一起工作的。<br>关于挖矿：挖矿很有趣，有点像精心照料你的室内盆栽，同时又是一种了解整个系统的方法。虽然以太币现在的价格可能连电费都补不齐，但以后谁知道呢。人们正在创造许多酷酷的DApp, 可能会让以太坊越来越流行。</p><p><strong>交互式控制台。</strong> 客户端运行起来后，你就可以同步区块链，建立钱包，收发以太币了。使用geth的一种方式是通过<a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console" target="_blank" rel="noopener">Javascript控制台</a>（JavaScript console, 类似你在chrome浏览器里面按F12出来的那个，只不过是跑在终端里）。此外还可以使用类似cURL的命令通过<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON RPC</a>来与客户端交互。本文的目标是带大家过一边DApp开发的流程，因此这块就不多说了。但是我们应该记住这些命令行工具是调试，配置节点，以及使用钱包的利器。</p><p><strong>在测试网络运行节点。</strong> 如果你在正式网络运行geth客户端，下载整个区块链与网络同步会需要相当时间。（你可以通过比较节点日志中打印的最后一个块号和<a href="http://stats.ethdev.com" target="_blank" rel="noopener">stats.ethdev.com</a>上列出的最新块来确定是否已经同步。) 另一个问题是在正式网络上跑智能合约需要实实在在的以太币。在测试网络上运行节点的话就没有这个问题。此时也不需要同步整个区块链，创建一个自己的私有链就勾了，对于开发来说更省时间。</p><p><strong>testrpc。</strong> 用geth可以创建一个测试网络，另一种更快的创建测试网络的方法是使用testrpc。Testrpc可以在启动时帮你创建一堆存有资金的测试账户。它的运行速度也更快因此更适合开发和测试。你可以从testrpc起步，然后随着合约慢慢成型，转移到geth创建的测试网络上 - 启动方法很简单，只需要指定一个networkid：<code>geth --networkid &quot;12345&quot;</code>。这里是<a href="https://github.com/ConsenSys/eth-testrpc" target="_blank" rel="noopener">testrpc的代码仓库</a>，下文我们还会再讲到它。</p><p>接下来我们来谈谈可用的编程语言，之后就可以开始真正的编程了。</p><h4 id="写智能合约用的编程语言"><a href="#写智能合约用的编程语言" class="headerlink" title="写智能合约用的编程语言"></a>写智能合约用的编程语言</h4><p><strong>用Solidity就好。</strong> 要写智能合约有好几种语言可选：有点类似Javascript的Solidity, 文件扩展名是<code>.sol</code>和Python接近的Serpent, 文件名以<code>.se</code>结尾。还有类似Lisp的LLL。Serpent曾经流行过一段时间，但现在最流行而且最稳定的要算是Solidity了，因此用Solidity就好。听说你喜欢Python? 用Solidity。</p><p><strong>solc编译器。</strong> 用Solidity写好智能合约之后，需要用solc来编译。它是一个来自C++客户端实现的组件（又一次，不同的实现产生互补），<a href="https://github.com/ethereum/webthree-umbrella/wiki" target="_blank" rel="noopener">这里</a>是安装方法。如果你不想安装solc也可以直接使用基于浏览器的编译器，例如<a href="https://chriseth.github.io/browser-solidity/" target="_blank" rel="noopener">Solidity real-time compiler</a>或者<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo</a>。后文有关编程的部分会假设你安装了solc。</p><p>注意：以太坊正处于积极的开发中，有时候新的版本之间会有不同步。确认你使用的是最新的dev版本，或者稳定版本。如果遇到问题可以去以太坊项目对应的Gitter聊天室或者<a href="http://forums.ethereum.org" target="_blank" rel="noopener">forums.ethereum.org</a>上问问其他人在用什么版本。</p><p><strong>web3.js API。</strong> 当Solidity合约编译好并且发送到网络上之后，你可以使用以太坊的<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API" target="_blank" rel="noopener">web3.js JavaScript API</a>来调用它，构建能与之交互的web应用。</p><p>以上就是在以太坊上编写智能合约和构建与之交互的DApp所需的基本工具。</p><h2 id="第二部分-DApp框架，工具以及工作流程"><a href="#第二部分-DApp框架，工具以及工作流程" class="headerlink" title="第二部分 DApp框架，工具以及工作流程"></a>第二部分 DApp框架，工具以及工作流程</h2><h3 id="DApp开发框架"><a href="#DApp开发框架" class="headerlink" title="DApp开发框架"></a>DApp开发框架</h3><p>虽然有上文提到的工具就可以进行开发了，但是使用社区大神们创造的框架会让开发更容易。</p><p><strong>Truffle and Embark。</strong> 是<a href="https://github.com/ConsenSys/truffle" target="_blank" rel="noopener">Truffle</a>把我领进了门。在Truffle出现之前的那个夏天，我目睹了一帮有天分的学生是如何不眠不休的参加一个hackathon（编程马拉松）活动的，虽然<a href="https://www.youtube.com/watch?v=TJBHTT88I8k" target="_blank" rel="noopener">结果相当不错</a>，但我还是吓到了。然后Truffle出现了，帮你处理掉大量无关紧要的小事情，让你可以迅速进入写代码-编译-部署-测试-打包DApp这个流程。另外一个相似的DApp构建与测试框架是<a href="https://iurimatias.github.io/embark-framework" target="_blank" rel="noopener">Embark</a>。我只用过Truffle, 但是两个阵营都拥有不少DApp大神。</p><p><strong>Meteor。</strong> 许多DApp开发者使用的另一套开发栈由web3.js和<a href="https://www.meteor.com/" target="_blank" rel="noopener">Meteor</a>组成，Meteor是一套通用webapp开发框架（<a href="https://github.com/ethereum/meteor-dapp-wallet" target="_blank" rel="noopener">ethereum-meteor-wallet</a>项目提供了一个很棒的入门实例，而<a href="https://github.com/SilentCicero" target="_blank" rel="noopener">SilentCiero</a>正在构建大量Meteor与web3.js和DApp集成的模板）。我下载并运行过一些不错的DApp是以这种方式构造的。在11月9日至13日的<a href="http://consensys.github.io/developers/articles/101-noob-intro/devcon.ethereum.org" target="_blank" rel="noopener">以太坊开发者大会ÐΞVCON1</a>上将有一些有趣的讨论，是关于使用这些工具构建DApp以及相关最佳实践的（会议将会在<a href="https://www.youtube.com/channel/UC6rYoXJ_3BbPyWx_GQDDRRQ" target="_blank" rel="noopener">YouTube</a>上直播）。</p><p><strong>APIs。</strong> <a href="http://blockapps.net/" target="_blank" rel="noopener">BlockApps.net</a>打算提供一套RESTful API给DApp使用以免去开发者运行本地节点的麻烦，这个中心化服务是基于以太坊Haskell实现的。这与DApp的去中心化模型背道而驰，但是在本地无法运行以太坊节点的场合非常有用，比如在你希望只有浏览器或者使用移动设备的用户也能使用你的DApp的时候。BlockApps提供了一个命令行工具<a href="https://github.com/blockapps/bloc" target="_blank" rel="noopener">bloc</a>，注册一个开发者帐号之后就可以使用。</p><p>许多人担心需要运行以太坊节点才能使用DApp的话会把用户吓跑，其实包括BlockApps在内的许多工具都能解决这个问题。<a href="https://metamask.io/" target="_blank" rel="noopener">Metamask</a>允许你在浏览器里面使用以太坊的功能而无需节点，以太坊官方提供的AlethZero或者AlethOne是正在开发中有易用界面的客户端，ConsenSys正在打造一个轻钱包<a href="https://github.com/ConsenSys/eth-lightwallet" target="_blank" rel="noopener">LightWallet</a>，这些工具都会让DApp的使用变得更容易。<a href="https://github.com/ethereum/wiki/wiki/White-Paper#scalability" target="_blank" rel="noopener">轻客户端</a>和水平分片(sharding)也在计划和开发之中。这是一个能进化出混合架构的P2P生态系统。</p><h3 id="智能合约集成开发环境-IDE"><a href="#智能合约集成开发环境-IDE" class="headerlink" title="智能合约集成开发环境 (IDE)"></a>智能合约集成开发环境 (IDE)</h3><p><strong>IDE。</strong> 以太坊官方出品了用来编写智能合约的<a href="https://github.com/ethereum/wiki/wiki/Mix:-The-DApp-IDE" target="_blank" rel="noopener">Mix IDE</a>，我还没用过但会尽快一试。</p><p><strong>基于浏览器的IDE。</strong> <a href="https://chriseth.github.io/browser-solidity" target="_blank" rel="noopener">Solidity real-time compiler</a>和<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo</a>都可以让你快速开始在浏览器中编写智能合约。你甚至可以让这些工具使用你的本地节点，只要让本地节点开一个端口（注意安全！这些工具站点必须可信，而且千万不要把你的全部身家放在这样一个本地节点里面！<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo UI</a>上有如何使用geth做到这一点的指引）。在你的智能合约调试通过之后，可以用开发框架来给它添加用户界面和打包成DApp，这正是Truffle的工作，后面的编程章节会有详细讲解。</p><p><a href="http://frontier.ether.camp/" target="_blank" rel="noopener">Ether.Camp</a>正在开发另一个强大的企业级浏览器IDE。他们的IDE将支持沙盒测试网络，自动生成用于测试的用户界面（取代后文将展示的手动编写测试），以及一个测试交易浏览器<a href="http://test.ether.camp/" target="_blank" rel="noopener">test.ether.camp</a>。当你的合约准备正式上线之前，使用他们的测试网络会是确保你的智能合约在一个接近真实的环境工作正常的好方法。他们也为正式网络提供了一个交易浏览器<a href="http://frontier.ether.camp/" target="_blank" rel="noopener">frontier.ether.camp</a>，上面可以看到每一笔交易的细节。在本文写作时Ether.Camp的IDE还只能通过邀请注册，预计很快会正式发布。</p><p><strong>合约和Dapp示例。</strong> 在Github上搜索DApp仓库和.sol文件可以看到进行中的有趣东西。这里有一个DApp大列表：<a href="http://dapps.ethercasts.com/" target="_blank" rel="noopener">dapps.ethercasts.com</a>，不过其中一些项目已经过时。<a href="http://ether.fund/contracts" target="_blank" rel="noopener">Ether.fund/contracts</a>上有一些Solidity和Serpent写的合约示例，但是不清楚这些例子有没有经过测试或者正确性验证。11月12日的<a href="https://devcon.ethereum.org/" target="_blank" rel="noopener">开发者大会ÐΞVCON1</a>将会有一整天的DApp主题演讲。</p><h3 id="部署智能合约的流程"><a href="#部署智能合约的流程" class="headerlink" title="部署智能合约的流程"></a>部署智能合约的流程</h3><p>流程如下：</p><ol><li>启动一个<strong>以太坊节点</strong> (例如geth或者testrpc)。</li><li>使用solc <strong>编译</strong> 智能合约。 =&gt; 获得二进制代码。</li><li>将编译好的合约<strong>部署</strong>到网络。（这一步会消耗以太币，还需要使用你的节点的默认地址或者指定地址来给合约签名。） =&gt; 获得合约的区块链地址和ABI（合约接口的JSON表示，包括变量，事件和可以调用的方法）。(译注：作者在这里把ABI与合约接口弄混了。ABI是合约接口的二进制表示。)</li><li>用web3.js提供的JavaScript API来<strong>调用</strong>合约。（根据调用的类型有可能会消耗以太币。）</li></ol><p>下图详细描绘了这个流程：</p><p><img src="https://ethfans.org/uploads/photo/2015/1fc96327c8a1d60c8dc16f8ec1a2fe5d.png" alt="这里写图片描述"></p><p>你的DApp可以给用户提供一个界面先部署所需合约再使用之（如图1到4步），也可以假设合约已经部署了（常见方法），直接从使用合约（如图第6步）的界面开始。</p><h2 id="第三部分-编程"><a href="#第三部分-编程" class="headerlink" title="第三部分 编程"></a>第三部分 编程</h2><h3 id="在Truffle中进行测试"><a href="#在Truffle中进行测试" class="headerlink" title="在Truffle中进行测试"></a>在Truffle中进行测试</h3><p><a href="https://github.com/consensys/truffle" target="_blank" rel="noopener">Truffle</a>用来做智能合约的测试驱动开发(TDD)非常棒，我强烈推荐你在学习中使用它。它也是学习使用JavaScript Promise的一个好途径，例如deferred和异步调用。Promise机制有点像是说“做这件事，如果结果是这样，做甲，如果结果是那样，做乙… 与此同时不要在那儿干等着结果返回，行不？”。Truffle使用了包装web3.js的一个JS Promise框架<a href="https://github.com/ConsenSys/ether-pudding" target="_blank" rel="noopener">Pudding</a>（因此它为为你安装web3.js）。(译注：Promise是流行于JavaScript社区中的一种异步调用模式。它很好的封装了异步调用，使其能够灵活组合，而不会陷入callback hell.)</p><p><strong>Transaction times。</strong> Promise对于DApp非常有用，因为交易写入以太坊区块链需要大约12-15秒的时间。即使在测试网络上看起来没有那么慢，在正式网络上却可能会要更长的时间（例如你的交易可能用光了Gas，或者被写入了一个孤儿块）。</p><p>下面让我们给一个简单的智能合约写测试用例吧。</p><h3 id="使用Truffle"><a href="#使用Truffle" class="headerlink" title="使用Truffle"></a>使用Truffle</h3><p>首先确保你 1.安装好了<a href="https://github.com/ethereum/webthree-umbrella/wiki" target="_blank" rel="noopener">solc</a>以及 2.<a href="https://github.com/ConsenSys/eth-testrpc" target="_blank" rel="noopener">testrpc</a>。（testrpc需要<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python</a>和<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip</a>。如果你是Python新手，你可能需要用<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" target="_blank" rel="noopener">virtualenv</a>来安装，这可以将Python程序库安装在一个独立的环境中。）</p><p>PS：在windows安装这个非常麻烦，要有<code>mingw</code>环境（在windows上模拟linux的环境），要安装<code>python</code>和<code>pip</code>，然后还会报告pkg-config的错误，参考<a href="https://stackoverflow.com/questions/1710922/how-to-install-pkg-config-in-windows" target="_blank" rel="noopener">这里</a>的帖子，最后还是存在问题。后来在<a href="https://github.com/trufflesuite/ganache-cli/wiki/Installing-TestRPC-on-Windows" target="_blank" rel="noopener">这里</a>找到一个js的版本，终于解决。</p><p>接下来安装 3.<a href="https://github.com/ConsenSys/truffle" target="_blank" rel="noopener">Truffle</a>（你可以使用<a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" rel="noopener">NodeJS’s npm</a>来安装：<code>npm install -g truffle</code>, <code>-g</code>开关可能会需要sudo）。安装好之后，在命令行中输入<code>truffle list</code>来验证安装成功。然后创建一个新的项目目录（我把它命名为’conference’），进入这个目录，运行<code>truffle init</code>。该命令会建立如下的目录结构：</p><p><img src="https://ethfans.org/uploads/photo/2015/57b9fb67369c190fa455766ab5f6556f.png" alt="这里写图片描述"></p><p>现在让我们在<strong>另一个终端</strong>里通过执行<code>testrpc</code>来启动一个节点（你也可以用geth）：</p><p><img src="https://ethfans.org/uploads/photo/2015/a7d19ebfb8d027b65384c532770b3ba8.png" alt="这里写图片描述"></p><p>回到之前的终端中，输入<code>truffle deploy</code>。这条命令会部署之前<code>truffle init</code>产生的模板合约到网络上。任何你可能遇到的错误信息都会在testrpc的终端或者执行truffle的终端中输出。</p><p>在开发过程中你随时可以使用<code>truffle compile</code>命令来确认你的合约可以正常编译（或者使用<code>solc YourContract.sol</code>），<code>truffle deploy</code>来编译和部署合约，最后是<code>truffle test</code>来运行智能合约的测试用例。</p><p>PS：运行之后，是什么样呢？怎么查看呢？我的终端上显示如下，这个说明什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">net_version</span><br><span class="line">eth_accounts</span><br><span class="line">net_version</span><br><span class="line">eth_accounts</span><br><span class="line">eth_accounts</span><br><span class="line">eth_accounts</span><br><span class="line">net_version</span><br><span class="line">net_version</span><br><span class="line">eth_sendTransaction</span><br><span class="line"></span><br><span class="line">  Transaction: 0x86d59c95d54482646fb1cca5b81a72123f833cb35168b2de9249921845643c20</span><br><span class="line">  Contract created: 0x4b46552283603e7f90da3d41c33b7b19d68bf248</span><br><span class="line">  Gas usage: 277462</span><br><span class="line">  Block Number: 1</span><br><span class="line">  Block Time: Fri Aug 10 2018 10:56:31 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">eth_newBlockFilter</span><br><span class="line">eth_getFilterChanges</span><br><span class="line">eth_getTransactionReceipt</span><br><span class="line">eth_getCode</span><br><span class="line">eth_uninstallFilter</span><br><span class="line">eth_sendTransaction</span><br><span class="line"></span><br><span class="line">  Transaction: 0x66d6279e0d0bb0798395af14a7092c9d6ce35ceb243ec57d7ce0cc9c18f6b31e</span><br><span class="line">  Gas usage: 42008</span><br><span class="line">  Block Number: 2</span><br><span class="line">  Block Time: Fri Aug 10 2018 10:56:32 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">eth_getTransactionReceipt</span><br></pre></td></tr></table></figure><p>PS：关于<code>truffle</code>的内容有些过时，需要重新整理一篇文章。</p><h3 id="第一个合约"><a href="#第一个合约" class="headerlink" title="第一个合约"></a>第一个合约</h3><p>下面是一个针对会议的智能合约，通过它参会者可以买票，组织者可以设置参会人数上限，以及退款策略。本文涉及的所有代码都可以在这个<a href="https://github.com/eshon/conference" target="_blank" rel="noopener">代码仓库</a>找到。</p><pre><code>contract Conference {  address public organizer;  mapping (address =&gt; uint) public registrantsPaid;  uint public numRegistrants;  uint public quota;  event Deposit(address _from, uint _amount);  // so you can log these events  event Refund(address _to, uint _amount);   function Conference() { // Constructor    organizer = msg.sender;    quota = 500;    numRegistrants = 0;  }  function buyTicket() public returns (bool success) {    if (numRegistrants &gt;= quota) { return false; }    registrantsPaid[msg.sender] = msg.value;    numRegistrants++;    Deposit(msg.sender, msg.value);    return true;  }  function changeQuota(uint newquota) public {    if (msg.sender != organizer) { return; }    quota = newquota;  }  function refundTicket(address recipient, uint amount) public {    if (msg.sender != organizer) { return; }    if (registrantsPaid[recipient] == amount) {       address myAddress = this;      if (myAddress.balance &gt;= amount) {         recipient.send(amount);        registrantsPaid[recipient] = 0;        numRegistrants--;        Refund(recipient, amount);      }    }  }  function destroy() { // so funds not locked in contract forever    if (msg.sender == organizer) {       suicide(organizer); // send funds to organizer    }  }}</code></pre><p>接下来让我们部署这个合约。（注意：本文写作时我使用的是Mac OS X 10.10.5, solc 0.1.3+ (通过brew安装)，Truffle v0.2.3, testrpc v0.1.18 (使用venv)）</p><h3 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h3><p><img src="https://ethfans.org/uploads/photo/2015/93ece58476d59db60d3c60657d5baa2d.png" alt="这里写图片描述"></p><p>(译注：图中步骤翻译如下：）</p><p>使用truffle部署智能合约的步骤：<br>1. <code>truffle init</code> (在新目录中) =&gt; 创建truffle项目目录结构<br>2. 编写合约代码，保存到<code>contracts/YourContractName.sol</code>文件。<br>3. 把合约名字加到<code>config/app.json</code>的’contracts’部分。<br>4. 启动以太坊节点（例如在另一个终端里面运行<code>testrpc</code>）。<br>5. <code>truffle deploy</code>（在truffle项目目录中)</p><p><strong>添加一个智能合约。</strong> 在<code>truffle init</code>执行后或是一个现有的项目目录中，复制粘帖上面的会议合约到<code>contracts/Conference.sol</code>文件中。然后打开<code>config/app.json</code>文件，把’Conference’加入’deploy’数组中。</p><p><img src="https://ethfans.org/uploads/photo/2015/62922e726f12f928492d4a647951f72c.png" alt=""></p><p><strong>启动testrpc。</strong> 在另一个终端中启动<code>testrpc</code>。</p><p><strong>编译或部署。</strong> 执行<code>truffle compile</code>看一下合约是否能成功编译，或者直接<code>truffle deploy</code>一步完成编译和部署。这条命令会把部署好的合约的地址和ABI（应用接口）加入到配置文件中，这样之后的<code>truffle test</code>和<code>truffle build</code>步骤可以使用这些信息。</p><p><strong>出错了？</strong> 编译是否成功了？记住，错误信息即可能出现在testrpc终端也可能出现在truffle终端。</p><p><strong>重启节点后记得重新部署！</strong> 如果你停止了testrpc节点，下一次使用任何合约之前切记使用<code>truffle deploy</code>重新部署。testrpc在每一次重启之后都会回到完全空白的状态。</p><h3 id="合约代码解读"><a href="#合约代码解读" class="headerlink" title="合约代码解读"></a>合约代码解读</h3><p>让我们从智能合约头部的变量声明开始：</p><pre><code>address public organizer;mapping (address =&gt; uint) public registrantsPaid;uint public numRegistrants;uint public quota;</code></pre><p><strong>address。</strong> 地址类型。第一个变量是会议组织者的钱包地址。这个地址会在合约的构造函数<code>function Conference()</code>中被赋值。很多时候也称呼这种地址为’owner’（所有人）。</p><p><strong>uint。</strong> 无符号整型。区块链上的存储空间很紧张，保持数据尽可能的小。</p><p><strong>public。</strong> 这个关键字表明变量可以被合约之外的对象使用。<code>private</code>修饰符则表示变量只能被本合约(或者衍生合约)内的对象使用。如果你想要在测试中通过web3.js使用合约中的某个变量，记得把它声明为<code>public</code>。</p><p><strong>Mapping或数组。</strong>（译注：Mapping类似Hash, Directory等数据类型，不做翻译。）在Solidity加入数组类型之前，大家都使用类似<code>mapping (address =&gt; uint)</code>的Mapping类型。这个声明也可以写作<code>address registrantsPaid[]</code>，不过Mapping的存储占用更小(smaller footprint)。这个Mapping变量会用来保存参加者（用他们的钱包地址表示）的付款数量以便在退款时使用。</p><p><strong>关于地址。</strong> 你的客户端（比如testrpc或者geth）可以生成一个或多个账户/地址。testrpc启动时会显示10个可用地址：</p><p><img src="https://ethfans.org/uploads/photo/2015/26c59b073b0d405cd482e2690e47639a.png" alt=""></p><p>第一个地址, <code>accounts[0]</code>，是发起调用的默认地址，如果没有特别指定的话。</p><p><strong>组织者地址 vs 合约地址。</strong> 部署好的合约会在区块链上拥有自己的地址（与组织者拥有的是不同的地址）。在Solidity合约中可以使用<code>this</code>来访问这个合约地址，正如<code>refundTicket</code>函数所展示的：<code>address myAddress = this;</code></p><p><strong>Suicide, Solidity的好东西。</strong>（译注：<code>suicide</code>意为’自杀’，Solidity提供的关键字，不做翻译。）转给合约的资金会保存于合约（地址）中。最终这些资金通过<code>destroy</code>函数被释放给了构造函数中设置的组织者地址。这是通过<code>suicide(orgnizer);</code>这行代码实现的。没有这个，资金可能被永远锁定在合约之中（reddit上有些人就遇到过），因此如果你的合约会接受资金一定要记得在合约中使用这个方法！</p><p>如果想要模拟另一个用户或者对手方（例如你是卖家想要模拟一个买家），你可以使用可用地址数组中另外的地址。假设你要以另一个用户，<code>accounts[1]</code>, 的身份来买票，可以通过<code>from</code>参数设置：</p><pre><code>conference.buyTicket({ from: accounts[1], value: some_ticket_price_integer });</code></pre><p><strong>函数调用可以是交易。</strong> 改变合约状态（修改变量值，添加记录，等等）的函数调用本身也是转账交易，隐式的包含了发送人和交易价值。因此web3.js的函数调用可以通过指定<code>{ from: __, value: __ }</code>参数来发送以太币。在Solidity合约中，你可以通过<code>msg.sender</code>和<code>msg.value</code>来获取这些信息：</p><pre><code>function buyTicket() public {    ...    registrantsPaid[msg.sender] = msg.value;    ...}</code></pre><p><strong>事件(Event)。</strong> 可选的功能。合约中的<code>Deposit</code>（充值）和<code>Send</code>（发送）事件是会被记录在以太坊虚拟机日志中的数据。它们实际上没有任何作用，但是用事件(Event)把交易记录进日志是好的做法。</p><p>好了，现在让我们给这个智能合约写一个测试，来确保它能工作。</p><h3 id="写测试"><a href="#写测试" class="headerlink" title="写测试"></a>写测试</h3><p>把项目目录<code>test/</code>中的<code>example.js</code>文件重命名为<code>conference.js</code>，文件中所有的’Example’替换为’Conference’。</p><pre><code>contract(&apos;Conference&apos;, function(accounts) {  it(&quot;should assert true&quot;, function(done) {    var conference = Conference.at(Conference.deployed_address);    assert.isTrue(true);    done();   // stops tests at this point  });});</code></pre><p>在项目根目录下运行<code>truffle test</code>，你应该看到测试通过。在上面的测试中truffle通过<code>Conference.deployed_address</code>获得合约部署在区块链上的地址。</p><p>让我们写一个测试来初始化一个新的Conference，然后检查变量都正确赋值了。将<code>conference.js</code>中的测试代码替换为：</p><pre><code>contract(&apos;Conference&apos;, function(accounts) {  it(&quot;Initial conference settings should match&quot;, function(done) {    var conference = Conference.at(Conference.deployed_address);      // same as previous example up to here    Conference.new({ from: accounts[0]  })    .then(function(conference) {      conference.quota.call().then(          function(quota) {            assert.equal(quota, 500, &quot;Quota doesn&apos;t match!&quot;);           }).then( function() {            return conference.numRegistrants.call();          }).then( function(num) {            assert.equal(num, 0, &quot;Registrants should be zero!&quot;);            return conference.organizer.call();          }).then( function(organizer) {            assert.equal(organizer, accounts[0], &quot;Owner doesn&apos;t match!&quot;);            done();   // to stop these tests earlier, move this up        }).catch(done);      }).catch(done);    });  });</code></pre><p><strong>构造函数。</strong> <code>Conference.new({ from: accounts[0] })</code>通过调用合约构造函数创造了一个新的Conference实例。由于不指定<code>from</code>时会默认使用<code>accounts[0]</code>，它其实可以被省略掉：</p><pre><code>Conference.new({ from: accounts[0] }); // 和Conference.new()效果相同</code></pre><p><strong>Promise。</strong> 代码中的那些<code>then</code>和<code>return</code>就是Promise。它们的作用写成一个深深的嵌套调用链的话会是这样：</p><pre><code>conference.numRegistrants.call().then(  function(num) {    assert.equal(num, 0, &quot;Registrants should be zero!&quot;);    conference.organizer.call().then(     function(organizer) {        assert.equal(organizer, accounts[0], &quot;Owner doesn&apos;t match!&quot;);        }).then(          function(...))            }).then(              function(...))            // Because this would get hairy...</code></pre><p>Promise减少嵌套，使代码变得扁平，允许调用异步返回，并且简化了表达“成功时做这个”和“失败时做那个”的语法。Web3.js通过<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#using-callbacks" target="_blank" rel="noopener">回调函数</a>实现异步调用，因此你不需要等到交易完成就可以继续执行前端代码。Truffle借助了用Promise封装web3.js的一个框架，叫做<a href="https://github.com/ConsenSys/ether-pudding" target="_blank" rel="noopener">Pudding</a>，这个框架本身又是基于<a href="http://ricostacruz.com/cheatsheets/bluebird.html" target="_blank" rel="noopener">Bluebird</a>的，它支持Promise的高级特性。</p><p><strong>call。</strong> 我们使用<code>call</code>来检查变量的值，例如<code>conference.quota.call().then(...</code>，还可以通过传参数，例如<code>call(0)</code>, 来获取mapping在index 0处的元素。Solidity的文档说这是一种特殊的“消息调用”因为 1.不会为矿工记录和 2.不需要从钱包账户/地址发起（因此它没有被账户持有者私钥做签名）。另一方面，交易/事务(Transaction)会被矿工记录，必须来自于一个账户（也就是有签名），会被记录到区块链上。对合约中数据做的任何修改都是交易。仅仅是检查一个变量的值则不是。因此在读取变量时不要忘记加上<code>call()</code>！否则会发生奇怪的事情。（此外如果在读取变量是遇到问题别忘记检查它是否是<code>public</code>。）<code>call()</code>也能用于调用不是交易的函数。如果一个函数本来是交易，但你却用<code>call()</code>来调用，则不会在区块链上产生交易。</p><p><strong>断言。</strong> 标准JS测试中的断言（如果你不小心拼成了复数形式’asserts’，truffle会报错，让你一头雾水），<code>assert.equal</code>是最常用的，其他类型的断言可以在<a href="http://chaijs.com/api/assert/" target="_blank" rel="noopener">Chai的文档</a>中找到。</p><p>再一次运行<code>truffle test</code>确保一切工作正常。</p><h3 id="测试合约函数调用"><a href="#测试合约函数调用" class="headerlink" title="测试合约函数调用"></a>测试合约函数调用</h3><p>现在我们测试一下改变<code>quote</code>变量的函数能工作。在<code>tests/conference.js</code>文件的<code>contract(&#39;Conference&#39;, function(accounts) {...};)</code>的函数体中添加如下测试用例：</p><pre><code>it(&quot;Should update quota&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({from: accounts[0] }).then(    function(conference) {      conference.quota.call().then(         function(quota) {           assert.equal(quota, 500, &quot;Quota doesn&apos;t match!&quot;);         }).then( function() {           return conference.changeQuota(300);        }).then( function(result) {  // result here is a transaction hash          console.log(result);  // if you were to print this out it’d be long hex - the transaction hash          return conference.quota.call()        }).then( function(quota) {           assert.equal(quota, 300, &quot;New quota is not correct!&quot;);          done();        }).catch(done);    }).catch(done);});</code></pre><p>这里的新东西是调用<code>changeQuota</code>函数的那一行。<code>console.log</code>对于调试很有用，用它能在运行truffle的终端中输出信息。在关键点插入<code>console.log</code>可以查看执行到了哪一步。记得把Solidity合约中<code>changeQuota</code>函数被声明为<code>public</code>，否则你不能调用它：</p><pre><code>function changeQuota(uint newquota) public {  }</code></pre><h3 id="测试交易"><a href="#测试交易" class="headerlink" title="测试交易"></a>测试交易</h3><p>现在让我们调用一个需要发起人发送资金的函数。</p><p><strong>Wei。</strong> 以太币有很多种单位（这里有个很有用的<a href="http://ether.fund/tool/converter" target="_blank" rel="noopener">转换器</a>）,在合约中通常用的是Wei，最小的单位。Web3.js提供了在各单位与Wei之间互相转换的便利方法，形如<code>web3.toWei(.05, &#39;ether&#39;)</code>。JavaScript在处理很大的数字时有问题，因此web3.js使用了<a href="https://github.com/MikeMcl/bignumber.js/" target="_blank" rel="noopener">程序库BigNumber</a>，并建议在代码各处都以Wei做单位，直到要给用户看的时候（<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#a-note-on-big-numbers-in-web3js" target="_blank" rel="noopener">文档</a>。</p><p><strong>账户余额。</strong> Web3.js提供了许多提供方便的<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3-javascript-%C3%90app-api-reference" target="_blank" rel="noopener">方法</a>，其中另一个会在下面测试用到的是<code>web3.eth.getBalance(some_address)</code>。记住发送给合约的资金会由合约自己持有直到调用<code>suicide</code>。</p><p>在<code>contract(Conference, function(accounts) {...};)</code>的函数体中插入下面的测试用例。在高亮显示的方法中，测试用例让另一个用户(<code>accounts[1]</code>)以<code>ticketPrice</code>的价格买了一张门票。然后它检查合约的账户余额增加了<code>ticketPrice</code>，以及购票用户被加入了参会者列表。</p><p>这个测试中的<code>buyTicket</code>是一个交易函数：</p><pre><code>it(&quot;Should let you buy a ticket&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {      var ticketPrice = web3.toWei(.05, &apos;ether&apos;);      var initialBalance = web3.eth.getBalance(conference.address).toNumber();      conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(        function() {          var newBalance = web3.eth.getBalance(conference.address).toNumber();          var difference = newBalance - initialBalance;          assert.equal(difference, ticketPrice, &quot;Difference should be what was sent&quot;);          return conference.numRegistrants.call();      }).then(function(num) {          assert.equal(num, 1, &quot;there should be 1 registrant&quot;);          return conference.registrantsPaid.call(accounts[1]);      }).then(function(amount) {          assert.equal(amount.toNumber(), ticketPrice, &quot;Sender&apos;s paid but is not listed&quot;);          done();      }).catch(done);  }).catch(done);});</code></pre><p><strong>交易需要签名。</strong> 和之前的函数调用不同，这个调用是一个会发送资金的交易，在这种情况下购票用户(<code>accounts[1]</code>)会用他的私钥对<code>buyTicket()</code>调用做签名。（在geth中用户需要在发送资金之前通过输入密码来批准这个交易或是解锁钱包的账户。）</p><p><strong>toNumber()。</strong> 有时我们需要把Solidity返回的十六进制结果转码。如果结果可能是个很大的数字可以用<code>web3.toBigNumber(numberOrHexString)</code>来处理因为JavaScript直接对付大数要糟。</p><h3 id="测试包含转账的合约"><a href="#测试包含转账的合约" class="headerlink" title="测试包含转账的合约"></a>测试包含转账的合约</h3><p>最后，为了完整性，我们确认一下<code>refundTicket</code>方法能正常工作，而且只有会议组织者能调用。下面是测试用例：</p><pre><code>it(&quot;Should issue a refund by owner only&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {      var ticketPrice = web3.toWei(.05, &apos;ether&apos;);      var initialBalance = web3.eth.getBalance(conference.address).toNumber();       conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(        function() {          var newBalance = web3.eth.getBalance(conference.address).toNumber();          var difference = newBalance - initialBalance;          assert.equal(difference, ticketPrice, &quot;Difference should be what was sent&quot;);  // same as before up to here          // Now try to issue refund as second user - should fail          return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[1]});          }).then(          function() {            var balance = web3.eth.getBalance(conference.address).toNumber();            assert.equal(web3.toBigNumber(balance), ticketPrice, &quot;Balance should be unchanged&quot;);            // Now try to issue refund as organizer/owner - should work            return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[0]});          }).then(          function() {            var postRefundBalance = web3.eth.getBalance(conference.address).toNumber();            assert.equal(postRefundBalance, initialBalance, &quot;Balance should be initial balance&quot;);            done();        }).catch(done);    }).catch(done); });</code></pre><p>这个测试用例覆盖的Solidity函数如下：</p><pre><code>function refundTicket(address recipient, uint amount) public returns (bool success) {  if (msg.sender != organizer) { return false; }  if (registrantsPaid[recipient] == amount) {     address myAddress = this;    if (myAddress.balance &gt;= amount) {       recipient.send(amount);      Refund(recipient, amount);      registrantsPaid[recipient] = 0;      numRegistrants--;      return true;    }  }  return false;}</code></pre><p><strong>合约中发送以太币。</strong> <code>address myAddress = this</code>展示了如何获取该会议合约实例的地址，以变接下来检查这个地址的余额（或者直接使用<code>this.balance</code>）。合约通过<code>recipient.send(amount)</code>方法把资金发回了购票人。</p><p><strong>交易无法返回结果给web3.js。</strong> 注意这一点！<code>refundTicket</code>函数会返回一个布尔值，但是这在测试中无法检查。因为这个方法是一个交易函数（会改变合约内数据或是发送以太币的调用），而web3.js得到的交易运行结果是一个交易哈希（如果打印出来是一个长长的十六进制/怪怪的字符串）。既然如此为什么还要让<code>refundTicket</code>返回一个值？因为在Solidity合约内可以读到这个返回值，例如当另一个合约调用<code>refundTicket()</code>的时候。也就是说Solidity合约可以读取交易运行的返回值，而web3.js不行。另一方面，在web3.js中你可以用事件机制（Event, 下文会解释）来监控交易运行，而合约不行。合约也无法通过<code>call()</code>来检查交易是否修改了合约内变量的值。</p><p><strong>关于sendTransaction()。</strong> 当你通过web3.js调用类似<code>buyTicket()</code>或者<code>refundTicket()</code>的交易函数时（使用<code>web3.eth.sendTransaction</code>），交易并不会立即执行。事实上交易会被提交到矿工网络中，交易代码直到其中一位矿工产生一个新区块把交易记录进区块链之后才执行。因此你必须等交易进入区块链并且同步回本地节点之后才能验证交易执行的结果。用testrpc的时候可能看上去是实时的，因为测试环境很快，但是正式网络会比较慢。</p><p><strong>事件/Event。</strong> 在web3.js中你应该监听<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">事件</a>而不是返回值。我们的智能合约示例定义了这些事件：</p><pre><code>event Deposit(address _from, uint _amount);event Refund(address _to, uint _amount);</code></pre><p>它们在<code>buyTicket()</code>和<code>refundTicket()</code>中被触发。触发时你可以在testrpc的输出中看到日志。要监听事件，你可以使用web.js监听器(listener)。在写本文时我还不能在truffle测试中记录事件，但是在应用中没问题：</p><pre><code>Conference.new({ from: accounts[0] }).then(  function(conference) {    var event = conference.allEvents().watch({}, &apos;&apos;); // or use conference.Deposit() or .Refund()    event.watch(function (error, result) {      if (error) {        console.log(&quot;Error: &quot; + error);      } else {        console.log(&quot;Event: &quot; + result.event);      }    });    // ...</code></pre><p><strong>过滤器/Filter。</strong> 监听所有事件可能会产生大量的轮询，作为替代可以使用过滤器。它们可以更灵活的开始或是停止对事件的监听。更多过滤器的信息可查看<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter" target="_blank" rel="noopener">Solidity文档</a>。</p><p>总的来说，使用事件和过滤器的组合比检查变量消耗的Gas更少，因而在验证正式网络的交易运行结果时非常有用。</p><p><strong>Gas。</strong> （译注：以太坊上的燃料，因为代码的执行必须消耗Gas。直译为汽油比较突兀，故保留原文做专有名词。）直到现在我们都没有涉及Gas的概念，因为在使用testrpc时通常不需要显式的设置。当你转向geth和正式网络时会需要。在交易函数调用中可以在<code>{from: __, value: __, gas: __}</code>对象内设置Gas参数。Web3.js提供了<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgasprice" target="_blank" rel="noopener"><code>web3.eth.gasPrice</code></a>调用来获取当前Gas的价格，Solidity编译器也提供了一个参数让你可以从命令行获取合约的Gas开销概要：<code>solc --gas YouContract.sol</code>。下面是<code>Conference.sol</code>的结果：</p><p><img src="https://ethfans.org/uploads/photo/2015/afa43126d926ed3db1915718900c69c7.png" alt=""></p><h3 id="为合约创建DApp界面"><a href="#为合约创建DApp界面" class="headerlink" title="为合约创建DApp界面"></a>为合约创建DApp界面</h3><p><em>下面的段落会假设你没有网页开发经验。</em></p><p>上面编写的测试用例用到的都是在前端界面中也可以用的方法。你可以把前端代码放到<code>app/</code>目录中，运行<code>truffle build</code>之后它们会和合约配置信息一起编译输出到<code>build/</code>目录。在开发时可以使用<code>truffle watch</code>命令在<code>app/</code>有任何变动时自动编译输出到<code>build/</code>目录。然后在浏览器中刷新页面即可看到<code>build/</code>目录中的最新内容。（<code>truffle serve</code>可以启动一个基于<code>build/</code>目录的网页服务器。）</p><p><code>app/</code>目录中有一些样板文件帮助你开始：</p><p><img src="https://ethfans.org/uploads/photo/2015/a6a8374e2ee98c702455fdfa93b5e117.png" alt=""></p><p><code>index.html</code>会加载<code>app.js</code>：</p><p><img src="https://ethfans.org/uploads/photo/2015/91153d00abd7361d997276e252a3ac75.png" alt=""></p><p>因此我们只需要添加代码到<code>app.js</code>就可以了。</p><p>默认的<code>app.js</code>会在浏览器的console(控制台)中输出一条”Hello from Truffle!”的日志。在项目根目录中运行<code>truffle watch</code>，然后在浏览器中打开<code>build/index.html</code>文件，再打开浏览器的console就可以看到。（大部分浏览器例如Chrome中，单击右键 -&gt; 选择Inspect Element然后切换到Console即可。）</p><p><img src="https://ethfans.org/uploads/photo/2015/18b1dd84faa4aa16a841f6fe7ab0093e.png" alt=""></p><p>在<code>app.js</code>中，添加一个在页面加载时会运行的<code>window.onload</code>调用。下面的代码会确认web3.js已经正常载入并显示所有可用的账户。（注意：你的testrpc节点应该保持运行。）</p><pre><code>window.onload = function() {  var accounts = web3.eth.accounts;  console.log(accounts);}</code></pre><p>看看你的浏览器console中看看是否打印出了一组账户地址。</p><p>现在你可以从<code>tests/conference.js</code>中复制一些代码过来（去掉只和测试有关的断言），将调用返回的结果输出到console中以确认代码能工作。下面是个例子：</p><pre><code>window.onload = function() {  var accounts = web3.eth.accounts;  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {    var ticketPrice = web3.toWei(.05, &apos;ether&apos;);    var initialBalance = web3.eth.getBalance(conference.address).toNumber();     console.log(&quot;The conference&apos;s initial balance is: &quot; + initialBalance);    conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(      function() {        var newBalance = web3.eth.getBalance(conference.address).toNumber();        console.log(&quot;After someone bought a ticket it&apos;s: &quot; + newBalance);        return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[0]});      }).then(        function() {            var balance = web3.eth.getBalance(conference.address).toNumber();          console.log(&quot;After a refund it&apos;s: &quot; + balance);      });  });};</code></pre><p>上面的代码应该输出如下：</p><p><img src="https://ethfans.org/uploads/photo/2015/f093c01e94c9d56b8f58202edb42a27e.png" alt=""></p><p>(console输出的warning信息可忽略。)</p><p>现在起你就可以使用你喜欢的任何前端工具，jQuery, ReactJS, Meteor, Ember, AngularJS，等等等等，在<code>app/</code>目录中构建可以与以太坊智能合约互动的DApp界面了！接下来我们给出一个极其简单基于jQuery的界面作为示例。</p><p><img src="https://ethfans.org/uploads/photo/2015/a85ed594ffaceef763fb249508d855eb.png" alt=""></p><p>这里是<a href="https://github.com/eshon/conference/blob/master/app/index.html" target="_blank" rel="noopener">index.html的代码</a>，这里是<a href="https://github.com/eshon/conference/blob/master/app/javascripts/app.js" target="_blank" rel="noopener">app.js的代码</a>。</p><p>通过界面测试了智能合约之后我意识到最好加入检查以保证相同的用户不能注册两次。另外由于现在是运行在testrpc节点上，速度很快，最好是切换到geth节点并确认交易过程依然能及时响应。否则的话界面上就应该显示提示信息并且在处理交易时禁用相关的按钮。</p><p><strong>尝试geth。</strong> 如果你使用<a href="https://github.com/ethereum/go-ethereum/" target="_blank" rel="noopener">geth</a>, 可以尝试以下面的命令启动 - 在我这儿(geth v1.2.3)工作的很好：</p><pre><code>build/bin/geth --rpc --rpcaddr=&quot;0.0.0.0&quot; --rpccorsdomain=&quot;*&quot; --mine --unlock=&apos;0 1&apos; --verbosity=5 --maxpeers=0 --minerthreads=&apos;4&apos;  --networkid &apos;12345&apos; --genesis test-genesis.json</code></pre><p>这条命令解锁了两个账户, <code>0</code>和<code>1</code>。1. 在geth控制台启动后你可能需要输入这两个账户的密码。2. 你需要在<a href="https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network#custom-networks" target="_blank" rel="noopener"><code>test-genesis.json</code></a>文件里面的’alloc’配置中加入你的这两个账户，并且给它们充足的资金。3. 最后，在创建合约实例时加上gas参数：</p><pre><code>Conference.new({from: accounts[0], gas: 3141592})</code></pre><p>然后把整个<code>truffle deploy</code>, <code>truffle build</code>流程重来一遍。</p><p><strong>教程中的代码。</strong> 在这篇基础教程中用到的所有代码都可以在这个<a href="https://github.com/eshon/conference" target="_blank" rel="noopener">代码仓库</a>中找到。</p><p><strong>自动为合约生成界面。</strong> <a href="https://github.com/SilentCicero" target="_blank" rel="noopener">SilentCicero</a>制作了一个叫做<a href="http://dapp-builder.meteor.com/" target="_blank" rel="noopener">DApp Builder</a>的工具，可以用Solidity合约自动生成HTML, jQuery和web.js的代码。这种模式也正在被越来越多的正在开发中的开发者工具采用。</p><p><strong>教程到此结束！</strong> 最后一章我们仅仅学习了一套工具集，主要是Truffle和testrpc. 要知道即使在ConsenSys内部，不同的开发者使用的工具和框架也不尽相同。你可能会发现更适合你的工具，这里所说的工具可能很快也会有改进。但是本文介绍的工作流程帮助我走上了DApp开发之路。</p><p>(⊙ω⊙) wonk wonk</p><p><em>感谢Joseph Chow的校阅和建议，Christian Lundkvist, Daniel Novy, Jim Berry, Peter Borah和Tim Coulter帮我修改文字和debug，以及Tim Coulter, Nchinda Nchinda和Mike Goldin对DApp前端步骤图提供的帮助。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链：教程 | 以太坊智能合约编程之菜鸟教程及学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/categories/Blockchain/"/>
    
    
      <category term="区块链" scheme="https://www.oxysun.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://www.oxysun.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="智能合约" scheme="https://www.oxysun.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="编程" scheme="https://www.oxysun.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git：Repository not found.</title>
    <link href="https://www.oxysun.cn/git/git-change-server-password.html"/>
    <id>https://www.oxysun.cn/git/git-change-server-password.html</id>
    <published>2018-08-09T01:35:00.000Z</published>
    <updated>2018-08-18T00:08:05.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-change-server-password.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>Git：服务端更换密码后，报告“remote: Repository not found.”。<br><a id="more"></a></p><p>昨天Github提醒我需要修改密码，所以我将Github的密码修改了，结果，回到家，在mac笔记本上<code>git pull</code>代码时报告<code>remote: Repository not found.</code>，在网上找了半天，都是在说<code>git</code>路径存在问题，这肯定不是我的问题，我的问题应该就是更换了密码，只不过<code>git</code> 报告了一个奇怪的错误，应该是需要修改本地原本保存的密码。</p><p>找到一个帖子说：</p><blockquote><p>分别打开下面2个文件,将[User]部分完全删除后保存,再使用Git命令的时候就会提示输入帐号密码了.<br>$ vi .git/config (工程当前路径的Git配置文件)</p><p>$ vi ~/.gitconfig (全局的Git配置文件)</p></blockquote><p>这里是删除掉了用户信息，不过，不管用。</p><p>继续寻找原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx$ git config -l</span><br><span class="line">credential.helper=osxkeychain</span><br></pre></td></tr></table></figure></p><p>这里有个变量<code>credential.helper</code>，凭证帮助者，怀疑是这里保存了密码，后面指向了电脑的<code>keychain</code>。</p><p>查看<a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">官网</a>解释：</p><blockquote><p>credential.helper<br>Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. Note that multiple helpers may be defined. See gitcredentials[7] for details.</p></blockquote><p>这里确认了，这里是外部的一个凭证助手，用来保存用户名和密码。</p><p>然后找到mac的<code>keychain</code>（钥匙串访问），果然发现了一条Github的条目，这里应该保存在原本的用户名和密码，把它删掉（这里也是可以直接修改密码的，只是第一次尝试的是删除），这个时候再<code>git pull</code>就出现了提示请输入用户名了，至此，问题解决，相关的疑问也搞明白了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-change-server-password.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;Git：服务端更换密码后，报告“remote: Repository not found.”。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="Repository not found" scheme="https://www.oxysun.cn/tags/Repository-not-found/"/>
    
  </entry>
  
  <entry>
    <title>区块链：以太坊的工作原理（转）--阅读笔记</title>
    <link href="https://www.oxysun.cn/blockchain/ethereum-rationale-introduction.html"/>
    <id>https://www.oxysun.cn/blockchain/ethereum-rationale-introduction.html</id>
    <published>2018-08-07T06:47:00.000Z</published>
    <updated>2018-08-18T00:08:05.863Z</updated>
    
    <content type="html"><![CDATA[<p>区块链：以太坊的工作原理–阅读笔记。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>找到一篇写的很好的对以太坊的介绍，6月21日阅读了一遍，并且进行了转帖，今天感觉还有很多内容没有读明白，开始第二遍研究，记录一些笔记。当然，会对原文中的一些有点问题的格式进行一下调整。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这篇文章主要讲解以太坊的基本原理，对技术感兴趣的朋友可以看看。</p><p>翻译作者: <a href="https://lilymoana.github.io/" target="_blank" rel="noopener">许莉</a><br>原文地址：<a href="https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369" target="_blank" rel="noopener">How does Ethereum work, anyway?</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>不管你们知不知道以太坊（Ethereum blockchain）是什么，但是你们大概都听说过以太坊。最近在新闻里出现过很多次，包括一些专业杂志的封面，但是如果你们对以太坊到底是什么没有一个基本的了解的话，看这些文章就会感觉跟看天书一样。 所以，什么是以太坊？本质上，就是一个保存数字交易永久记录的公共数据库。重要的是，这个数据库不需要任何中央权威机构来维持和保护它。相反的它以一个“无信任”的交易系统来运行—<strong>一个个体在不需要信任任何第三方或对方的情况下进行点对点交易的架构</strong>。（PS：加了标红，感觉这句话需要着重理解）</p><p>依然感到很困惑？这就是这篇文章存在的理由。我的目标是在技术层面来解释以太坊的工作原理，但是不会出现很复杂的数学问题或看起来很可怕的公式。即使你不是一个程序员，我希望你看完之后最起码对技术有个更好的认识。如果有些部分技术性太强不好理解，这是非常正常的，真的没有必要完全理解每一个小细节。我建议只要宏观的理解一下事物就行了。</p><p>这篇文章中的很多议点都是以太坊黄皮书中讨论过的概念的细分。我添加了我自己的解释和图表使理解以太坊更加简单一点。那些足够勇敢的人可以挑战一下技术，去阅读一下以太坊的黄皮书。</p><p>好了，让我们开始吧！</p><h2 id="区块链定义"><a href="#区块链定义" class="headerlink" title="区块链定义"></a>区块链定义</h2><p>区块链就是一个<strong>具有共享状态的密码性安全交易的单机(cryptographically secure transactional singleton machine with shared-state)</strong>。[1]这有点长，是吧？让我们将它分开来看：</p><ul><li><strong>“密码性安全(Cryptographically secure)”</strong>是指用一个很难被解开的复杂数学机制算法来保证数字货币生产的安全性。将它想象成类似于防火墙的这种。它们使得欺骗系统近乎是一个不可能的事情（比如：构造一笔假的交易，消除一笔交易等等）。</li><li><strong>“交易的单机(Transactional singleton machine)”</strong>是指只有一个权威的机器实例为系统中产生的交易负责任。换句话说，只有一个全球真相是大家所相信的。</li><li><strong>“具有共享状态(With shared-state)”</strong>是指在这台机器上存储的状态是共享的，对每个人都是开放的。</li></ul><p>以太坊实现了区块链的这个范例。</p><p>PS：这段概念说的有些绕，理解起来有点费劲。对这里面的<strong>singleton machine with shared-state</strong>不是太理解<strong>。</strong>同时发现了以太坊总是在强调一个概念，就是state。</p><h2 id="以太坊模型说明"><a href="#以太坊模型说明" class="headerlink" title="以太坊模型说明"></a>以太坊模型说明</h2><p>以太坊的本质就是一个<strong>基于交易的状态机(transaction-based state machine)</strong>。（PS：比特币不也是这样吗？）在计算机科学中，一个 状态机是指可以读取一系列的输入，然后根据这些输入，会转换成一个新的状态出来的东西。<br><img src="https://lilymoana.github.io/asset/eth_statemachine.png" alt=""></p><p>根据以太坊的状态机，我们从<strong>创世纪状态(genesis state)</strong>开始。这差不多类似于一片空白的石板，在网络中还没有任何交易的产生状态。当交易被执行后，这个创世纪状态就会转变成最终状态。在任何时刻，这个最终状态都代表着以太坊当前的状态。<br><img src="https://lilymoana.github.io/asset/eth_statetransition.png" alt=""></p><p>以太坊的状态有百万个交易。这些交易都被“组团”到一个区块中。一个区块包含了一系列的交易，每个区块都与它的前一个区块链接起来。<br><img src="https://lilymoana.github.io/asset/eth_chain.png" alt=""></p><p>为了让一个状态转换成下一个状态，交易必须是有效的。<strong>为了让一个交易被认为是有效的，它必须要经过一个验证过程，此过程也就是挖矿</strong>。挖矿就是一组节点（即电脑）用它们的计算资源来创建一个包含有效交易的区块出来。</p><p>任何在网络上宣称自己是矿工的节点都可以尝试创建和验证区块。世界各地的很多矿工都在同一时间创建和验证区块。每个矿工在提交一个区块到区块链上的时候都会提供一个数学机制的“证明”，这个证明就像一个保证：如果这个证明存在，那么这个区块一定是有效的。</p><p>为了让一个区块添加到主链上，一个矿工必须要比其他矿工更快的提供出这个“证明”。通过矿工提供的一个数学机制的“证明”来证实每个区块的过程称之为<strong>工作量证明(proof of work)</strong>。</p><p>证实了一个新区块的矿工都会被奖励一定价值的奖赏。奖赏是什么？以太坊使用一种内在数字代币—<strong>以太币(Ether)</strong>作为奖赏。每次矿工证明了一个新区块，那么就会产生一个新的以太币并被奖励给矿工。</p><p>你也许会在想：什么能确保每个人都只在区块的同一条链上呢？我们怎么能确定不会存在一部分矿工创建一个他们自己的链呢？</p><p>前面，我们定义了区块链就是一个<strong>具有共享状态的交易单机</strong>。使用这个定义，我们可以知道正确的当前状态是一个全球真相，所有人都必须要接受它。拥有多个状态（或多个链）会摧毁这个系统，因为它在哪个是正确状态的问题上不可能得到统一结果。如果链分叉了，你有可能在一条链上拥有10个币，一条链上拥有20个币，另一条链上拥有40个币。在这种场景下，是没有办法确定哪个链才是最”有效的“。</p><p>不论什么时候只要多个路径产生了，一个”分叉“就会出现。我们通常都想避免分叉，因为它们会破坏系统，强制人们去选择哪条链是他们相信的链。<br><img src="https://lilymoana.github.io/asset/eth_fork.png" alt=""></p><p>为了确定哪个路径才是最有效的以及防止多条链的产生，以太坊使用了一个叫做<strong>“GHOST协议(GHOST protocol)”</strong>的数学机制。</p><blockquote><p><strong>GHOST</strong> = <strong>Greedy Heaviest Observed Subtree</strong></p></blockquote><p>简单来说，GHOST协议就是让我们必须选择一个在其上完成计算最多的路径。一个方法确定路径就是使用最近一个区块（叶子区块）的区块号，区块号代表着当前路径上总的区块数（不包含创世纪区块）。区块号越大，路径就会越长，就说明越多的挖矿算力被消耗在此路径上以达到叶子区块。使用这种推理就可以允许我们赞同当前状态的权威版本。<br><img src="https://lilymoana.github.io/asset/eth_canonical.png" alt=""></p><p>PS：以上是总体的一个概念。</p><hr><p>现在你大概对区块链是什么有个理性的认识，让我们在再深入地了解一下以太坊系统主要组成部分：</p><ul><li>账户(accounts)</li><li>状态(state)</li><li>损耗和费用(gas and fees)</li><li>交易(transactions)</li><li>区块(blocks)</li><li>交易执行(transaction execution)</li><li>挖矿(mining)</li><li>工作量证明(proof of work)</li></ul><p>在开始之前需要注意的是：每当我说某某的Hash， 我指的都是<a href="https://ethereum.stackexchange.com/questions/550/which-cryptographic-hash-function-does-ethereum-use" target="_blank" rel="noopener">KECCAK-256</a> hash, 以太坊就是使用这个Hash算法。</p><h2 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h2><p>以太坊的全局“共享状态”是有很多小对象（账户）来组成的，这些账户可以通过消息传递来与对方进行交互。每个账户都有一个与之关联的<strong>状态(state)</strong>和一个20字节的<strong>地址(address)</strong>。在以太坊中一个地址是160位的标识符，用来识别账户。（PS：这个状态又是怎么呈现的呢？外部拥有账户是有一个余额的概念，那么合约账户呢？怎么呈现当前的状态呢？需要检索以前所有和这个合约发生过关系的交易？）</p><p>两种不同类型的账户：</p><ul><li>外部拥有的账户，被私钥控制且没有任何代码与之关联</li><li>合约账户，被它们的合约代码控制且有代码与之关联<br><img src="https://lilymoana.github.io/asset/eth_account.png" alt=""></li></ul><h3 id="外部拥有账户与合约账户的比较"><a href="#外部拥有账户与合约账户的比较" class="headerlink" title="外部拥有账户与合约账户的比较"></a>外部拥有账户与合约账户的比较</h3><p>理解外部拥有账户和合约账户的基本区别是很重要的。一个外部拥有账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部拥有账户或合约账户。在两个外部拥有账户之间传送的消息只是一个简单的价值转移。但是从外部拥有账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作。（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。</p><p>不像外部拥有账户，合约账户不可以自己发起一个交易。相反，合约账户只有在接收到一个交易之后(从一个外部拥有账户或另一个合约账户处)，为了响应此交易而触发一个交易。我们将会在“交易和消息”章节来了解关于合约与合约之间的通信。<br><img src="https://lilymoana.github.io/asset/eth_transationset.png" alt=""></p><p><strong>因此，在以太坊上任何的动作，总是被外部拥有账户触发的交易所发动的。</strong><br><img src="https://lilymoana.github.io/asset/eth_blockchain.png" alt=""></p><h3 id="账户状态"><a href="#账户状态" class="headerlink" title="账户状态"></a>账户状态</h3><p>账户状态有四个组成部分，不论账户类型是什么，都存在这四个组成部分：</p><ul><li>nonce：如果账户是一个外部拥有账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号</li><li>balance： 此地址拥有Wei的数量。1Ether=10^18Wei</li><li>storageRoot： Merkle Patricia树的根节点Hash值（我们后面在解释Merkle树）。Merkle树会将此账户存储内容的Hash值进行编码，默认是空值</li><li>codeHash：此账户EVM（以太坊虚拟机，后面细说）代码的hash值。对于合约账户，就是被Hash的代码并作为codeHash保存。对于外部拥有账户，codeHash域是一个空字符串的Hash值</li></ul><p>（PS：这个地方存在几个问题：</p><ol><li>storageRoot和codeHash存储的都是hash值，那么原本的内容被存在哪里？</li><li>合约代码会发生改变吗？代码里面的状态值是怎样体现改变的？</li><li>账户的唯一性是由nonce来确定的吗？）</li></ol><ul><li><img src="https://lilymoana.github.io/asset/eth_codehash.png" alt=""></li></ul><p>（PS：账户的信息又是怎么保存在区块链上呢？）</p><h3 id="世界状态"><a href="#世界状态" class="headerlink" title="世界状态"></a>世界状态</h3><p>好了，我们知道了以太坊的全局状态就是由账户地址和账户状态组成的一个映射。这个映射被保存在一个叫做Merkle Patricia树的数据结构中</p><p>Merkle Tree（也被叫做Merkle trie）是一种由一系列节点组成的二叉树，这些节点包括：</p><ul><li>在树底的大量叶子节点，这些叶子节点包含了源数据</li><li>一系列的中间节点，这些节点是两个子节点的Hash值</li><li>一个根节点，同样是两个子节点的Hash值，代表着整棵树</li><li><img src="https://lilymoana.github.io/asset/eth_merkletree.png" alt=""></li></ul><p>树底的数据是通过分开我们想要保存到<strong>chunks</strong>的数据产生的，然后将<strong>chunks</strong>分成<strong>buckets</strong>，再然后获取每个<strong>bucket</strong>的hash值并一直重复直到最后只剩下一个Hash：根Hash。</p><p>PS：这段话翻译得不好，原文是：</p><blockquote><p>The data at the bottom of the tree is generated by splitting the data that we want to store into <em>chunks</em>, then splitting the chunks into <em>buckets</em>, and then taking the hash of each bucket and repeating the same process until the total number of hashes remaining becomes only one: <strong>the root hash.</strong></p></blockquote><p>不是分开，是把我们想要保存的数据分隔开（splitting），保存到chunks上，然后再分隔chunks到bucket上。这是两个组织数据的单位。不过怎么体现在区块上呢？<br><img src="https://lilymoana.github.io/asset/eth_roothash.png" alt=""></p><p>这棵树要求存在里面的值（value）都有一个对应的key。从树的根节点开始，key会告诉你顺着哪个子节点可以获得对应的值，这个值存在叶子节点。在以太坊中，key/value是地址和与地址相关联的账户之间状态的映射，包括每个账户的balance, nonce, codeHash和storageRoot（storageRoot自己就是一颗树）。<br><img src="https://lilymoana.github.io/asset/eth_nonce.png" alt=""></p><p>（PS：到这里明白了，账户信息是保存在state树中的）</p><p>同样的树结构也用来存储交易和收据。更具体的说，每个块都有一个<strong>头(header)</strong>，头中保存了三个Merkle树结构的根节点Hash，三个Merkle树分别为：</p><ul><li>状态树</li><li>交易树</li><li>收据树<br><img src="https://lilymoana.github.io/asset/eth_blockheader.png" alt=""></li></ul><p>Merkle树中存储信息的高效性在以太坊的“轻客户端”和“轻节点”中相当的有用。记住区块链就是一群节点来维持的。广泛的说，有两种节点类型：全节点和轻节点。</p><p>全节点通过下载整条链来进行同步，从创世纪块到当前块，执行其中包含的所有交易。通常，矿工会存储全节点，因为他们在挖矿过程中需要全节点。也有可能下载一个全节点而不用执行所有的交易。无论如何，一个全节点包含了整个链。（PS：为什么要执行交易呢？交易的结果状态没有被记录吗？）</p><p>不过除非一个节点需要执行所有的交易或轻松访问历史数据，不然没必要保存整条链。这就是轻节点概念的来源。<strong>比起下载和存储整个链以及执行其中所有的交易，轻节点仅仅下载链的头，从创世纪块到当前块的头，不执行任何的交易或检索任何相关联的状态</strong>。由于轻节点可以访问区块头，而头中包含了3个Merkle树的根Hash值，所有轻节点依然可以很容易生成和接收关于交易、事件、余额等可验证的答案。</p><p>这个可以行的通是因为在Merkle树中Hash值是向上传播的—如果一个恶意用户试图用一个假交易来交换Merkle树底的交易，这个会改变它上面节点的Hash值，而它上面节点的值的改变也会导致上上一个节点Hash值的改变，以此类推，一直到树的根节点。<br><img src="https://lilymoana.github.io/asset/eth_hashchange.png" alt=""></p><p>任何节点想要验证一些数据都可以通过<strong>Merkle证明</strong>来进行验证，<strong>Merkle 证明</strong>的组成：</p><ul><li>一块需要验证的数据</li><li>树的根节点Hash值</li><li>一个“分支”（从 <strong>chunk</strong>到根这个路径上所有的Hash值）<br><img src="https://lilymoana.github.io/asset/eth_chunk.png" alt=""></li></ul><p>任何可以读取证明的人都可以验证分支的Hash值是连贯的，因此给出的块在树中实际的位置就是在此处。</p><p><strong>总之，使用Merkle Patricia树的好处就是该结构的根节点加密取决于存储在树中的数据，而且根节点的Hash值还可以作为该数据的安全标识。由于块的头包含了状态树、交易树、收据树的根Hash值，所以任何节点都可以验证以太坊的一小部分状态而不用保存整个状态，这整个状态的的大小可能是非常大的。</strong></p><h2 id="Gas和费用"><a href="#Gas和费用" class="headerlink" title="Gas和费用"></a>Gas和费用</h2><p>在以太坊中一个比较重要的概念就是<strong>费用(fees)</strong>，<strong>由以太坊网络上的交易而产生的每一次计算，都会产生费用—没有免费的午餐</strong>。这个费用是以”gas”来支付。</p><p>Gas就是用来衡量在一个具体计算中要求的费用单位。gas price就是你愿意在每个gas上花费Ether的数量，以“gwei”进行衡量。“Wei”是Ether的最小单位，1Ether=10^18Wei，1gwei=1,000,000,000 Wei。</p><p>对每个交易，发送者设置gas limit和gas price。gas limit和gas price就代表着发送者愿意为执行交易支付的Wei的最大值。</p><p>例如，假设发送者设置gas limit为50,000，gas price为20gwei。这就表示发送者愿意最多支付50,000 * 20gwei = 1,000,000,000,000,000 Wei = 0.001 Ether来执行此交易。<br><img src="https://lilymoana.github.io/asset/eth_price.png" alt=""></p><p>记住gas limit代表用户愿意花费在gas上费用的最大值。如果在他们的账户余额中有足够的Ether来支付这个最大值费用，那么就没问题。在交易结束时任何未使用的gas都会被返回给发送者，以原始费率兑换。<br><img src="https://lilymoana.github.io/asset/eth_gas.png" alt=""></p><p>在发送者没有提供足够的gas来执行交易，那么交易执行就会出现“gas不足”然后被认为是无效的。在这种情况下，交易处理就会被终止以及所有已改变的状态将会被恢复，最后我们就又回到了交易之前的状态—完完全全的之前状态就像这笔交易从来没有发生。因为机器在耗尽gas之前还是为计算做出了努力，<br>所以理论上，<strong>将不会有任何的gas被返回给发送者</strong>。<br><img src="https://lilymoana.github.io/asset/eth_refunder.png" alt=""></p><p>这些gas的钱到底去了哪里？<strong>发送者在gas上花费的所有费用都被发送到“受益人”的地址，通常情况下就是矿工的地址</strong>。因为矿工为了计算和验证交易做出了努力，所以矿工接收gas的费用作为奖励。<br><img src="https://lilymoana.github.io/asset/eth_reward.png" alt=""></p><p>通常，发送者愿意支付更高的gas price，矿工从这笔交易中就能获得更多的价值。因此，矿工也就更加愿意选择这笔交易。这样的话，矿工可以自由的选择自己愿意验证或忽略的交易。为了引导发送者设置合理的gas price，矿工可以选择建议一个最小的gas值，此值代表自己愿意执行交易的最低价格。</p><h2 id="存储也有费用"><a href="#存储也有费用" class="headerlink" title="存储也有费用"></a>存储也有费用</h2><p>Gas不仅仅是用来支付计算这一步的费用，而且也用来支付存储的费用。存储的总费用与所使用的32位字节的最小倍数成比例。</p><p>存储费用有一些比较细微的方面。比如，由于增加的存储增加了所有节点上的以太坊状态数据库的大小，所以激励保持数据存储量小。为了这个原因，如果一个交易的执行有一步是清除一个存储实体，那么为执行这个操作的费用就会被放弃，并且由于释放存储空间的退款就会被返回给发送者。</p><h2 id="费用的作用是什么？"><a href="#费用的作用是什么？" class="headerlink" title="费用的作用是什么？"></a>费用的作用是什么？</h2><p>以太坊可以运作的一个重要方面就是每个网络执行的操作同时也被全节点所影响。然而，计算的操作在以太坊虚拟机上是非常昂贵的。因此，以太坊智能合约最好是用来执行最简单的任务，比如运行一个简单的业务逻辑或者验证签名和其他密码对象，而不是用于复杂的操作，比如文件存储，电子邮件，或机器学习，这些会给网络造成压力。<strong>施加费用防止用户使网络超负荷</strong>。</p><p>以太坊是一个图灵完备语言（短而言之，图灵机器就是一个可以模拟任何电脑算法的机器。对于图灵机器不太熟悉的人可以看看<a href="https://en.wikipedia.org/wiki/Turing_machine" target="_blank" rel="noopener">这个</a>和<a href="http://mathworld.wolfram.com/TuringMachine.html" target="_blank" rel="noopener">这个</a>）。这就允许有循环，并使以太坊受到<a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" rel="noopener">停机问题</a>的影响，这个问题让你无法确定程序是否无限制的运行。如果没有费用的话，恶意的执行者通过执行一个包含无限循环的交易就可以很容易的让网络瘫痪而不会产生任何反响。因此，费用保护网络不受蓄意攻击。</p><p>你也许会想，“为什么我们还需要为存储付费？”其实就像计算一样，以太坊网络上的存储是整个网络都必须要负担的成本。</p><h2 id="交易和消息"><a href="#交易和消息" class="headerlink" title="交易和消息"></a>交易和消息</h2><p>之前说过以太坊是一个基于交易的状态机。换句话说，在两个不同账户之间发生的交易才让以太坊的全局状态从一个状态转换成另一个状态。</p><p><strong>最基本的概念，一个交易就是指被外部拥有账户生成的加密签名的一段指令，序列化之后提交给区块链。</strong></p><p>有两种类型的交易：<strong>消息通信(message calls)</strong>和<strong>合约创建(contract creations)(也就是交易产生一个新的以太坊合约)</strong>。</p><p>不管什么类型的交易，都包含：</p><ul><li>nonce：发送者发送交易数的计数</li><li>gasPrice：发送者愿意支付执行交易所需的每个gas的Wei数量</li><li>gasLimit：发送者愿意为执行交易支付gas数量的最大值。此值设置之后在任何计算完成之前就会被提前扣掉</li><li>to：接收者的地址。在合约创建交易中，合约账户的地址还没有存在，所以值先空着</li><li>value：从发送者转移到接收者Wei的数量。在合约创建交易中，value作为新建合约账户的开始余额</li><li>v,r,s：用于产生标识交易发送者的签名</li><li>init（只有在合约创建交易中存在）：用来初始化新合约账户的EVM代码片段。<strong>init</strong>值会执行一次，然后就会被丢弃。当<strong>init</strong>第一次执行的时候，它返回一个账户代码体，也就是永久与合约账户关联的一段代码。</li><li><p>data（可选域，只有在<strong>消息通信</strong>中存在）：消息通信中的输入数据(也就是参数)。例如，如果智能合约就是一个域名注册服务，那么调用合约可能就会期待输入参数：域名和IP地址</p><p><img src="https://lilymoana.github.io/asset/eth_transationmessage.png" alt=""></p></li></ul><p>在“账户”这个章节中我们学到交易—消息通信和合约创建交易两者都总是被外部拥有账户触发并提交到区块链的。换种思维思考就是，交易是外部世界和以太坊内部状态的桥梁。</p><p><img src="https://lilymoana.github.io/asset/eth_%20bridge.png" alt=""></p><p>但是这也并不代表一个合约与另一个合约无法通信。<strong>在以太坊状态全局范围内的合约可以与在相同范围内的合约进行通信。他们是通过“消息”或者“内部交易”进行通信的</strong>。（PS：没看懂）我们可以认为消息或内部交易类似于交易，不过与交易有着最大的不同点—它们不是由外部拥有账户产生的。相反，他们是被合约产生的。它们是虚拟对象，与交易不同，没有被序列化而且只存在于以太坊执行环境。</p><p><strong>当一个合约发送一个内部交易给另一个合约，存在于接收者合约账户相关联的代码就会被执行。</strong><br><img src="https://lilymoana.github.io/asset/eth_excuted.png" alt=""></p><p>一个需要注意的重要事情是内部交易或者消息不包含<strong>gasLimit</strong>。因为gas limit是由原始交易的外部创建者决定的（也就是外部拥有账户）。外部拥有账户设置的gas limit必须要高到足够将交易完成，包括由于此交易而产生的任何”子执行”，例如合约到合约的消息。如果，在一个交易或者信息链中，其中一个消息执行造成gas不足，那么这个消息的执行会被还原，包括任何被此执行触发的子消息。不过，父执行没必要被还原。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>所有的交易都被组成一个”块”。一个区块链包含了一系列这样链在一起的区块。</p><p>在以太坊中，一个区块包含：</p><ul><li><strong>区块头</strong></li><li>关于包含在此区块中<strong>交易集</strong>的信息</li><li>与当前块的ommers相关的一系列其他区块头</li></ul><h2 id="Ommers解释"><a href="#Ommers解释" class="headerlink" title="Ommers解释"></a>Ommers解释</h2><p>“ommer”到底是什么？ ommer就是一个区块的父区块与当前区块父区块的父区块是相同的。让我们快速了解一下ommers是用来干嘛的，并且为什么一个区块需要为ommers包含区块头。</p><p>由于以太坊的构造，它的区块生产时间（大概15秒左右）比其他的区块链例如Bitcoin（大概10分钟左右）要快很多。这使得交易的处理更快。但是，更短的区块生产时间的一个缺点就是：更多的竞争区块会被矿工发现。这些竞争区块同样也被称为“孤区块”（也就是被挖出来但是不会被添加到主链上的区块）。</p><p>Ommers的目的就是为了帮助奖励矿工纳入这些孤区块。矿工包含的ommers必须是有效的，也就是ommers必须是往上数6代之内或更小范围内父区块的子区块。 一个孤区块在第6个子区块之后，这种陈旧的孤区块将不会再被引用（因为包含老旧的交易会使事情变得复杂一点）。</p><p>Ommer区块会收到比全区块少一点的奖励。不管怎样，依然存在激励来让矿工们纳入孤区块并能从中获得一些报酬。</p><h3 id="区块头"><a href="#区块头" class="headerlink" title="区块头"></a>区块头</h3><p>让我们再回到区块的问题上。我们前面提到每个区块都有一个“区块头”，但这究竟是什么？</p><p>区块头是区块的一部分，包含了：</p><ul><li>parentHash：父区块头的Hash值（这也是使得区块变成区块链的原因）</li><li>ommerHash：当前区块ommers列表的Hash值</li><li>beneficiary：接收挖此区块费用的账户地址</li><li>stateRoot：状态树根节点的Hash值（回忆一下我们之前所说的保存在头中的状态树以及它使得轻客户端认证任何关于状态的事情都变得非常简单）</li><li>transactionsRoot：包含此区块所有交易的Merkle树的根节点Hash值</li><li>receiptsRoot：包含此区块所有交易收据的Merkle树的根节点Hash值</li><li>logsBloom：由日志信息组成的一个<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">Bloom过滤器</a> (一种数据结构)</li><li>difficulty： 此区块的难度级别</li><li>number：当前区块的计数（创世纪块的区块序号为0，对于每个后续区块，区块序号都增加1）</li><li>gasLimit：每个区块的当前gas limit</li><li>gasUsed： 此区块中交易所用的总gas量</li><li>timestamp：此区块成立时的unix的时间戳</li><li>extraData：与此区块相关的附加数据</li><li>mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计算</li><li>nonce：一个Hash值，当与mixHash组合时，证明此区块已经执行了足够的计算<br><img src="https://lilymoana.github.io/asset/eth_blockheaders.png" alt=""></li></ul><p>注意每个区块是如何包含三个树结构的，三个树结构分别对应：</p><ul><li>状态（stateRoot）</li><li>交易（transactionsRoot）</li><li>收据（receiptsRoot）<br>这三个树结构就是我们前面讨论的Merkle Patricia树。</li></ul><p>另外，上面描述的有几个术语值得说明一下，下面来看一下。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>以太坊允许日志可以跟踪各种交易和信息。一个合约可以通过定义“事件”来显示的生成日志。</p><p>一个日志的实体包含：</p><ul><li>记录器的账户地址</li><li>代表本次交易执行的各种事件的一系列主题以及与这些事件相关的任何数据</li></ul><p>日志被保存在<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">bloom过滤器</a>中，过滤器高效的保存了无尽的日志数据。（PS：这得保留多少？不是越来越大）</p><h2 id="交易收据"><a href="#交易收据" class="headerlink" title="交易收据"></a>交易收据</h2><p>包含着日志信息的交易收据的根Hash值保存在头中。 就像你在商店买东西时收到的收据一样，以太坊为每笔交易都产生一个收据。像你期望的那样，每个收据包含关于交易的特定信息，这些信息为：</p><ul><li>区块序号</li><li>区块Hash值</li><li>交易Hash值</li><li>当前交易使用了的gas</li><li>在当前交易执行完之后当前块使用的累计gas</li><li>执行当前交易时创建的日志</li><li>等等</li></ul><h2 id="区块难度"><a href="#区块难度" class="headerlink" title="区块难度"></a>区块难度</h2><p>区块的难度是被用来在验证区块时加强一致性。创世纪区块的难度是131,072，有一个特殊的公式用来计算之后的每个块的难度。如果某个区块比前一个区块验证的更快，以太坊协议就会增加区块的难度。</p><p>区块的难度影响<strong>nonce</strong>，它是在挖矿时必须要使用工作量证明算法计算出的一个Hash值。</p><p>区块<strong>难度</strong>和<strong>nonce</strong>之间的关系用数学形式表达就是：<br><img src="https://lilymoana.github.io/asset/eth_math.png" alt=""><br><strong>Hd</strong>代表的是难度。</p><p>找到符合难度阈值的<strong>nonce</strong>唯一方法就是使用工作量证明算法来列举所有的可能性。找到解决方案预期时间与难度成正比—难度越高，找到<strong>nonce</strong>就越困难，因此验证一个区块也就越难，这又相应地增加了验证新块所需的时间。<strong>所以，通过调整区块难度，协议可以调整验证区块所需的时间</strong>。</p><p>另一方面，如果验证时间变的越来越慢，协议就会降低难度。这样的话，验证时间自我调节以保持恒定的速率—平均每15s一个块。</p><h2 id="交易执行"><a href="#交易执行" class="headerlink" title="交易执行"></a>交易执行</h2><p>我们已经到了以太坊协议最复杂的部分：交易的执行。假设你发送了一笔交易给以太坊网络处理，将以太坊状态转换成包含你的交易这个过程到底发生了什么？<br><img src="https://lilymoana.github.io/asset/eth_transition.png" alt=""></p><p>首先，为了可以被执行所有的交易必须都要符合最基础的一系列要求，包括：</p><ul><li>交易必须是正确格式化的RLP。”RLP”代表Recursive Length Prefix，它是一种数据格式，用来编码二进制数据嵌套数组。以太坊就是使用RLP格式序列化对象。</li><li>有效的交易签名。</li><li>有效的交易序号。回忆一下账户中的nonce就是从此账户发送出去交易的计数。如果有效，那么交易序号一定等于发送账户中的nonce。</li><li>交易的gas limit 一定要等于或者大于交易使用的<strong>intrinsic gas</strong>，<strong>intrinsic gas</strong>包括：<br>1.执行交易预订费用为21,000gas<br>2.随交易发送的数据的gas费用（每字节数据或代码为0的费用为4gas，每个非零字节的数据或代码费用为68gas）<br>3.如果是合约创建交易，还需要额外的32,000gas<br><img src="https://lilymoana.github.io/asset/eth_%20intrinsicgas.png" alt=""></li><li>发送账户余额必须有足够的Ether来支付”前期”gas费用。前期gas费用的计算比较简单：首先，交易的gas limit乘以交易的gas价格得到最大的gas费用。然后，这个最大的gas费用加上从发送方传送给接收方的总值。<br><img src="https://lilymoana.github.io/asset/eth_upfront.png" alt=""></li></ul><p>如果交易符合上面的所有要求，那么我们进行下面的步骤。</p><p>第一步，我们从发送者的余额中扣除执行的前期费用，并为当前交易将发送者账户中的nonce增加1。此时，我们可以计算剩余的gas，将交易的总gas减去使用的<strong>intrinsic gas</strong>。<br><img src="https://lilymoana.github.io/asset/eth_gasremaining.png" alt=""></p><p>第二步，开始执行交易。在交易执行的整个过程中，以太坊保持跟踪“子状态”。子状态是记录在交易中生成的信息的一种方式，当交易完成时会立即需要这些信息。具体来说，它包含：</p><ul><li>自毁集：在交易完成之后会被丢弃的账户集（如果存在的话）</li><li>日志系列：虚拟机的代码执行的归档和可检索的检查点</li><li>退款余额：交易完成之后需要退还给发送账户的总额。回忆一下我们之前提到的以太坊中的存储需要付费，发送者要是清理了内存就会有退款。以太坊使用退款计数进行跟踪退款余额。退款计数从0开始并且每当合约删除了一些存储中的东西都会进行增加。</li></ul><p>第三步，交易所需的各种计算开始被处理。</p><p>当交易所需的步骤全部处理完成，并假设没有无效状态，通过确定退还给发送者的未使用的gas量，最终的状态也被确定。除了未使用的gas，发送者还会得到上面所说的“退款余额”中退还的一些津贴。</p><p>一旦发送者得到退款之后：</p><ul><li>gas的Ether就会给矿工</li><li>交易使用的gas会被添加到区块的gas计数中（计数一直记录当前区块中所有交易使用的gas总量，这对于验证区块时是非常有用的）</li><li>所有在<strong>自毁集</strong>中的账户（如果存在的话）都会被删除</li></ul><p>最后，我们就有了一个新的状态以及交易创建的一系列日志。</p><p>现在我们已经介绍了交易执行的基本知识，让我们再看看合约创建交易和消息通信的一些区别。</p><p>合约创建(Contract creation)</p><p>回忆一下在以太坊中，有两种账户类型：合约账户和外部拥有账户。当我们说一个交易是“合约创建”，是指交易的目的是创建一个新的合约账户。</p><p>为了创建一个新的合约账户，我们使用一个特殊的公式来声明新账户的地址。然后我们使用下面的方法来初始化一个账户：</p><ul><li>设置nonce为0</li><li>如果发送者通过交易发送了一定量的Ether作为<strong>value</strong>，那么设置账户的余额为<strong>value</strong></li><li>将存储设置为0</li><li>设置合约的<strong>codeHash</strong>为一个空字符串的Hash值</li></ul><p>一旦我们完成了账户的初始化，使用交易发送过来的<strong>init code</strong>（查看”交易和消息”章节来复习一下<strong>init code</strong>），实际上就创造了一个账户。<strong>init code</strong>的执行过程是各种各样的。取决于合约的构造器，可能是更新账户的存储，也可能是创建另一个合约账户，或者发起另一个消息通信等等。</p><p>当初始化合约的代码被执行之后，会使用gas。<strong>交易不允许使用的gas超过剩余gas。如果它使用的gas超过剩余gas，那么就会发生gas不足异常(OOG)并退出。如果一个交易由于gas不足异常而退出，那么状态会立刻恢复到交易前的一个点。发送者也不会获得在gas用完之前所花费的gas</strong>。</p><p>不过，如果发送者随着交易发送了Ether，即使合约创建失败Ether也会被退回来。</p><p>如果初始化代码成功的执行完成，最后合约创建的花费会被支付。这些是存储成本，与创建的合约代码大小成正比（再一次，没有免费的午餐）。如果没有足够的剩余gas来支付最后的花费，那么交易就会再次宣布gas不足异常并中断退出。</p><p>如果所有的都正常进行没有任何异常出现，那么任何剩余的未使用gas都会被退回给原始的交易发送者，现在改变的状态才被允许永久保存。</p><h3 id="消息通信-Message-calls"><a href="#消息通信-Message-calls" class="headerlink" title="消息通信(Message calls)"></a>消息通信(Message calls)</h3><p>消息通信的执行与合约创建比较类似，只不过有一点点区别。</p><p>由于没有新账户被创建，所以消息通信的执行不包含任何的<strong>init code</strong>。不过，它可以包含输入数据，如果交易发送者提供了此数据的话。一旦执行，消息通信同样会有一个额外的组件来包含输出数据，如果后续执行需要此数据的话组件就会被使用。</p><p>就像合约创建一样，如果消息通信执行退出是因为gas不足或交易无效（例如栈溢出，无效跳转目的地或无效指令），那么已使用的gas是不会被退回给原始触发者的。相反，所有剩余的未使用gas也会被消耗掉，并且状态会被立刻重置为余额转移之前的那个点。</p><p>没有任何方法停止或恢复交易的执行而不让系统消耗你提供的所有gas，直到最新的以太坊更新。例如，假设你编写了一个合约，当调用者没有授权来执行这些交易的时候抛出一个错误。在以太坊的前一个版本中，剩余的gas也会被消耗掉，并且没有任何gas退回给发送者。<strong>但是拜占庭更新包括了一个新的“恢复”代码，允许合约停止执行并且恢复改变的状态而不消耗剩余的gas，此代码还拥有返回交易失败原因的能力</strong>。如果一个交易是由于恢复而退出，那么未使用的gas就会被退回给发送者。</p><h3 id="执行模式"><a href="#执行模式" class="headerlink" title="执行模式"></a>执行模式</h3><p>到目前为止，我们了解了从开始到结束交易的执行必须经历的一系列步骤。现在，我们来看看交易究竟是如何在虚拟机(VM)中执行的。</p><p><strong>协议实际操作交易处理的部分是以太坊自己的虚拟机，称之为以太坊虚拟机(EVM)</strong>。</p><p>像之前定义的那样，EVM是图灵完备虚拟机器。EVM存在而典型图灵完备机器不存在的唯一限制就是EVM本质上是被gas束缚。因此，可以完成的计算总量本质上是被提供的gas总量限制的。<br><img src="https://lilymoana.github.io/asset/eth_evm.png" alt=""></p><p>此外，EVM具有基于堆栈的架构。<a href="https://en.wikipedia.org/wiki/Stack_machine" target="_blank" rel="noopener">堆栈机器</a>就是使用后进先出来保存临时值的计算机。</p><p>EVM中每个堆栈项的大小为256位，堆栈有一个最大的大小，为1024位。</p><p>EVM有内存，各项按照可寻址字节数组来存储。内存是易失性的，也就是数据是不持久的。</p><p>EVM也有一个存储器。不像内存，存储器是非易失性的，并作为系统状态的一部分进行维护。EVM分开保存程序代码，在虚拟<a href="https://en.wikipedia.org/wiki/Read-only_memory" target="_blank" rel="noopener">ROM</a> 中只能通过特殊指令来访问。这样的话，EVM就与典型的<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture" target="_blank" rel="noopener">冯·诺依曼架构</a>不同，此架构将程序的代码存储在内存或存储器中。<br><img src="https://lilymoana.github.io/asset/eth_evmstorage.png" alt=""></p><p>EVM同样有属于它自己的语言：“EVM字节码”，当一个程序员比如你或我写一个在以太坊上运行的智能合约时，我们通常都是用高级语言例如Solidity来编写代码。然后我们可以将它编译成EVM可以理解的EVM字节码。</p><p>好了现在来说执行。</p><p>在执行特定的计算之前，处理器会确定下面所说的信息是否有效和是否可获取：</p><ul><li>系统状态</li><li>用于计算的剩余gas</li><li>拥有执行代码的账户地址</li><li>原始触发此次执行的交易发送者的地址</li><li>触发代码执行的账户地址（可能与原始发送者不同）</li><li>触发此次执行的交易gas price</li><li>此次执行的输入数据</li><li><strong>Value</strong>(单位为Wei)作为当前执行的一部分传递给该账户</li><li>待执行的机器码</li><li>当前区块的区块头</li><li>当前消息通信或合约创建堆栈的深度</li></ul><p>执行刚开始时，内存和堆栈都是空的，程序计数器为0。</p><table><br><tbody><br><tr><br><td style="vertical-align:middle;"><br>    1<br></td><br><td style="vertical-align:middle;"><br>    PC: 0 STACK: [] MEM: [], STORAGE: {}<br></td><br></tr><br></tbody><br></table><p>然后EVM开始递归的执行交易，为每个循环计算<strong>系统状态</strong>和<strong>机器状态</strong>。系统状态也就是以太坊的全局状态(global state)。机器状态包含：</p><ul><li>可获取的gas</li><li>程序计数器</li><li>内存的内容</li><li>内存中字的活跃数</li><li>堆栈的内容</li></ul><p>堆栈中的项从系列的最左边被删除或者添加。</p><p>每个循环，剩余的gas都会被减少相应的量，程序计数器也会增加。<br>在每个循环的结束，都有三种可能性：</p><ul><li>机器到达异常状态（例如 gas不足，无效指令，堆栈项不足，堆栈项会溢出1024，无效的JUMP/JUMPI目的地等等）因此停止，并丢弃所有更改</li><li>进入后续处理下一个循环</li><li>机器到达了受控停止（到达执行过程的终点）</li></ul><p>假设执行没有遇到异常状态，达到一个“可控的”或正常的停止，机器就会产生一个合成状态，执行之后的剩余gas、产生的子状态、以及组合输出。</p><p>呼。我们终于过了一遍以太坊最难的部分了。如果你不能完全理解这个部分，也没关系。除非你在研究非常深层次的东西，否则你真的没有必要去理解交易执行的每个细节。</p><h2 id="一个块是如何完成的？"><a href="#一个块是如何完成的？" class="headerlink" title="一个块是如何完成的？"></a>一个块是如何完成的？</h2><p>最后，让我们看看一个包含许多交易的块是如何完成的。</p><p>当我们说“完成”，取决于此块是新的还是已存在的，可以指两个不同的事情。如果是个新块，就是指挖这个块所需的处理。如果是已存在的块，就是指验证此块的处理。不论哪种情况，一个块的“完成”都有4个要求：<br>1）验证（或者，如果是挖矿的话，就是确定）ommers<br>在区块头中的每个ommer都必须是有效的并且必须在当前块往上6代之内</p><p>2）验证（或者，如果是挖矿的话，就是确定）交易<br>区块中的<strong>gasUsed</strong>数量必须与区块中所列交易使用的累积gas量相等。（回忆一下，当执行一个交易的时候，我们会跟踪区块的gas计数器，也就跟踪了区块中所有交易使用的gas总数量）</p><p>3）申请奖励（只有挖矿时）<br>受益人的地址会因为挖矿而获得5Ether（在以太坊<a href="https://github.com/ethereum/EIPs/pull/669" target="_blank" rel="noopener">EIP-649</a> 提案中，5ETH很快将会被减少为3ETH）。另外，对于每个ommer，当前块的受益人会获得额外的1/32当前块奖励金的奖励。最近，每个ommer区块的受益人能够得到一定量的奖励（有个特殊公式可以进行计算）。</p><p>4）校验（或者，如果是挖矿的话，就是计算一个有效的）状态和nonce<br>确保所有的交易和改变的结果状态都被应用了，然后在区块奖励被应用于最终交易结果状态之后定义一个新块为状态。通过检查最终状态与存储在头中的状态树来进行验证。</p><h3 id="工作量证明挖矿"><a href="#工作量证明挖矿" class="headerlink" title="工作量证明挖矿"></a>工作量证明挖矿</h3><p>在“区块”这个章节简短的说明了一下区块难度这个概念。给予区块难度意义的算法叫做工作量证明（PoW）。</p><p>以太坊的工作量证明算法称之为<a href="https://github.com/ethereum/wiki/wiki/Ethash" target="_blank" rel="noopener">“Ethash”</a> （之前叫做Dagger-Hashimoto）。<br>算法正式定义为：<br><img src="https://lilymoana.github.io/asset/eth_algorithm.png" alt=""><br><strong>m</strong>代表的是<strong>mixHash</strong>，<strong>n</strong>代表的是<strong>nonce</strong>，<strong>Hn</strong>代表的是新区块的头（不包含需要计算的<strong>nonce</strong>和<strong>mixHash</strong>），<strong>Hn</strong>是区块头的nonce，<strong>d</strong>是<a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank" rel="noopener">DAG</a> ，就是一个大数据集。</p><p>在”区块”章节，我们讨论了存在于区块头中的多项。其中两项叫做<strong>mixHash</strong>和<strong>nonce</strong>。也许你会回忆起：</p><ul><li>mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计算</li><li>nonce：一个Hash值，当与mixHash组合时，证明此区块已经执行了足够的计算</li></ul><p>PoW函数就是用来估算这两项的。<br><strong>mixHash</strong>和<strong>nonce</strong>到底是如何使用PoW函数来计算出来的有点复杂，如果深入了解的话，我们可以另写一篇文章来讲解了。但是在一个高层面上，它大致就是这样计算的：<br>会为每个区块计算一个”种子”。每个“时期”的种子都不一样，每个时期是30,000个区块长度。对于第一时期，种子就是32位0的Hash值。对于后续的每个时期，种子就是前一个种子Hash值的Hash值。使用这个种子，节点可以计算出一个伪随机“缓存”。</p><p>这个缓存是非常有用的，因为它可以使“轻节点”的概念变成现实，轻节点概念在这篇文章的前面讨论过。轻节点的目的就是让某个节点有能力高效的校验交易而用不着存储整个区块链的数据集。一个轻节点可以仅基于缓存来校验一个交易的有效性，因为缓存可以重新生成需要校验的特定块。</p><p>使用这个缓存，节点可以生成DAG“数据集”，数据集中的每项取决于缓存中少量伪随机选择项。为了成为矿工，你需要要生成全数据集，所有全客户端和矿工都保存这个数据集，并且这个数据集随着时间线性增长。</p><p>然后矿工可以随机抽取数据集中的部分并将它们放入一个数学函数中Hash出一个”mixHash”。矿工会重复生成<strong>mixHash</strong>直到输出的值小于想要的目标值<strong>nonce</strong>。当输出的值符合这个条件的时候，nonce就被认为是有效的，然后区块就被添加到链中。</p><h3 id="挖矿作为安全机制"><a href="#挖矿作为安全机制" class="headerlink" title="挖矿作为安全机制"></a>挖矿作为安全机制</h3><p>总的来说，PoW的目的就是以加密安全的方式证明生成的一些输出（也就是<strong>nonce</strong>）是经过了一定量的计算的。<strong>因为除了列举所有的可能性，没有更好的其他方法来找到一个低于要求阈值的nonce</strong>。重复应用Hash函数的输出均匀分布，所以我们可以确保，在平均值上，<strong>找到满足要求的nonce所需时间取决于难度阈值</strong>。难度系数越大，所需时间越长。这样的话，<strong>PoW算法就给予难度这个概念意义了：用来加强区块链的安全</strong>。</p><p>我们所说的区块链的安全又是什么意思？这非常简单：我们想要创造一个每个人都信任的区块链。像我们之前在这篇文章中讨论的那样，如果存在超过1条以上的链，用户的信任就会消失，因为他们没有能力合理的确认哪条链才是“有效的”。为了让一群用户接受存储在区块链中的潜在状态，我们需要有一群人信任的一个权威区块链。</p><p><strong>这完完全全就是Pow算法所做的事情：它确保特定的区块链直到未来都一直保持着权威性，让攻击者创造一个新区块来重写某个历史部分（例如清除一个交易或者创建一个假的交易）或者保持一个分叉变得非常困难</strong>。为了首先让他们的区块被验证，攻击者需要总是比网络上的其他人更快的解决掉<strong>nonce</strong>问题，这样网络就会相信他们的链是最重的链（基于我们之前提到的GHOST协议原则）。除非攻击者拥有超过一半的网络挖矿能力（这种场景也被称为<a href="https://en.bitcoin.it/wiki/Majority_attack" target="_blank" rel="noopener">大多数51%攻击</a>），要不然这基本上是不可能的。<br><img src="https://lilymoana.github.io/asset/eth_attack.png" alt=""></p><h3 id="挖矿作为财富分配机制"><a href="#挖矿作为财富分配机制" class="headerlink" title="挖矿作为财富分配机制"></a>挖矿作为财富分配机制</h3><p>除了提供一个安全的区块链，PoW同样也是分配财富给那些为提供这个安全而花费自己计算力的人的一种方法。回忆一下，一个矿工挖出一个区块的时候会获得奖励，包括：</p><ul><li>为“获胜”区块提供的5 ether静态区块奖励（马上就会<a href="https://github.com/ethereum/EIPs/pull/669" target="_blank" rel="noopener">变成3 ether</a>）</li><li>区块中的交易在区块内所消耗的gas</li><li>纳入ommers作为区块的一部分的额外奖励</li></ul><p>为了保证PoW共识算法机制对安全和财富分配的使用是长期可持续的，以太坊努力灌输这两个特性：</p><ul><li>尽可能的让更多的人可访问。换句话说，人们不需要特殊的或者与众不同的硬件来运行这个算法。这样做的目的是为了让财富分配模式变的尽可能的开放，以便任何人都可以提供一些算力而获得Ether作为回报。</li><li>降低任何单个节点（或小组）能够创造与其不成比例的利润可能性。任何可以创造不成比例的利润的节点拥有比较大的影响力来决定权威区块链。这是件麻烦的事情，因为这降低了网络的安全性。</li></ul><p>在区块链网络中，与上面两个特性有关的一个问题是PoW算法是SHA256哈希函数。这种函数的缺点就是它使用特殊的硬件（也被称之为ASCIs）可以更加快速高效的解决<strong>nonce</strong>问题。</p><p>为了减轻这个问题，以太坊选择让PoW算法<a href="https://github.com/ethereum/wiki/wiki/Ethash" target="_blank" rel="noopener">(Ethhash)</a> 提高内存级别难度。意思是此算法被设计为计算出要求的<strong>nonce</strong>需要大量的内存和带宽。大量内存的需求让电脑平行的使用内存同时计算多个<strong>nonce</strong>变得极其困难，高带宽的需求让即使是超级电脑同时计算多个<strong>nonce</strong>也变得十分艰难。这种方式降低了中心化的风险，并为正在进行验证的节点提供了更加公平的竞争环境。</p><p>有一件值得注意的事情是以太坊正在从PoW共识机制渐渐转换为一个叫做“权益证明(PoS)”的共识算法。这就是一个比较野心的话题了，我们希望可以在未来的文章中探索这个话题。</p><h2 id="总结（PS：原文的总结）"><a href="#总结（PS：原文的总结）" class="headerlink" title="总结（PS：原文的总结）"></a>总结（PS：原文的总结）</h2><p>呼！ 你终于坚持到最后了。我希望如此？</p><p>这篇文章中有很多的地方需要消化。如果需要你阅读好几遍才能理解怎么回事，这完全正常。我个人重复阅读了好几次以太坊黄皮书，白皮书，以及代码的不同部分才渐渐明白是怎么回事。</p><p>无论如何，我希望你觉得这篇文章对你有帮助。如果你发现了任何的错误或失误，我很乐意你给我写个私人消息或者直接在评论区评论（我保证我会查看所有评论）。</p><p>记住，我是个人类（对，这是真的），我会犯错误。为了社区的利益，我花时间免费写了这篇文章。所以请你在反馈时不要带着没必要的攻击性，尽量是建设性的反馈。</p><p><a href="https://github.com/ethereum/yellowpaper" target="_blank" rel="noopener">以太坊的黄皮书</a></p><h1 id="总结（自己的总结）"><a href="#总结（自己的总结）" class="headerlink" title="总结（自己的总结）"></a>总结（自己的总结）</h1><p>第二遍读完，又多消化了一些内容，也总结了一些问题，列在下面：</p><ul><li>storageRoot和codeHash存储的都是hash值，那么原本的内容被存在哪里？</li><li>合约代码会发生改变吗？代码里面的状态值是怎样体现改变的？</li><li>账户的唯一性是由nonce来确定的吗？</li><li>账户的信息又是怎么保存在区块链上呢？</li><li>什么时候需要重新执行交易呢？交易的结果状态没有被记录吗？</li><li>日志是如何保留的？</li></ul><p>下一步，一个问题一个问题去研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链：以太坊的工作原理–阅读笔记。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/categories/Blockchain/"/>
    
    
      <category term="区块链" scheme="https://www.oxysun.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://www.oxysun.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-checkout的用法总结（2）</title>
    <link href="https://www.oxysun.cn/git/git-checkout-2.html"/>
    <id>https://www.oxysun.cn/git/git-checkout-2.html</id>
    <published>2018-08-04T01:00:00.000Z</published>
    <updated>2018-08-04T01:11:19.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-checkout-2.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>Git的git-checkout的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结合前一篇文章，再认真总结一下<code>git-checkout</code>的用法，因为可能一次总结到不了位，那么就不怕啰嗦，不怕重复，多总结几次，这样可能会造成每篇文章内容之间的分布不是那么清晰，将来再做更好的整理吧，因为现在这种方式，对于当前的学习是有帮助的，是从浅入深的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-checkout - Switch branches or restore working tree files</span><br></pre></td></tr></table></figure><p>从上面可见，git checkout是用来切换分支或者回复工作目录的，看到这里，记住这一点，会有很大帮助。（备注：我发现，有的时候，学习的节奏放慢一些，反而其实是更有效率的，反而是更快的。多思考一些，记的更准确，因慢得快）</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout [-q] [-f] [-m] [&lt;branch&gt;]</span><br><span class="line">git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;]</span><br><span class="line">git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt;</span><br><span class="line">git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]</span><br><span class="line">git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</span><br><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br><span class="line">git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</span><br></pre></td></tr></table></figure><h3 id="用法1"><a href="#用法1" class="headerlink" title="用法1"></a>用法1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>用来切换到一个分支上。切换<code>index</code>和工作目录，还有<code>HEAD</code> 指针到这个分支上。本地发生的修改也会被保留。如果本地不存在这个分支而远程存在同名分支的话，则这个命令相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;]</span><br></pre></td></tr></table></figure><p><code>-b</code>表示创建新分支；如果分支存在的话，不进行任何处理。<br><code>-B</code> 在创建新分支的功能和<code>-b</code> 是一样的；但是，如果分支存在的话，它会重置<code>&lt;start_point&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Specifying -b causes a new branch to be created as if git-branch[1] were called and then checked out. In this case you can use the --track or --no-track options, which will be passed to git branch. As a convenience, --track without -b implies branch creation; see the description of --track below.</span><br><span class="line"></span><br><span class="line">If -B is given, &lt;new_branch&gt; is created if it doesn’t exist; otherwise, it is reset. This is the transactional equivalent of</span><br><span class="line"></span><br><span class="line">$ git branch -f &lt;branch&gt; [&lt;start point&gt;]</span><br><span class="line">$ git checkout &lt;branch&gt;</span><br><span class="line">that is to say, the branch is not reset/created unless &quot;git checkout&quot; is successful.</span><br></pre></td></tr></table></figure><p>这里涉及到<code>track</code> 和<code>&lt;start point&gt;</code>的概念。<br><code>track</code>表示的是远程仓库与之对应的分支，这个信息被称为<code>upstream</code>，上游，远程仓库的，是上游。本地的，是下游，有一个对应的关系。<code>track</code> 本意是轨迹、跟踪的意思，使用了<code>--track</code>或者<code>--no-track</code> 来设置这个，这个信息会传递给<code>git branch</code>。</p><h3 id="用法2"><a href="#用法2" class="headerlink" title="用法2"></a>用法2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --detach [&lt;branch&gt;]</span><br><span class="line">git checkout [--detach] &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>切换代码到某一个提交号或者分支上，并且分离了<code>HEAD</code>指针，指向了这个提交。这块有点复杂，还需要理解深度理解一下，这个可能要留到下一篇帖子来完成了，争取每天整理一些（2018-08-03）。</p><p>整理完成，可以参考<a href="https://www.oxysun.cn/git/git-DETACHED-HEAD.html">这里</a>（2018-08-04）。</p><h3 id="用法3"><a href="#用法3" class="headerlink" title="用法3"></a>用法3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br><span class="line">git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…​]</span><br></pre></td></tr></table></figure><p>从<code>index</code>或者<code>&lt;tree-ish&gt;</code> 检出代码来替换<code>&lt;pathspec&gt;</code> 处的代码。如果<code>&lt;tree-ish&gt;</code> 被指定了，那么<code>index</code>和工作空间的代码都会被更新。</p><blockquote><p>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using -f will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using –ours or –theirs. With -m, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</p></blockquote><p><code>index</code>区域可能还有一些没有<code>merge</code>的条目，因为之前有失败的<code>merge</code>。</p><p>后一种用法使用互动的方式来完成这个功能。</p><p>到此，这个命令的用法基本整理完，下一步，要实践一些实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-checkout-2.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;Git的git-checkout的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="checkout" scheme="https://www.oxysun.cn/tags/checkout/"/>
    
  </entry>
  
  <entry>
    <title>Git：DETACHED HEAD的概念</title>
    <link href="https://www.oxysun.cn/git/git-DETACHED-HEAD.html"/>
    <id>https://www.oxysun.cn/git/git-DETACHED-HEAD.html</id>
    <published>2018-08-03T13:58:00.000Z</published>
    <updated>2018-08-03T14:01:51.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-DETACHED-HEAD.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>Git：DETACHED HEAD的概念。<br><a id="more"></a></p><p>原帖收藏于IT老兵驿站，传递一个IT老兵凋零前的光和氧。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<code>git</code>使用的时候，经常会碰到<code>DETACHED HEAD</code>，在此总结一下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>HEAD normally refers to a named branch (e.g. master). Meanwhile, each branch refers to a specific commit. Let’s look at a repo with three commits, one of them tagged, and with branch master checked out:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   HEAD (refers to branch &apos;master&apos;)</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">a---b---c  branch &apos;master&apos; (refers to commit &apos;c&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>上面是一个常见的例子，三个提交，<code>HEAD</code>指针指向<code>c</code>，往往是这个分支上最后的提交。然后又进行了一次修改和提交，生成了<code>d</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ edit; git add; git commit</span><br><span class="line"></span><br><span class="line">       HEAD (refers to branch &apos;master&apos;)</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>这个时候我们需要重新检出<code>v2.0</code>版本（这种可能性是很大，经常容易出现的），如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout v2.0  # or</span><br><span class="line">$ git checkout master^^</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   HEAD (refers to commit &apos;b&apos;)</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>这个时候<code>HEAD</code>指针就指向了<code>b</code>，这就是<code>detached HEAD</code>状态，这意味着<code>HEAD</code>指向了某一个提交了，而不再指向当前分支的最后一个提交了。</p><p>然后我们又进行了一次提交，就会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ edit; git add; git commit</span><br><span class="line"></span><br><span class="line">     HEAD (refers to commit &apos;e&apos;)</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">      e</span><br><span class="line">     /</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>one more time，再来一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ edit; git add; git commit</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> HEAD (refers to commit &apos;f&apos;)</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line">      e---f</span><br><span class="line">     /</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>我们可以做任何正常的<code>git</code>操作，如果你想回到<code>master</code>分支，那么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line">       HEAD (refers to branch &apos;master&apos;)</span><br><span class="line">      e---f     |</span><br><span class="line">     /          v</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>这个时候要意识到没有指针指向<code>f</code>提交，最后<code>e</code>和<code>f</code> 都会被常规的Git垃圾回收所删除掉，除非我们创建一个指针，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b foo   (1)</span><br><span class="line">$ git branch foo        (2)</span><br><span class="line">$ git tag foo           (3)</span><br></pre></td></tr></table></figure><ol><li>创建了一个新的分支指向<code>f</code>，并且更新了<code>HEAD</code>指针，这样<code>HEAD</code>指针就不再是<code>detached</code>状态了</li><li>简单创建了一个新的分支指向<code>f</code>，这个时候<code>HEAD</code>指针仍然是<code>detached</code>状态。<br>3.创建了一个新<code>tag</code>，指向<code>f</code>，这个时候<code>HEAD</code>指针仍然是<code>detached</code>状态。</li></ol><p>If we have moved away from commit f, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which HEAD referred, we can use either of these commands:</p><p>如果<code>f</code>已经被移除了，我们首先需要恢复它的对象名，使用<code>git reflog</code>，然后我们创建一个指针指向它。例如，想看到<code>HEAD</code>之前的最后两个提交，我们可以使用下面的命令（二选一）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog -2 HEAD # or</span><br><span class="line">$ git log -g -2 HEAD</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇总结基本上还是以翻译为主，留了一个问题，就是<code>reflog</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-DETACHED-HEAD.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;Git：DETACHED HEAD的概念。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="DETACHED HEAD" scheme="https://www.oxysun.cn/tags/DETACHED-HEAD/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-tag的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-tag.html"/>
    <id>https://www.oxysun.cn/git/git-tag.html</id>
    <published>2018-08-01T08:23:00.000Z</published>
    <updated>2018-08-03T14:00:27.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-tag.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>Git：git-tag的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git的tag和SVN不一样，SVN的tag其实还是一个分支，Git的tag则真的是一个标签，是给某一个commit打上一个标签，这个说明了Linus的巧妙设计，那么，对这个tag做一个笔记。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>记录几个主要的命令，用于速查：<br><strong>实例：</strong>列显已有的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>只看某一个tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l &apos;v1.4.2.*&apos;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>新建含附注的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &apos;my version 1.4&apos;</span><br></pre></td></tr></table></figure><p><code>-a</code>相当于给标签起个名字，<code>-m</code>是写一些注释。</p><p><strong>实例：</strong>查看相应标签的版本信息，并连同显示打标签时的提交对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>签署标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong>轻量级标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong>验证标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -v v1.4.2.1</span><br></pre></td></tr></table></figure></p><p>这个功能的具体意义还没有搞明白。</p><p><strong>实例：</strong>后期加注标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>推送某一标签到服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.5</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong>推送所有标签到服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-tag.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;Git：git-tag的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="git tag" scheme="https://www.oxysun.cn/tags/git-tag/"/>
    
      <category term="标签" scheme="https://www.oxysun.cn/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-reset的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-reset.html"/>
    <id>https://www.oxysun.cn/git/git-reset.html</id>
    <published>2018-07-31T09:23:00.000Z</published>
    <updated>2018-08-02T00:39:42.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-reset.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>Git：git-reset的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Git reset</code>感觉是相当复杂的一个指令，用了快一年了，总感觉还没有用明白，所以，需要好好总结一下。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</span><br><span class="line">git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</span><br><span class="line">git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>In the first and second form, copy entries from <tree-ish> to the index. In the third form, set the current branch head (HEAD) to <commit>, optionally modifying index and working tree to match. The <tree-ish>/<commit> defaults to HEAD in all forms.</commit></tree-ish></commit></tree-ish></p></blockquote><p>这个命令有三种用法，前两种用来从<code>&lt;tree-ish&gt;</code>所指定的地方拷贝条目到index（其实是说从仓库的某一个版本获取到<code>index</code>区域）。第三种格式，将当前分支的<code>HEAD</code>指针设定为<code>&lt;commit&gt;</code> 这个提交号，同时可以选择性地修改<code>index</code>和工作区域。</p><p><code>tree-ish</code>是什么意思呢？要参考<a href="https://stackoverflow.com/questions/4044368/what-does-tree-ish-mean-in-git" target="_blank" rel="noopener">这里</a>，是Git所使用的指明路径的语法。类似以下这样的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;rev&gt;:&lt;path&gt;, e.g. HEAD:README, :README, master:./README</span><br><span class="line"></span><br><span class="line">A suffix : followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon.</span><br></pre></td></tr></table></figure><p><strong>备注：</strong>但是感觉这里这个解释放在这里不是很准确，这里的<code>&lt;tree-ish&gt;</code> 似乎是指类似<code>HEAD</code>、<code>master~3</code>、<code>&lt;sha1&gt;</code> 而不包含冒号以及后面的部分。</p><h2 id="用法1"><a href="#用法1" class="headerlink" title="用法1"></a>用法1</h2><p><code>git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</code></p><blockquote><p>This form resets the index entries for all <paths> to their state at <tree-ish>. (It does not affect the working tree or the current branch.)</tree-ish></paths></p></blockquote><blockquote><p>This means that git reset <paths> is the opposite of git add <paths>.</paths></paths></p></blockquote><blockquote><p>After running git reset <paths> to update the index entry, you can use git-checkout[1] to check the contents out of the index to the working tree. Alternatively, using git-checkout[1] and specifying a commit, you can copy the contents of a path out of a commit to the index and to the working tree in one go.</paths></p></blockquote><p>这个用法将<code>index</code>区域所有符合<paths>的条目修改为<code>&lt;tree-ish&gt;</code> 的状态。（这并不影响工作目录或者当前分支。）<br>这个<code>reset</code>是更新<code>index</code>条目，更新后，可以从<code>index</code>中通过<code>checkout</code>指令获取内容到工作目录。如果<code>git checkout</code>指定了一个提交号，那么就可以根据这个提交号更新内容到<code>index</code>和工作目录。</paths></p><p>关于<code>ORIG_HEAD</code>的介绍：需要参考<a href="https://stackoverflow.com/questions/964876/head-and-orig-head-in-git" target="_blank" rel="noopener">这里</a>。</p><blockquote><p>HEAD is (direct or indirect, i.e. symbolic) reference to the current commit. It is a commit that you have checked in the working directory (unless you made some changes, or equivalent), and it is a commit on top of which “git commit” would make a new one. Usually HEAD is symbolic reference to some other named branch; this branch is currently checked out branch, or current branch. HEAD can also point directly to a commit; this state is called “detached HEAD”, and can be understood as being on unnamed, anonymous branch.</p></blockquote><blockquote><p>And @ alone is a shortcut for HEAD, since Git 1.8.5</p></blockquote><blockquote><p>ORIG_HEAD is previous state of HEAD, set by commands that have possibly dangerous behavior, to be easy to revert them. It is less useful now that Git has reflog: HEAD@{1} is roughly equivalent to ORIG_HEAD (HEAD@{1} is always last value of HEAD, ORIG_HEAD is last value of HEAD before dangerous operation).</p></blockquote><blockquote><p>For more information read git(1) manpage, Git User’s Manual, the Git Community Book and Git Glossary</p></blockquote><p><code>HEAD</code>是指当前分支上当前的提交号。<br><code>ORIG_HEAD</code> 是指上一个HEAD所指向的提交号。<br>这其实是两个指针，第二个指针的设计其实是为了做保护，一旦第一个指针被误操作了，还有机会去挽回。</p><p><strong>实例：</strong><br>将发生改变的文件 <code>_config.yml</code>加入<code>index</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add _config.yml</span><br></pre></td></tr></table></figure></p><p>这样<code>_config.yml</code> 文件就被加入到<code>index</code>区域中，显示成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   _config.yml</span><br></pre></td></tr></table></figure></p><p>撤销上面的操作，恢复<code>_config.yml</code>为版本库中的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset _config.yml</span><br></pre></td></tr></table></figure></p><p>这种用法相当于<code>&lt;tree-ish&gt;</code>的参数设置为<code>HEAD</code>。</p><h2 id="用法2"><a href="#用法2" class="headerlink" title="用法2"></a>用法2</h2><p><code>git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</code></p><blockquote><p>Interactively select hunks in the difference between the index and <tree-ish> (defaults to HEAD). The chosen hunks are applied in reverse to the index.</tree-ish></p></blockquote><blockquote><p>This means that git reset -p is the opposite of git add -p, i.e. you can use it to selectively reset hunks. See the “Interactive Mode” section of git-add[1] to learn how to operate the –patch mode.</p></blockquote><p>这个用法是以<code>patch</code> 的方式展示出来需要<code>reset</code>的代码， <code>git reset -p</code> 和<code>git add -p</code> 就是一对互为反向的操作，后者是把工作目录下变更的代码以<code>patch</code> 的方式展示出来，以互动的方式应用到<code>index</code>上，前者则是一个反向操作。</p><p><strong>实例：</strong><br>将发生改变的文件 <code>_config.yml</code>加入<code>index</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -p  _config.yml</span><br></pre></td></tr></table></figure></p><p>撤销上面的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset -p  _config.yml</span><br></pre></td></tr></table></figure></p><p>可以看到，这种用法相对上面那一种用法其实是增加了互动的提醒。</p><h2 id="用法3"><a href="#用法3" class="headerlink" title="用法3"></a>用法3</h2><p><code>git reset [&lt;mode&gt;] [&lt;commit&gt;]</code></p><p>This form resets the current branch head to <commit> and possibly updates the index (resetting it to the tree of <commit>) and the working tree depending on <mode>. If <mode> is omitted, defaults to “–mixed”. The <mode> must be one of the following:</mode></mode></mode></commit></commit></p><p>这个用法是用来设置当前的分支的<code>HEAD</code>指针，或者<code>index</code> 的指向当前版本的指针，或者工作空间指向当前版本的指针。</p><blockquote><p>–soft<br>Does not touch the index file or the working tree at all (but resets the head to <commit>, just like all modes do). This leaves all your changed files “Changes to be committed”, as git status would put it.</commit></p></blockquote><p><code>soft</code>参数用来设置<code>HEAD</code>指针。</p><blockquote><p>–mixed<br>Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.</p></blockquote><p><code>mixed</code>参数用来设置<code>index</code>指针，文件的修改仍然会被保留，但是没有纳入到<code>index</code>中。</p><blockquote><p>If -N is specified, removed paths are marked as intent-to-add (see git-add[1]).</p></blockquote><blockquote><p>–hard<br>Resets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded.</commit></p></blockquote><p><code>hard</code>重置<code>index</code>和工作区域，所有在这个<code>&lt;commit&gt;</code>之后的修改将被丢弃。</p><blockquote><p>–merge<br>Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted.</commit></commit></p></blockquote><blockquote><p>In other words, –merge does something like a git read-tree -u -m <commit>, but carries forward unmerged index entries.</commit></p></blockquote><p><code>merge</code>重置<code>index</code> ，并且更新那些工作区的文件（在<code>&lt;commit&gt;</code>和<code>HEAD</code>中不同的）。这个还需要进一步理解一下。</p><blockquote><p>–keep<br>Resets index entries and updates files in the working tree that are different between <commit> and HEAD. If a file that is different between <commit> and HEAD has local changes, reset is aborted.</commit></commit></p></blockquote><blockquote><p>If you want to undo a commit other than the latest on a branch, git-revert[1] is your friend.</p></blockquote><p><strong>实例</strong> 版本库中的提交如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">commit cac453cf6501c3ea3b626636bc4399ed48704543 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: xxx &lt;xxx@xxx.xxx&gt;</span><br><span class="line">Date:   Fri Jul 27 18:08:46 2018 +0800</span><br><span class="line"></span><br><span class="line">    从版本库中移除项目配置文件和日志配置文件</span><br><span class="line"></span><br><span class="line">commit cd36b7297106a871ae331f487179fd5584fb38cd</span><br><span class="line">Author: xxx &lt;xxx@xxx.xxx&gt;</span><br><span class="line">Date:   Fri Jul 27 18:06:37 2018 +0800</span><br><span class="line"></span><br><span class="line">    暂时参考原来的逻辑，使用硬编码的方式，新增了权限</span><br><span class="line"></span><br><span class="line">commit 24f19e80b5b8e2c05faf04706d95b5ac538ddbdd (f_1486)</span><br><span class="line">Author: xxx &lt;xxx@xxx.xxx&gt;</span><br><span class="line">Date:   Wed Jul 11 22:00:43 2018 +0800</span><br><span class="line"></span><br><span class="line">    修改了login的登录按钮的宽度</span><br><span class="line"></span><br><span class="line">commit e948bb044676ff917be862d9fae8391ba1b82351</span><br><span class="line">Author: xxx &lt;xxx@xxx.xxx&gt;</span><br><span class="line">Date:   Tue Jul 10 23:39:28 2018 +0800</span><br><span class="line"></span><br><span class="line">    完成初步的修改</span><br></pre></td></tr></table></figure></p><p>现在发现最后三次提交是存在问题的，不应该直接提交到<code>master</code>上，这个时候需要把<code>HEAD</code>指针恢复到倒数第四次提交上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft e948bb044676ff917be862d9fae8391ba1b82351</span><br></pre></td></tr></table></figure></p><p>这样后面三次提交的改变从版本库还原出来，变成尚未提交的状态，这样我们就可以新开一个临时的<code>dev</code>分支，继续我们之前的工作（参考Git Flow一篇文章）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-reset.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;Git：git-reset的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="git reset" scheme="https://www.oxysun.cn/tags/git-reset/"/>
    
  </entry>
  
  <entry>
    <title>区块链：比特币难度的概念</title>
    <link href="https://www.oxysun.cn/blockchain/bitcoin-difficulty.html"/>
    <id>https://www.oxysun.cn/blockchain/bitcoin-difficulty.html</id>
    <published>2018-07-30T08:46:00.000Z</published>
    <updated>2018-08-18T00:08:05.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/blockchain/bitcoin-difficulty.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>区块链：比特币难度的概念。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇笔记记录一下对于比特币难度的学习，参考<a href="https://en.bitcoin.it/wiki/Difficulty" target="_blank" rel="noopener">这里</a>，记录下来自己的理解，哩哩啦啦地写了两天，边看边查，还是没有理解到位，等待之后再补充吧。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>Difficulty is a measure of how difficult it is to find a hash below a given target.</p></blockquote><p><code>Difficulty</code> 是用来衡量找到一个低于给定目标的<code>hash</code>的困难程度。</p><h3 id="难度公式："><a href="#难度公式：" class="headerlink" title="难度公式："></a>难度公式：</h3><blockquote><p>difficulty = difficulty_1_target / current_target<br>(target is a 256 bit number)</p></blockquote><p>有许多不同测量难度的方法，得到的difficulty_1_target可能不同。传统地，它表示一个<code>HASH</code>值，前32位为0，后面都为1（也就是被称为“矿池难度”或“pdiff”的值），比特币协议把目标<code>HASH</code>表示成一个有限精度的自定义浮点类型。因而，比特币客户端用该值来估计难度(称之为：“bdiff”)。</p><h3 id="难度如何保存在区块上呢？"><a href="#难度如何保存在区块上呢？" class="headerlink" title="难度如何保存在区块上呢？"></a>难度如何保存在区块上呢？</h3><p>每一个区块会用一种压缩的格式（被称为“Bits”）来表示实际的16进制的目标值。目标值通过一个预先定义好的公式，从这个压缩值中得出。举一个例子，压缩值为<code>0x1b0404cb</code>，16进制的目标值则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><blockquote><p>Note that the 0x0404cb value is a signed value in this format. The largest legal value for this field is 0x7fffff. To make a larger value you must shift it down one full byte. Also 0x008000 is the smallest positive valid value.</p></blockquote><p>注意<code>0x0404cb</code> 是一个符号数，最大值是<code>0x7fffff</code>，这个明白，下面两句就不明白了：如果想生成一个更大的值，你需要向下移动一整个字节。同时，<code>0x008000</code> 是最小的正值（为什么不是<code>0x000001</code>呢？）。</p><h3 id="难度如何计算？"><a href="#难度如何计算？" class="headerlink" title="难度如何计算？"></a>难度如何计算？</h3><p>最大目标难度（1）被定义成<code>0x1d00ffff</code>， 那么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00ffff * 2**(8*(0x1d - 3)) = 0x00000000FFFF0000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>这个是截断后的目标值，就是上文所说的比特币协议定义的格式，如果没有截断，那么就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure><p>所以<code>0x1b0404cb</code> 位置的难度是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00000000FFFF0000000000000000000000000000000000000000000000000000 /</span><br><span class="line">0x00000000000404CB000000000000000000000000000000000000000000000000 </span><br><span class="line">= 16307.420938523983 (bdiff)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF /</span><br><span class="line">0x00000000000404CB000000000000000000000000000000000000000000000000 </span><br><span class="line">= 16307.669773817162 (pdiff)</span><br></pre></td></tr></table></figure><h3 id="当前难度是什么"><a href="#当前难度是什么" class="headerlink" title="当前难度是什么"></a>当前难度是什么</h3><p><a href="https://blockexplorer.com/api/status?q=getDifficulty" target="_blank" rel="noopener">Current difficulty</a>。这个是比特币浏览器提供的接口，给出了当前难度。</p><h3 id="什么是最大难度"><a href="#什么是最大难度" class="headerlink" title="什么是最大难度"></a>什么是最大难度</h3><blockquote><p>There is no minimum target. The maximum difficulty is roughly: maximum_target / 1 (since 0 would result in infinity), which is a ridiculously huge number (about 2^224).</p></blockquote><blockquote><p>The actual maximum difficulty is when current_target=0, but we would not be able to calculate the difficulty if that happened. (fortunately it never will, so we’re ok.)</p></blockquote><p>不存在最小的目标。最大难度可以粗暴地认为是：maximum_target / 1（因为0会产生无限值），这个数很大，大约是2的224次方。</p><h3 id="网络难度是否可以降低"><a href="#网络难度是否可以降低" class="headerlink" title="网络难度是否可以降低"></a>网络难度是否可以降低</h3><p>可以，参考上面的内容。</p><h3 id="最小难度是什么"><a href="#最小难度是什么" class="headerlink" title="最小难度是什么"></a>最小难度是什么</h3><blockquote><p>The minimum difficulty, when the target is at the maximum allowed value, is 1.</p></blockquote><p>当targe是最大允许值的时候，最小难度，也就是1。这里说的target应该是分母，分子的最大值是确定的，上文已经说过了。</p><h3 id="在给定难度的情况下，网络hash率是如何得出的"><a href="#在给定难度的情况下，网络hash率是如何得出的" class="headerlink" title="在给定难度的情况下，网络hash率是如何得出的"></a>在给定难度的情况下，网络hash率是如何得出的</h3><p>根据10分钟一块的平均速度，产生2016个块应该需要两周。每产生2016个块，会调整一下难度，根据之前产生这2016个块花费的时间，和理论上应该花费的时间–两周做一下对比。</p><p>难度为1时的目标值（上文提到的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xffff * 2**208</span><br></pre></td></tr></table></figure><p>难度为D时的目标值应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0xffff * 2**208) / D</span><br></pre></td></tr></table></figure><p>所需要的<code>hash</code>计算数（2**256是最大<code>hash</code>计算数，除以当前的目标值，也是一个256位的数，例如上面的<code>0x00000000000404CB000000000000000000000000000000000000000000000000</code> ，这个地方不是太理解，这样除，就可以算出总共需要的计算数？翻了一些帖子，还是没有找到答案）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D * 2**256 / (0xffff * 2**208)</span><br></pre></td></tr></table></figure></p><p>简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D * 2**48 / 0xffff</span><br></pre></td></tr></table></figure><p>以上是10分钟的<code>hash</code>数，<code>hash</code>率是以秒为单位的，所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D * 2**48 / 0xffff / 600</span><br></pre></td></tr></table></figure></p><p>最后简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D * 2**32 / 600</span><br></pre></td></tr></table></figure><p>如果难度为1的话，每秒钟7 Mhashes。<br>原文写作时，难度是 22012.4941572，那么过去2016个块的<code>hash</code>率是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22012.4941572 * 2**32 / 600 = around 157 Ghashes per second.</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.bitcoin.it/wiki/Difficulty。" target="_blank" rel="noopener">https://en.bitcoin.it/wiki/Difficulty。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/blockchain/bitcoin-difficulty.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;区块链：比特币难度的概念。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/categories/Blockchain/"/>
    
    
      <category term="区块链" scheme="https://www.oxysun.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="https://www.oxysun.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="难度" scheme="https://www.oxysun.cn/tags/%E9%9A%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-branch的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-branch.html"/>
    <id>https://www.oxysun.cn/git/git-branch.html</id>
    <published>2018-07-30T03:37:00.000Z</published>
    <updated>2018-08-02T00:39:42.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-branch.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>git-branch的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>git branch的用法。这个命令使用频度很高，还有一些没有搞明白，在这里总结梳理一下。</p><p>PS：之前的文章题目命名都用空格，以前一直不理解git的官网为什么多加一个“-”，现在明白了，为了用作文章名和题目比较方便，解了一个惑。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git branch [--color[=&lt;when&gt;] | --no-color] [-r | -a] [--list] [-v [--abbrev=&lt;length&gt; | --no-abbrev]]</span><br><span class="line">[--column[=&lt;options&gt;] | --no-column] [--sort=&lt;key&gt;]</span><br><span class="line">[(--merged | --no-merged) [&lt;commit&gt;]]</span><br><span class="line">[--contains [&lt;commit]] [--no-contains [&lt;commit&gt;]]</span><br><span class="line">[--points-at &lt;object&gt;] [--format=&lt;format&gt;] [&lt;pattern&gt;…​] // 列出分支（这个用法有点复杂）</span><br><span class="line"></span><br><span class="line">git branch [--track | --no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;] // 设置分支本地和远程的关系（上流）</span><br><span class="line">git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;] // 设置分支上流</span><br><span class="line">git branch --unset-upstream [&lt;branchname&gt;] // 取消分支上流的设置</span><br><span class="line">git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt; // 重命名分支</span><br><span class="line">git branch (-c | -C) [&lt;oldbranch&gt;] &lt;newbranch&gt; // 拷贝分支</span><br><span class="line">git branch (-d | -D) [-r] &lt;branchname&gt;…​ // 删除分支</span><br><span class="line">git branch --edit-description [&lt;branchname&gt;] //修改分支描述</span><br></pre></td></tr></table></figure><p>git branch有以上这么多种用法，原本我看了几遍，也感觉云山雾绕，需要在上面加了一些备注。</p><h2 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h2><p><strong>实例：</strong> 展示分支<br>最简单的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p><p>较为详细的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">* master cac453c 从版本库中移除项目配置文件和日志配置文件</span><br></pre></td></tr></table></figure></p><p>可以看到，加了<code>-v</code>，显示出了提交号。</p><p>更为详细的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">* master cac453c [origin/master] 从版本库中移除项目配置文件和日志配置文件</span><br></pre></td></tr></table></figure></p><p>可以看到，加两个<code>v</code>，除了显示出了提交号，还显示出了上流分支（upstream）的名称。。</p><p><strong>实例：</strong> 查看所有分支（包括远程的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/f_1123</span><br><span class="line">  remotes/origin/f_1268</span><br><span class="line">  remotes/origin/f_1316</span><br><span class="line">  remotes/origin/f_1317</span><br><span class="line">  remotes/origin/f_1346</span><br><span class="line">  remotes/origin/f_1347</span><br><span class="line">  remotes/origin/f_1490</span><br><span class="line">  remotes/origin/f_english</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p><code>-a</code>就是<code>-all</code>的意思，显示所有。</p><p><strong>实例：</strong> 查看远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/dev</span><br><span class="line">  origin/f_1123</span><br><span class="line">  origin/f_1268</span><br><span class="line">  origin/f_1316</span><br><span class="line">  origin/f_1317</span><br><span class="line">  origin/f_1346</span><br><span class="line">  origin/f_1347</span><br><span class="line">  origin/f_1490</span><br><span class="line">  origin/f_english</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure><p>比上面那个指令少了一项<code>master</code>。<br><code>-r</code>的意思是<code>remote</code>，显示远程的分支情况。</p><p><strong>实例：</strong>修改分支名<br>把<code>master</code>分支名称修改成<code>dev</code>，这里仅仅是举一个例子，正常工作中一般是不应该发生这样的修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master dev</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong>删除分支<br>删除dev分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D dev</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/docs/git-branch。" target="_blank" rel="noopener">https://git-scm.com/docs/git-branch。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-branch.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;git-branch的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="git branch" scheme="https://www.oxysun.cn/tags/git-branch/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="分支" scheme="https://www.oxysun.cn/tags/%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java：“目标服务器没有返回一个X-Frame-Options头”的解决方案</title>
    <link href="https://www.oxysun.cn/java/java-springmvc-X-Frame-Options.html"/>
    <id>https://www.oxysun.cn/java/java-springmvc-X-Frame-Options.html</id>
    <published>2018-07-29T03:25:00.000Z</published>
    <updated>2018-08-02T00:39:42.489Z</updated>
    
    <content type="html"><![CDATA[<p>原帖位于<a href="https://www.oxysun.cn/java/java-springmvc-X-Frame-Options.html">IT老兵博客</a>，沉淀着一个IT老兵对于这个行业的认知。</p><p>Java：“目标服务器没有返回一个X-Frame-Options头”的解决方案。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在涉及网站安全时遇到一个问题（360网站安全测试也会报告），“目标服务器没有返回一个X-Frame-Options头”，找了网上的帖子，说的都不是太清楚，所以研究总结一下，方便后人。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>以下摘录一下对于安全网站这个问题的描述和建议解决方案：</p><blockquote><p>概要<br>目标服务器没有返回一个X-Frame-Options头。<br>攻击者可以使用一个透明的、不可见的iframe，覆盖在目标网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击iframe页面的一些功能性按钮上，导致被劫持。<br><br><br>解决方案<br>修改web服务器配置，添加X-frame-options响应头。赋值有如下三种：<br>（1）DENY：不能被嵌入到任何iframe或frame中。<br>（2）SAMEORIGIN：页面只能被本站页面嵌入到iframe或者frame中。<br>（3）ALLOW-FROM uri：只能被嵌入到指定域名的框架中。<br>也可在代码中加入，在PHP中加入：<br>header(‘X-Frame-Options: deny’);</p></blockquote><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>但是我们的环境是<code>Java</code>的<code>Springmvc</code>，这个应该怎么解决呢？其实<code>Spring</code>框架中的<code>security</code>本身有对这个问题的解决方案，但是这是之前的<code>Spring</code>框架中的（<code>SSH</code>那会的），现在用了<code>SpringMVC</code>了，应该怎么去解决这个问题呢？</p><p>参考<a href="https://blog.csdn.net/princeluan/article/details/73268637" target="_blank" rel="noopener">这里</a>，这里介绍说配置项目的web.xml文件如下，即可解决问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.apache.catalina.filters.HttpHeaderSecurityFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;antiClickJackingOption&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;SAMEORIGIN&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;async-supported&gt;true&lt;/async-supported&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><p>但是我这里又引出一个新的问题：</p><blockquote><p>cvc-complex-type.2.4.a: Invalid content was found starting with element ‘async-supported’. One of ‘{“<a href="http://java.sun.com/xml/ns/javaee&quot;:run-as" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee&quot;:run-as</a>, “<a href="http://java.sun.com/xml/ns/javaee&quot;:security-role-ref}&#39;" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee&quot;:security-role-ref}&#39;</a> is expected.</p></blockquote><p>意思是说<code>async-supported</code>这个元素不被识别。继续探索，找到<a href="https://blog.csdn.net/DouBoomFly/article/details/70200740" target="_blank" rel="noopener">这里</a>说的：</p><blockquote><p>xmlns中再加两行：<br><a href="http://www.springmodules.org/schema/cache/springmodules-cache.xsd" target="_blank" rel="noopener">http://www.springmodules.org/schema/cache/springmodules-cache.xsd</a><br><a href="http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd" target="_blank" rel="noopener">http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd</a></p></blockquote><p>要在web.xml顶部的<code>xmlns</code>里面再加两行，问题才真正得到了解决。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>问题是解决了，但是问题产生的原因和解决的方法又是什么呢？</p><p>###首先，这样设置web.xml的目的是什么？</p><p>找到<a href="https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html" target="_blank" rel="noopener"><code>Tomcat</code>官网</a>的讲解：</p><blockquote><p>org.apache.catalina.filters.HttpHeaderSecurityFilter .//过滤器的类名<br>……<br>antiClickJackingOption //参数配置，可以设置成DENY（拒绝），SAMEORIGIN（同源），ALLOW-FROM（允许从哪里来的）<br>What value should be used for the anticlick-jacking header? Must be one of DENY, SAMEORIGIN, ALLOW-FROM (case-insensitive). If not specified, the default value of DENY will be used.</p></blockquote><p>意思是说<code>HttpHeaderSecurityFilter</code> 这个过滤器是用来做<code>anticlick-jacking</code>（防止点击劫持，<code>Java</code>做<code>Web</code>服务的优越性就在这里，很多功能都已经做成了工具类，只需要配置一下即可）。三个配置选项，我们上文中配置成了SAMEORIGIN（同源），安全性就大大提高了。<br>那么，上面配置这个过滤器就搞明白了，那么后面出现的那个问题又是怎么回事呢？</p><h3 id="其次，web-xml的这个设置错误又是怎么回事？"><a href="#其次，web-xml的这个设置错误又是怎么回事？" class="headerlink" title="其次，web.xml的这个设置错误又是怎么回事？"></a>其次，web.xml的这个设置错误又是怎么回事？</h3><p>这里要研究一下这段语句的意思，在web.xml的头部，可能很多人总会看到它，但不会去思考它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app version=&quot;3.0&quot; </span><br><span class="line">    xmlns=&quot;http://java.sun.com/xml/ns/javaee </span><br><span class="line">    http://www.springmodules.org/schema/cache/springmodules-cache.xsd </span><br><span class="line">    http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee </span><br><span class="line">    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><code>xmlns</code>：<code>xml</code>的<code>namespace</code>，这个是为了解决多个开发者对于xml的命名会产生冲突的问题。<br><code>xmlns:xsi</code>：定义了<code>xml</code>的标准前缀。<br><code>xsi:schemaLocation</code>：<code>xml</code>的<code>schema</code>定义的位置。</p><p>简言之，<code>Java</code>对于<code>xml</code>的名值设置了一套定义规则，发布在上面的地方，我们上面使用的这个元素名<code>async-supported</code> ，在之前的<code>web.xml</code>中所定义的位置是没有找到的，加了那两行的命名空间的定义，才可以找到这个元素定义的位置。</p><p>至此，问题基本搞明白了。</p><p>参考<br><a href="https://www.w3schools.com/xml/schema_intro.asp。" target="_blank" rel="noopener">https://www.w3schools.com/xml/schema_intro.asp。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原帖位于&lt;a href=&quot;https://www.oxysun.cn/java/java-springmvc-X-Frame-Options.html&quot;&gt;IT老兵博客&lt;/a&gt;，沉淀着一个IT老兵对于这个行业的认知。&lt;/p&gt;
&lt;p&gt;Java：“目标服务器没有返回一个X-Frame-Options头”的解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.oxysun.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.oxysun.cn/tags/Java/"/>
    
      <category term="tomcat" scheme="https://www.oxysun.cn/tags/tomcat/"/>
    
      <category term="linux" scheme="https://www.oxysun.cn/tags/linux/"/>
    
      <category term="X-Frame-Options" scheme="https://www.oxysun.cn/tags/X-Frame-Options/"/>
    
  </entry>
  
  <entry>
    <title>Git：git diff发现windows下会出现&quot;^M&quot;符号</title>
    <link href="https://www.oxysun.cn/git/git-diff-m-symbol.html"/>
    <id>https://www.oxysun.cn/git/git-diff-m-symbol.html</id>
    <published>2018-07-28T13:53:00.000Z</published>
    <updated>2018-08-02T00:39:42.485Z</updated>
    
    <content type="html"><![CDATA[<p>原帖收藏于IT老兵驿站，传递一个IT老兵凋零前的光和氧。</p><p>Git：git diff发现windows下会出现”^M”符号。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在不同操作系统上编译Git仓库的文件，经常在<code>git diff</code> 时发现很多文件的变化是尾部多了一个<code>^M</code> 的符号。这给工作带来很多困扰，研究一下这个问题。</p><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><p>翻到这个<a href="https://stackoverflow.com/questions/1889559/git-diff-to-ignore-m" target="_blank" rel="noopener">帖子</a>：</p><blockquote><p><a href="https://help.github.com/articles/dealing-with-line-endings/" target="_blank" rel="noopener">GitHub</a> suggests that you should make sure to only use \n as a newline character in git-handled repos. There’s an option to auto-convert:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf true</span><br></pre></td></tr></table></figure><p>大体翻译：GitHub建议你应该只用<code>\n</code> 来做为新行的开始，用上面那样的设置就可以做到自动的转换，这样也就解决了问题，Git不会再报告差异。</p><p>那这是为什么呢？</p><p>阅读一下这里所介绍的这个帖子。</p><blockquote><p>If you’re using Git to collaborate with others on GitHub, ensure that Git is properly configured to handle line endings.</p></blockquote><blockquote><p>Every time you press return on your keyboard you’re actually inserting an invisible character called a line ending. Historically, different operating systems have handled line endings differently.</p></blockquote><blockquote><p>When you view changes in a file, Git handles line endings in its own way. Since you’re collaborating on projects with Git and GitHub, Git might produce unexpected results if, for example, you’re working on a Windows machine, and your collaborator has made a change in OS X.</p></blockquote><p>这里大概是说每个操作系统有自己的换行符（就是当你按下”回车”后，系统会自动插入一些不可见的符号来表示一行的结束），<code>Linux</code>和<code>Mac</code>都是使用<code>LF</code> ，<code>Windows</code> 则是<code>CRLF</code> ，这样就造成了差异。</p><p>Git会对此进行一些处理，但是做什么处理呢？这里没有说清楚，只是说要用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.autocrlf</span><br></pre></td></tr></table></figure><p>来控制，和上面说的是一样的，但是原理还是没有搞明白。</p><p>只好来看<a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">官网</a>。</p><blockquote><p>core.autocrlf<br>Setting this variable to “true” is the same as setting the text attribute to “auto” on all files and core.eol to “crlf”. Set to true if you want to have CRLF line endings in your working directory and the repository has LF line endings. This variable can be set to input, in which case no output conversion is performed.</p></blockquote><p>这个变量设置为<code>true</code> 等同于在所有文件上设置<code>text attribute</code> 为<code>auto</code> 并且把<code>core.eol</code> 设置为<code>crlf</code>。设成<code>true</code> ， 如果你的工作空间用的是<code>CRLF</code> 作为行结束符，同时仓库用的是<code>LF</code> 行结束符。这个变量也可以设置成<code>input</code>，这样在输出时就不做转换了。</p><p>对上面说的<code>core.eol</code> 又不明白了，继续查看：</p><blockquote><p>core.eol<br>Sets the line ending type to use in the working directory for files that have the text property set when core.autocrlf is false. Alternatives are lf, crlf and native, which uses the platform’s native line ending. The default value is native. See gitattributes[5] for more information on end-of-line conversion.</p></blockquote><p>这个变量是用来设置行结束符的，在<code>core.autocrlf</code> 是<code>false</code>的时候。可以设置成<code>lf</code>，<code>crlf</code>和<code>native</code> ， <code>native</code>是说使用当前平台自己的行结束符。</p><p>到这里，大体就明白了，还留有一个问题，就是<code>attribute</code>的问题，留在下一次来研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原帖收藏于IT老兵驿站，传递一个IT老兵凋零前的光和氧。&lt;/p&gt;
&lt;p&gt;Git：git diff发现windows下会出现”^M”符号。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="diff" scheme="https://www.oxysun.cn/tags/diff/"/>
    
      <category term="windows" scheme="https://www.oxysun.cn/tags/windows/"/>
    
      <category term="^M" scheme="https://www.oxysun.cn/tags/M/"/>
    
      <category term="符号" scheme="https://www.oxysun.cn/tags/%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>区块链：Base64编码和Base58编码</title>
    <link href="https://www.oxysun.cn/blockchain/base64-base58.html"/>
    <id>https://www.oxysun.cn/blockchain/base64-base58.html</id>
    <published>2018-07-27T03:10:00.000Z</published>
    <updated>2018-08-18T00:08:05.861Z</updated>
    
    <content type="html"><![CDATA[<p>区块链：Base64编码和Base58编码。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接触base64有很久了，其实一直没有理解base64这种编码的根本原理，或者说是设计意图，今天又读了一遍，终于开窍了，请看下图。</p><p>Base64 table</p><table><thead><tr><th>原始值</th><th>显示值</th><th>原始值</th><th>显示值</th><th>原始值</th><th>显示值</th><th>原始值</th><th>显示值</th></tr></thead><tbody><tr><td>0</td><td><code>A</code></td><td>16</td><td><code>Q</code></td><td>32</td><td><code>g</code></td><td>48</td><td><code>w</code></td></tr><tr><td>1</td><td><code>B</code></td><td>17</td><td><code>R</code></td><td>33</td><td><code>h</code></td><td>49</td><td><code>x</code></td></tr><tr><td>2</td><td><code>C</code></td><td>18</td><td><code>S</code></td><td>34</td><td><code>i</code></td><td>50</td><td><code>y</code></td></tr><tr><td>3</td><td><code>D</code></td><td>19</td><td><code>T</code></td><td>35</td><td><code>j</code></td><td>51</td><td><code>z</code></td></tr><tr><td>4</td><td><code>E</code></td><td>20</td><td><code>U</code></td><td>36</td><td><code>k</code></td><td>52</td><td><code>0</code></td></tr><tr><td>5</td><td><code>F</code></td><td>21</td><td><code>V</code></td><td>37</td><td><code>l</code></td><td>53</td><td><code>1</code></td></tr><tr><td>6</td><td><code>G</code></td><td>22</td><td><code>W</code></td><td>38</td><td><code>m</code></td><td>54</td><td><code>2</code></td></tr><tr><td>7</td><td><code>H</code></td><td>23</td><td><code>X</code></td><td>39</td><td><code>n</code></td><td>55</td><td><code>3</code></td></tr><tr><td>8</td><td><code>I</code></td><td>24</td><td><code>Y</code></td><td>40</td><td><code>o</code></td><td>56</td><td><code>4</code></td></tr><tr><td>9</td><td><code>J</code></td><td>25</td><td><code>Z</code></td><td>41</td><td><code>p</code></td><td>57</td><td><code>5</code></td></tr><tr><td>10</td><td><code>K</code></td><td>26</td><td><code>a</code></td><td>42</td><td><code>q</code></td><td>58</td><td><code>6</code></td></tr><tr><td>11</td><td><code>L</code></td><td>27</td><td><code>b</code></td><td>43</td><td><code>r</code></td><td>59</td><td><code>7</code></td></tr><tr><td>12</td><td><code>M</code></td><td>28</td><td><code>c</code></td><td>44</td><td><code>s</code></td><td>60</td><td><code>8</code></td></tr><tr><td>13</td><td><code>N</code></td><td>29</td><td><code>d</code></td><td>45</td><td><code>t</code></td><td>61</td><td><code>9</code></td></tr><tr><td>14</td><td><code>O</code></td><td>30</td><td><code>e</code></td><td>46</td><td><code>u</code></td><td>62</td><td><code>+</code></td></tr><tr><td>15</td><td><code>P</code></td><td>31</td><td><code>f</code></td><td>47</td><td><code>v</code></td><td>63</td><td><code>/</code></td></tr></tbody></table><p>什么意思呢？我这样理解，在计算机里面，所有信息都是以二进制的方式承载的，即<code>0</code>和<code>1</code>，这二进制如何去表达我们想要显示（printable）的信息呢？这个时候ASCII码就出现了，以及后来的UniCode等等，它们是以字节为单位来处理，一个字节是8位，这也是计算机系统里面的一个标准处理单位。</p><p>而Base64的目的不是这个，它是要把一段信息显示成另外的一个形式，变成不可直接读，这样尤其是在邮件传输时，可以增加一点安全性。所以，它是以6位为一个单位来处理，对应上面的这个码表，来显示的。Base58是Base64的子集，它的码表元素就更少了，少了8个（ <code>0 , O (大写O)，I (大写i) ，l (小写L) ， + (加号) ，/ (后倒线)</code>），现在被用于区块链领域。</p><p>6位的处理会造成有的时候，不够一个字节，后面需要多补一个到两个字节的<code>0</code>来补齐长度，统一用<code>=</code>显示。</p><p>以下这个例子取自<a href="https://en.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">维基百科</a>，一个表用MD不好展示，分成了两个表：</p><table><thead><tr><th>Source text (ASCII)</th><th>M</th><th>a</th><th></th></tr></thead><tbody><tr><td>Source octets</td><td>77 (0x4d)</td><td>97 (0x61)</td><td></td></tr><tr><td>Bit pattern</td><td>0 1 0 0 1 1 0 1</td><td>0 1 1 0 0 0 0 1</td><td>0 0 0 0 0 0 0 0</td></tr></tbody></table><table><thead><tr><th>Source text (ASCII)</th><th>M</th><th>a</th><th></th><th></th></tr></thead><tbody><tr><td>Bit pattern</td><td>0 1 0 0 1 1</td><td>0 1 0 1 1 0</td><td>0 0 0 1 0 0</td><td>0 0 0 0 0 0</td></tr><tr><td>Index</td><td>19</td><td>22</td><td>4</td><td>(padding)</td></tr><tr><td>Base64-encoded</td><td>T</td><td>W</td><td>E</td><td>=</td></tr><tr><td>Encoded octets</td><td>84 (0x54)</td><td>87 (0x57)</td><td>69 (0x45)</td><td>61 (0x3D)</td></tr></tbody></table><p>这样<code>MA</code>就变成了<code>TWE=</code>，这样就清楚了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链：Base64编码和Base58编码。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/categories/Blockchain/"/>
    
    
      <category term="区块链" scheme="https://www.oxysun.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Base48" scheme="https://www.oxysun.cn/tags/Base48/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：which</title>
    <link href="https://www.oxysun.cn/linux/shell-command-which.html"/>
    <id>https://www.oxysun.cn/linux/shell-command-which.html</id>
    <published>2018-07-26T15:03:07.000Z</published>
    <updated>2018-07-26T15:13:49.679Z</updated>
    
    <content type="html"><![CDATA[<p><code>which</code>命令用于查找并显示给定命令的绝对路径，环境变量<code>$PATH</code>中保存了查找命令时需要遍历的目录。<code>which</code>指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用<code>which</code>命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><a id="more"></a><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>今天有点累，也已经很晚了，总结一个较为简单的命令吧，20英里法则，每天尽量坚持往前走一点。</p><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p><code>which</code>命令是查找某个命令的完整路径。它是用来在当前登录用户的<code>$PATH</code>环境变量记录的路径中查找可执行文件（即二进制文件）的路径。默认情况下，只返回第一个搜索结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHICH(1)                                                        General Commands Manual                                                       WHICH(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       which - shows the full path of (shell) commands.</span><br></pre></td></tr></table></figure><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>which [选项] 命令</code></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>实例：</strong>查看ls命令的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz90drrwkerfi7bc8mqiZ ~]# which ls</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br><span class="line">/usr/bin/ls</span><br></pre></td></tr></table></figure><p>第一行输出暂时没有搞明白是哪里来的，第二行就是<code>ls</code>命令的位置了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;which&lt;/code&gt;命令用于查找并显示给定命令的绝对路径，环境变量&lt;code&gt;$PATH&lt;/code&gt;中保存了查找命令时需要遍历的目录。&lt;code&gt;which&lt;/code&gt;指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用&lt;code&gt;which&lt;/code&gt;命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Shell" scheme="https://www.oxysun.cn/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git：修改远程仓库地址</title>
    <link href="https://www.oxysun.cn/git/git-remote-set-url.html"/>
    <id>https://www.oxysun.cn/git/git-remote-set-url.html</id>
    <published>2018-07-25T14:58:00.000Z</published>
    <updated>2018-08-02T00:39:42.487Z</updated>
    
    <content type="html"><![CDATA[<p>Git：修改远程仓库地址。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有的时候，我们会遇到Git远程仓库IP发生改变，这样的改变可能是：</p><ol><li>远程服务器挂了：远程服务器上的Git仓库被一个爱折腾的同事给删掉了，这个时候把他骂死也没用了，这要是SVN就没办法了，还好是Git，可以从本机的仓库去恢复这个远程仓库。</li><li>远程服务器迁移了，IP变了。<br>这个时候就要用到这个命令了。</li></ol><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-remote - Manage set of tracked repositories（管理被追踪的仓库集合）</span><br></pre></td></tr></table></figure><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>修改远程仓库的url只是这个命令的一个功能。</p><p>记得很久以前（刚毕业的时候）从一本书中看到，中括号表示是可选项，尖括号表示为必选项，现在找不到了，上网查了查，可以参考<a href="https://stackoverflow.com/questions/23242493/linux-unix-man-page-syntax-conventions" target="_blank" rel="noopener">这里</a>。关于这个问题，接触过的很多同事都是糊里糊涂的，我觉得这样总是不好，搞计算机，应该严谨一些，做事情，还是应该寻根究底。</p><p>所以，要修改远程仓库，只需要进入代码目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"># 查看当前的远程仓库</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://where you want to put your repository to.git</span><br><span class="line"># 修改为想要设置的远程仓库</span><br><span class="line"></span><br><span class="line">git remote -v</span><br><span class="line">#验证一下</span><br></pre></td></tr></table></figure><p>大功告成，亲个嘴（韦小宝语）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/docs/git-remote。" target="_blank" rel="noopener">https://git-scm.com/docs/git-remote。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git：修改远程仓库地址。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="修改" scheme="https://www.oxysun.cn/tags/%E4%BF%AE%E6%94%B9/"/>
    
      <category term="远程仓库地址" scheme="https://www.oxysun.cn/tags/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-revert的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-revert.html"/>
    <id>https://www.oxysun.cn/git/git-revert.html</id>
    <published>2018-07-24T14:10:00.000Z</published>
    <updated>2018-08-02T00:39:42.488Z</updated>
    
    <content type="html"><![CDATA[<p>Git：git-revert的用法总结。<br><a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-revert - Revert some existing commits // 撤销一些已经存在的提交</span><br></pre></td></tr></table></figure><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​</span><br><span class="line">git revert --continue</span><br><span class="line">git revert --quit</span><br><span class="line">git revert --abort</span><br></pre></td></tr></table></figure><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><blockquote><p>Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit).<br>Note: git revert is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see git-reset[1], particularly the –hard option. If you want to extract specific files as they were in another commit, you should see git-checkout[1], specifically the git checkout <commit> – <filename> syntax. Take care with these alternatives as both will discard uncommitted changes in your working directory.</filename></commit></p></blockquote><p>这个工具的使用场景有一点复杂，所以把原本的介绍贴在这里，下面附上翻译：<br>给定一个或多个现有提交，还原由这些提交引入的更改，并用新的提交去记录。 这需要您的工作树是干净的（没有对于<code>HEAD</code>的修改）。注意：<code>git revert</code>用于记录一些新的提交以还原某些早期提交的效果（通常是一个错误的提交）。 如果你想丢弃工作目录中所有未提交的更改，你应该看到<code>git-reset [1]</code>，特别是–hard选项。 如果你想在另一个提交中提取特定文件，你应该看到<code>git-checkout [1]</code>，特别是<code>git checkout &lt;commit&gt; - &lt;filename&gt;</code>语法。 请注意这些替代方案，因为它们都会丢弃工作目录中未提交的更改。</p><p>意思是，如果你想撤销之前的一个或几个提交带来的修改，那么使用这个工具；如果想放弃工作目录的修改（并没有提交），那么你应该使用<code>git reset</code>；或者你只是想检出一个文件的某一个版本，那么使用<code>git checkout</code>。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>摘录了官网的两个例子：<br><strong>实例：</strong> 撤销HEAD指针之前的第3个提交，并且生成一个新的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~3</span><br></pre></td></tr></table></figure><blockquote><p>Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes.</p></blockquote><p><strong>实例：</strong> 撤销从master之前第5个提交到之前第3个提交的变化（这么看来，前面是开区间，第6个没有被包含；后面是闭区间，包含了第3个）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert -n master~5..master~2</span><br></pre></td></tr></table></figure><blockquote><p>Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index.</p></blockquote><p><strong>实例：</strong> 撤销某个提交带来的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git：git-revert的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="git revert" scheme="https://www.oxysun.cn/tags/git-revert/"/>
    
  </entry>
  
  <entry>
    <title>区块链：教程 | 以太坊智能合约编程之菜鸟教程</title>
    <link href="https://www.oxysun.cn/blockchain/block-chain-ethereum-contract-program.html"/>
    <id>https://www.oxysun.cn/blockchain/block-chain-ethereum-contract-program.html</id>
    <published>2018-07-23T14:37:00.000Z</published>
    <updated>2018-08-18T00:08:05.862Z</updated>
    
    <content type="html"><![CDATA[<p>区块链：教程 | 以太坊智能合约编程之菜鸟教程。<br><a id="more"></a></p><blockquote><p>这篇介绍以太坊合约的文章写得很好，在查找了这么多资料，进行对比之后，感觉阅读这一篇就可以大体理解以太坊编程的原理，如果对个别的知识点还有点含糊，可以相应地去查一查，就是以这篇为主干，别的资料为辅。稍微整理了一下格式，以及修改了一些半角符号。</p></blockquote><p><em>译注：<a href="http://consensys.github.io/developers/articles/101-noob-intro/" target="_blank" rel="noopener">原文</a>首发于ConsenSys开发者博客，原作者为Eva以及ConsenSys的开发团队。如果您想要获取更多及时信息，可以访问<a href="https://consensys.net/" target="_blank" rel="noopener">ConsenSys</a>首页点击左下角Newsletter订阅邮件。本文的翻译获得了ConsenSys创始人Lubin先生的授权。</em></p><p>有些人说以太坊太难对付，于是我们(译注：指<a href="http://consensys.net" target="_blank" rel="noopener">Consensys</a>, 下同)写了这篇文章来帮助大家学习如何利用以太坊编写智能合约和应用。这里所用到的工具，钱包，应用程序以及整个生态系统仍处于开发状态，它们将来会更好用！</p><ul><li><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.%20%E6%A6%82%E8%BF%B0">第一部分</a>概述，讨论了关键概念，几大以太坊客户端以及写智能合约用到的编程语言。</li><li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.%20DApp%E6%A1%86%E6%9E%B6,%20%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">第二部分</a>讨论了总体的工作流程，以及目前流行的一些DApp框架和工具。</li><li><a href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86.%20%E7%BC%96%E7%A8%8B">第三部分</a>主要关于编程，我们将学习如何使用Truffle来为智能合约编写测试和构建DApp。</li></ul><h2 id="第一部分-概述"><a href="#第一部分-概述" class="headerlink" title="第一部分 概述"></a>第一部分 概述</h2><p>如果你对诸如比特币以及其工作原理等密码学货币的概念完全陌生，我们建议你先看看Andreas Antonopoulos所著的<a href="https://github.com/aantonop/bitcoinbook" target="_blank" rel="noopener">Bitcoin Book</a>的头几章，然后读一下<a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="noopener">以太坊白皮书</a>。(译注：以太坊白皮书中文版请看 <a href="http://ethfans.org/posts/ethereum-whitepaper" target="_blank" rel="noopener">http://ethfans.org/posts/ethereum-whitepaper</a>)</p><p>如果你觉得白皮书中的章节太晦涩，也可以直接动手来熟悉以太坊。在以太坊上做开发并不要求你理解所有那些“密码经济计算机科学”(crypto economic computer science)，而白皮书的大部分是关于以太坊想对于比特币架构上的改进。</p><h3 id="新手教程"><a href="#新手教程" class="headerlink" title="新手教程"></a>新手教程</h3><p><a href="http://ethereum.org" target="_blank" rel="noopener">ethereum.org</a>提供了官方的新手入门教程，以及一个代币合约和众筹合约的教程。合约语言Solidity也有<a href="https://ethereum.github.io/solidity/" target="_blank" rel="noopener">官方文档</a>。学习智能合约的另一份不错的资料（也是我的入门资料）是<a href="https://dappsforbeginners.wordpress.com/" target="_blank" rel="noopener">dappsForBeginners</a>，不过现在可能有些过时了。</p><p>这篇文章的目的是成为上述资料的补充，同时介绍一些基本的开发者工具，使入门以太坊，智能合约以及构建DApps(decentralized apps, 分布式应用)更加容易。我会试图按照我自己(依然是新手)的理解来解释工作流程中的每一步是在做什么，我也得到了ConsenSys酷酷的开发者们的许多帮助。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>了解这些名词是一个不错的开始：</p><p><strong>公钥加密系统。</strong> Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的<code>0xdf...5f</code>地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。过来人表示：通过踩坑学习到这一点是非常痛苦的…</p><p><strong>点对点网络。</strong> 就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。(未来会有半中心化的混合型服务出现为用户和开发者提供方便，这我们后面会讲到。)</p><p><strong>区块链。</strong> 区块链就像是一个全球唯一的帐簿，或者说是数据库，记录了网络中所有交易历史。</p><p><strong>以太坊虚拟机(EVM)。</strong> 它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。</p><p><strong>节点。</strong> 你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。</p><p><strong>矿工。</strong> 挖矿，也就是处理区块链上的区块的节点。这个网页可以看到当前活跃的一部分以太坊矿工：<a href="http://stats.ethdev.com" target="_blank" rel="noopener">stats.ethdev.com</a>。</p><p><strong>工作量证明。</strong> 矿工们总是在竞争解决一些数学问题。第一个解出答案的(算出下一个区块)将获得以太币作为奖励。然后所有节点都更新自己的区块链。所有想要算出下一个区块的矿工都有与其他节点保持同步，并且维护同一个区块链的动力，因此整个网络总是能达成共识。(注意：以太坊正计划转向没有矿工的权益证明系统(POS)，不过那不在本文讨论范围之内。)</p><p><strong>以太币。</strong> 缩写ETH。一种你可以购买和使用的真正的数字货币。这里是可以交易以太币的其中一家交易所的<a href="https://poloniex.com/exchange#usdt_eth" target="_blank" rel="noopener">走势图</a>。在写这篇文章的时候，1个以太币价值65美分。</p><p><strong>Gas。(汽油)</strong> 在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。</p><p><strong>DApp。</strong> 以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。(花一分钟思考一下：与一般的网站不同，DApp不能跑在普通的服务器上。他们需要提交交易到<strong>区块链</strong>并且从<strong>区块链</strong>而不是中心化数据库读取<strong>重要</strong>数据。相对于典型的用户登录系统，用户有可能被表示成一个钱包地址而其它用户数据保存在本地。许多事情都会与目前的web应用有不同架构。)</p><p>如果想看看从另一个新手视角怎么理解这些概念，请读<a href="https://medium.com/@user1/time-sure-does-fly-ed4518792679" target="_blank" rel="noopener">Just Enough Bitcoin for Ethereum</a>。</p><h3 id="以太坊客户端，智能合约语言"><a href="#以太坊客户端，智能合约语言" class="headerlink" title="以太坊客户端，智能合约语言"></a>以太坊客户端，智能合约语言</h3><p>编写和部署智能合约并不要求你运行一个以太坊节点。下面有列出<a href="#browser_ides">基于浏览器的IDE和API</a>。但如果是为了学习的话，还是应该运行一个以太坊节点，以便理解其中的基本组件，何况运行节点也不难。</p><h4 id="运行以太坊节点可用的客户端"><a href="#运行以太坊节点可用的客户端" class="headerlink" title="运行以太坊节点可用的客户端"></a>运行以太坊节点可用的客户端</h4><p>以太坊有许多不同语言的客户端实现（即多种与以太坊网络交互的方法），包括C++, Go, Python, Java, Haskell等等。为什么需要这么多实现？不同的实现能满足不同的需求（例如Haskell实现的目标是可以被数学验证），能使以太坊更加安全，能丰富整个生态系统。</p><p>在写作本文时，我使用的是Go语言实现的客户端geth (<a href="http://ethereum.github.io/go-ethereum/" target="_blank" rel="noopener">go-ethereum</a>)，其他时候还会使用一个叫testrpc的工具, 它使用了Python客户端<a href="https://github.com/ethereum/pyethereum" target="_blank" rel="noopener">pyethereum</a>。后面的例子会用到这些工具。</p><p>注: 我曾经使用过C++的客户端，现在仍然在用其中的ethminer组件和geth配合挖矿，因此这些不同的组件是可以一起工作的。<br>关于挖矿：挖矿很有趣，有点像精心照料你的室内盆栽，同时又是一种了解整个系统的方法。虽然以太币现在的价格可能连电费都补不齐，但以后谁知道呢。人们正在创造许多酷酷的DApp, 可能会让以太坊越来越流行。</p><p><strong>交互式控制台。</strong> 客户端运行起来后，你就可以同步区块链，建立钱包，收发以太币了。使用geth的一种方式是通过<a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console" target="_blank" rel="noopener">Javascript控制台</a>（JavaScript console, 类似你在chrome浏览器里面按F12出来的那个，只不过是跑在终端里）。此外还可以使用类似cURL的命令通过<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON RPC</a>来与客户端交互。本文的目标是带大家过一边DApp开发的流程，因此这块就不多说了。但是我们应该记住这些命令行工具是调试，配置节点，以及使用钱包的利器。</p><p><strong>在测试网络运行节点。</strong> 如果你在正式网络运行geth客户端，下载整个区块链与网络同步会需要相当时间。（你可以通过比较节点日志中打印的最后一个块号和<a href="http://stats.ethdev.com" target="_blank" rel="noopener">stats.ethdev.com</a>上列出的最新块来确定是否已经同步。) 另一个问题是在正式网络上跑智能合约需要实实在在的以太币。在测试网络上运行节点的话就没有这个问题。此时也不需要同步整个区块链，创建一个自己的私有链就勾了，对于开发来说更省时间。</p><p><strong>testrpc。</strong> 用geth可以创建一个测试网络，另一种更快的创建测试网络的方法是使用testrpc。Testrpc可以在启动时帮你创建一堆存有资金的测试账户。它的运行速度也更快因此更适合开发和测试。你可以从testrpc起步，然后随着合约慢慢成型，转移到geth创建的测试网络上 - 启动方法很简单，只需要指定一个networkid：<code>geth --networkid &quot;12345&quot;</code>。这里是<a href="https://github.com/ConsenSys/eth-testrpc" target="_blank" rel="noopener">testrpc的代码仓库</a>，下文我们还会再讲到它。</p><p>接下来我们来谈谈可用的编程语言，之后就可以开始真正的编程了。</p><h4 id="写智能合约用的编程语言"><a href="#写智能合约用的编程语言" class="headerlink" title="写智能合约用的编程语言"></a>写智能合约用的编程语言</h4><p><strong>用Solidity就好。</strong> 要写智能合约有好几种语言可选：有点类似Javascript的Solidity, 文件扩展名是<code>.sol</code>和Python接近的Serpent, 文件名以<code>.se</code>结尾。还有类似Lisp的LLL。Serpent曾经流行过一段时间，但现在最流行而且最稳定的要算是Solidity了，因此用Solidity就好。听说你喜欢Python? 用Solidity。</p><p><strong>solc编译器。</strong> 用Solidity写好智能合约之后，需要用solc来编译。它是一个来自C++客户端实现的组件（又一次，不同的实现产生互补），<a href="https://github.com/ethereum/webthree-umbrella/wiki" target="_blank" rel="noopener">这里</a>是安装方法。如果你不想安装solc也可以直接使用基于浏览器的编译器，例如<a href="https://chriseth.github.io/browser-solidity/" target="_blank" rel="noopener">Solidity real-time compiler</a>或者<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo</a>。后文有关编程的部分会假设你安装了solc。</p><p>注意：以太坊正处于积极的开发中，有时候新的版本之间会有不同步。确认你使用的是最新的dev版本，或者稳定版本。如果遇到问题可以去以太坊项目对应的Gitter聊天室或者<a href="http://forums.ethereum.org" target="_blank" rel="noopener">forums.ethereum.org</a>上问问其他人在用什么版本。</p><p><strong>web3.js API。</strong> 当Solidity合约编译好并且发送到网络上之后，你可以使用以太坊的<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API" target="_blank" rel="noopener">web3.js JavaScript API</a>来调用它，构建能与之交互的web应用。</p><p>以上就是在以太坊上编写智能合约和构建与之交互的DApp所需的基本工具。</p><h2 id="第二部分-DApp框架，工具以及工作流程"><a href="#第二部分-DApp框架，工具以及工作流程" class="headerlink" title="第二部分 DApp框架，工具以及工作流程"></a>第二部分 DApp框架，工具以及工作流程</h2><h3 id="DApp开发框架"><a href="#DApp开发框架" class="headerlink" title="DApp开发框架"></a>DApp开发框架</h3><p>虽然有上文提到的工具就可以进行开发了，但是使用社区大神们创造的框架会让开发更容易。</p><p><strong>Truffle and Embark。</strong> 是<a href="https://github.com/ConsenSys/truffle" target="_blank" rel="noopener">Truffle</a>把我领进了门。在Truffle出现之前的那个夏天，我目睹了一帮有天分的学生是如何不眠不休的参加一个hackathon（编程马拉松）活动的，虽然<a href="https://www.youtube.com/watch?v=TJBHTT88I8k" target="_blank" rel="noopener">结果相当不错</a>，但我还是吓到了。然后Truffle出现了，帮你处理掉大量无关紧要的小事情，让你可以迅速进入写代码-编译-部署-测试-打包DApp这个流程。另外一个相似的DApp构建与测试框架是<a href="https://iurimatias.github.io/embark-framework" target="_blank" rel="noopener">Embark</a>。我只用过Truffle, 但是两个阵营都拥有不少DApp大神。</p><p><strong>Meteor。</strong> 许多DApp开发者使用的另一套开发栈由web3.js和<a href="https://www.meteor.com/" target="_blank" rel="noopener">Meteor</a>组成，Meteor是一套通用webapp开发框架（<a href="https://github.com/ethereum/meteor-dapp-wallet" target="_blank" rel="noopener">ethereum-meteor-wallet</a>项目提供了一个很棒的入门实例，而<a href="https://github.com/SilentCicero" target="_blank" rel="noopener">SilentCiero</a>正在构建大量Meteor与web3.js和DApp集成的模板）。我下载并运行过一些不错的DApp是以这种方式构造的。在11月9日至13日的<a href="http://consensys.github.io/developers/articles/101-noob-intro/devcon.ethereum.org" target="_blank" rel="noopener">以太坊开发者大会ÐΞVCON1</a>上将有一些有趣的讨论，是关于使用这些工具构建DApp以及相关最佳实践的（会议将会在<a href="https://www.youtube.com/channel/UC6rYoXJ_3BbPyWx_GQDDRRQ" target="_blank" rel="noopener">YouTube</a>上直播）。</p><p><strong>APIs。</strong> <a href="http://blockapps.net/" target="_blank" rel="noopener">BlockApps.net</a>打算提供一套RESTful API给DApp使用以免去开发者运行本地节点的麻烦，这个中心化服务是基于以太坊Haskell实现的。这与DApp的去中心化模型背道而驰，但是在本地无法运行以太坊节点的场合非常有用，比如在你希望只有浏览器或者使用移动设备的用户也能使用你的DApp的时候。BlockApps提供了一个命令行工具<a href="https://github.com/blockapps/bloc" target="_blank" rel="noopener">bloc</a>，注册一个开发者帐号之后就可以使用。</p><p>许多人担心需要运行以太坊节点才能使用DApp的话会把用户吓跑，其实包括BlockApps在内的许多工具都能解决这个问题。<a href="https://metamask.io/" target="_blank" rel="noopener">Metamask</a>允许你在浏览器里面使用以太坊的功能而无需节点，以太坊官方提供的AlethZero或者AlethOne是正在开发中有易用界面的客户端，ConsenSys正在打造一个轻钱包<a href="https://github.com/ConsenSys/eth-lightwallet" target="_blank" rel="noopener">LightWallet</a>，这些工具都会让DApp的使用变得更容易。<a href="https://github.com/ethereum/wiki/wiki/White-Paper#scalability" target="_blank" rel="noopener">轻客户端</a>和水平分片(sharding)也在计划和开发之中。这是一个能进化出混合架构的P2P生态系统。</p><h3 id="智能合约集成开发环境-IDE"><a href="#智能合约集成开发环境-IDE" class="headerlink" title="智能合约集成开发环境 (IDE)"></a>智能合约集成开发环境 (IDE)</h3><p><strong>IDE。</strong> 以太坊官方出品了用来编写智能合约的<a href="https://github.com/ethereum/wiki/wiki/Mix:-The-DApp-IDE" target="_blank" rel="noopener">Mix IDE</a>，我还没用过但会尽快一试。</p><p><strong>基于浏览器的IDE。</strong> <a href="https://chriseth.github.io/browser-solidity" target="_blank" rel="noopener">Solidity real-time compiler</a>和<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo</a>都可以让你快速开始在浏览器中编写智能合约。你甚至可以让这些工具使用你的本地节点，只要让本地节点开一个端口（注意安全！这些工具站点必须可信，而且千万不要把你的全部身家放在这样一个本地节点里面！<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo UI</a>上有如何使用geth做到这一点的指引）。在你的智能合约调试通过之后，可以用开发框架来给它添加用户界面和打包成DApp，这正是Truffle的工作，后面的编程章节会有详细讲解。</p><p><a href="http://frontier.ether.camp/" target="_blank" rel="noopener">Ether.Camp</a>正在开发另一个强大的企业级浏览器IDE。他们的IDE将支持沙盒测试网络，自动生成用于测试的用户界面（取代后文将展示的手动编写测试），以及一个测试交易浏览器<a href="http://test.ether.camp/" target="_blank" rel="noopener">test.ether.camp</a>。当你的合约准备正式上线之前，使用他们的测试网络会是确保你的智能合约在一个接近真实的环境工作正常的好方法。他们也为正式网络提供了一个交易浏览器<a href="http://frontier.ether.camp/" target="_blank" rel="noopener">frontier.ether.camp</a>，上面可以看到每一笔交易的细节。在本文写作时Ether.Camp的IDE还只能通过邀请注册，预计很快会正式发布。</p><p><strong>合约和Dapp示例。</strong> 在Github上搜索DApp仓库和.sol文件可以看到进行中的有趣东西。这里有一个DApp大列表：<a href="http://dapps.ethercasts.com/" target="_blank" rel="noopener">dapps.ethercasts.com</a>，不过其中一些项目已经过时。<a href="http://ether.fund/contracts" target="_blank" rel="noopener">Ether.fund/contracts</a>上有一些Solidity和Serpent写的合约示例，但是不清楚这些例子有没有经过测试或者正确性验证。11月12日的<a href="https://devcon.ethereum.org/" target="_blank" rel="noopener">开发者大会ÐΞVCON1</a>将会有一整天的DApp主题演讲。</p><h3 id="部署智能合约的流程"><a href="#部署智能合约的流程" class="headerlink" title="部署智能合约的流程"></a>部署智能合约的流程</h3><p>流程如下：</p><ol><li>启动一个<strong>以太坊节点</strong> (例如geth或者testrpc)。</li><li>使用solc<em>_编译_</em>智能合约。 =&gt; 获得二进制代码。</li><li>将编译好的合约<strong>部署</strong>到网络。（这一步会消耗以太币，还需要使用你的节点的默认地址或者指定地址来给合约签名。） =&gt; 获得合约的区块链地址和ABI（合约接口的JSON表示，包括变量，事件和可以调用的方法）。(译注：作者在这里把ABI与合约接口弄混了。ABI是合约接口的二进制表示。)</li><li>用web3.js提供的JavaScript API来<strong>调用</strong>合约。（根据调用的类型有可能会消耗以太币。）</li></ol><p>下图详细描绘了这个流程：</p><p><img src="https://ethfans.org/uploads/photo/2015/1fc96327c8a1d60c8dc16f8ec1a2fe5d.png" alt="这里写图片描述"></p><p>你的DApp可以给用户提供一个界面先部署所需合约再使用之（如图1到4步），也可以假设合约已经部署了（常见方法），直接从使用合约（如图第6步）的界面开始。</p><h2 id="第三部分-编程"><a href="#第三部分-编程" class="headerlink" title="第三部分 编程"></a>第三部分 编程</h2><h3 id="在Truffle中进行测试"><a href="#在Truffle中进行测试" class="headerlink" title="在Truffle中进行测试"></a>在Truffle中进行测试</h3><p><a href="https://github.com/consensys/truffle" target="_blank" rel="noopener">Truffle</a>用来做智能合约的测试驱动开发(TDD)非常棒，我强烈推荐你在学习中使用它。它也是学习使用JavaScript Promise的一个好途径，例如deferred和异步调用。Promise机制有点像是说“做这件事，如果结果是这样，做甲，如果结果是那样，做乙… 与此同时不要在那儿干等着结果返回，行不？”。Truffle使用了包装web3.js的一个JS Promise框架<a href="https://github.com/ConsenSys/ether-pudding" target="_blank" rel="noopener">Pudding</a>（因此它为为你安装web3.js）。(译注：Promise是流行于JavaScript社区中的一种异步调用模式。它很好的封装了异步调用，使其能够灵活组合，而不会陷入callback hell.)</p><p><strong>Transaction times。</strong> Promise对于DApp非常有用，因为交易写入以太坊区块链需要大约12-15秒的时间。即使在测试网络上看起来没有那么慢，在正式网络上却可能会要更长的时间（例如你的交易可能用光了Gas，或者被写入了一个孤儿块）。</p><p>下面让我们给一个简单的智能合约写测试用例吧。</p><h3 id="使用Truffle"><a href="#使用Truffle" class="headerlink" title="使用Truffle"></a>使用Truffle</h3><p>首先确保你 1.安装好了<a href="https://github.com/ethereum/webthree-umbrella/wiki" target="_blank" rel="noopener">solc</a>以及 2.<a href="https://github.com/ConsenSys/eth-testrpc" target="_blank" rel="noopener">testrpc</a>。（testrpc需要<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python</a>和<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip</a>。如果你是Python新手，你可能需要用<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" target="_blank" rel="noopener">virtualenv</a>来安装，这可以将Python程序库安装在一个独立的环境中。）</p><p>接下来安装 3.<a href="https://github.com/ConsenSys/truffle" target="_blank" rel="noopener">Truffle</a>（你可以使用<a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" rel="noopener">NodeJS’s npm</a>来安装：<code>npm install -g truffle</code>, <code>-g</code>开关可能会需要sudo）。安装好之后，在命令行中输入<code>truffle list</code>来验证安装成功。然后创建一个新的项目目录（我把它命名为’conference’），进入这个目录，运行<code>truffle init</code>。该命令会建立如下的目录结构：</p><p><img src="https://ethfans.org/uploads/photo/2015/57b9fb67369c190fa455766ab5f6556f.png" alt="这里写图片描述"></p><p>现在让我们在<strong>另一个终端</strong>里通过执行<code>testrpc</code>来启动一个节点（你也可以用geth）：</p><p><img src="https://ethfans.org/uploads/photo/2015/a7d19ebfb8d027b65384c532770b3ba8.png" alt="这里写图片描述"></p><p>回到之前的终端中，输入<code>truffle deploy</code>。这条命令会部署之前<code>truffle init</code>产生的模板合约到网络上。任何你可能遇到的错误信息都会在testrpc的终端或者执行truffle的终端中输出。</p><p>在开发过程中你随时可以使用<code>truffle compile</code>命令来确认你的合约可以正常编译（或者使用<code>solc YourContract.sol</code>），<code>truffle deploy</code>来编译和部署合约，最后是<code>truffle test</code>来运行智能合约的测试用例。</p><h3 id="第一个合约"><a href="#第一个合约" class="headerlink" title="第一个合约"></a>第一个合约</h3><p>下面是一个针对会议的智能合约，通过它参会者可以买票，组织者可以设置参会人数上限，以及退款策略。本文涉及的所有代码都可以在这个<a href="https://github.com/eshon/conference" target="_blank" rel="noopener">代码仓库</a>找到。</p><pre><code>contract Conference {  address public organizer;  mapping (address =&gt; uint) public registrantsPaid;  uint public numRegistrants;  uint public quota;  event Deposit(address _from, uint _amount);  // so you can log these events  event Refund(address _to, uint _amount);   function Conference() { // Constructor    organizer = msg.sender;    quota = 500;    numRegistrants = 0;  }  function buyTicket() public returns (bool success) {    if (numRegistrants &gt;= quota) { return false; }    registrantsPaid[msg.sender] = msg.value;    numRegistrants++;    Deposit(msg.sender, msg.value);    return true;  }  function changeQuota(uint newquota) public {    if (msg.sender != organizer) { return; }    quota = newquota;  }  function refundTicket(address recipient, uint amount) public {    if (msg.sender != organizer) { return; }    if (registrantsPaid[recipient] == amount) {       address myAddress = this;      if (myAddress.balance &gt;= amount) {         recipient.send(amount);        registrantsPaid[recipient] = 0;        numRegistrants--;        Refund(recipient, amount);      }    }  }  function destroy() { // so funds not locked in contract forever    if (msg.sender == organizer) {       suicide(organizer); // send funds to organizer    }  }}</code></pre><p>接下来让我们部署这个合约。（注意：本文写作时我使用的是Mac OS X 10.10.5, solc 0.1.3+ (通过brew安装)，Truffle v0.2.3, testrpc v0.1.18 (使用venv)）</p><h3 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h3><p><img src="https://ethfans.org/uploads/photo/2015/93ece58476d59db60d3c60657d5baa2d.png" alt="这里写图片描述"></p><p>(译注：图中步骤翻译如下：）</p><p>使用truffle部署智能合约的步骤：<br>1. <code>truffle init</code> (在新目录中) =&gt; 创建truffle项目目录结构<br>2. 编写合约代码，保存到<code>contracts/YourContractName.sol</code>文件。<br>3. 把合约名字加到<code>config/app.json</code>的’contracts’部分。<br>4. 启动以太坊节点（例如在另一个终端里面运行<code>testrpc</code>）。<br>5. <code>truffle deploy</code>（在truffle项目目录中)</p><p><strong>添加一个智能合约。</strong> 在<code>truffle init</code>执行后或是一个现有的项目目录中，复制粘帖上面的会议合约到<code>contracts/Conference.sol</code>文件中。然后打开<code>config/app.json</code>文件，把’Conference’加入’deploy’数组中。</p><p><img src="https://ethfans.org/uploads/photo/2015/62922e726f12f928492d4a647951f72c.png" alt=""></p><p><strong>启动testrpc。</strong> 在另一个终端中启动<code>testrpc</code>。</p><p><strong>编译或部署。</strong> 执行<code>truffle compile</code>看一下合约是否能成功编译，或者直接<code>truffle deploy</code>一步完成编译和部署。这条命令会把部署好的合约的地址和ABI（应用接口）加入到配置文件中，这样之后的<code>truffle test</code>和<code>truffle build</code>步骤可以使用这些信息。</p><p><strong>出错了？</strong> 编译是否成功了？记住，错误信息即可能出现在testrpc终端也可能出现在truffle终端。</p><p><strong>重启节点后记得重新部署！</strong> 如果你停止了testrpc节点，下一次使用任何合约之前切记使用<code>truffle deploy</code>重新部署。testrpc在每一次重启之后都会回到完全空白的状态。</p><h3 id="合约代码解读"><a href="#合约代码解读" class="headerlink" title="合约代码解读"></a>合约代码解读</h3><p>让我们从智能合约头部的变量声明开始：</p><pre><code>address public organizer;mapping (address =&gt; uint) public registrantsPaid;uint public numRegistrants;uint public quota;</code></pre><p><strong>address。</strong> 地址类型。第一个变量是会议组织者的钱包地址。这个地址会在合约的构造函数<code>function Conference()</code>中被赋值。很多时候也称呼这种地址为’owner’（所有人）。</p><p><strong>uint。</strong> 无符号整型。区块链上的存储空间很紧张，保持数据尽可能的小。</p><p><strong>public。</strong> 这个关键字表明变量可以被合约之外的对象使用。<code>private</code>修饰符则表示变量只能被本合约(或者衍生合约)内的对象使用。如果你想要在测试中通过web3.js使用合约中的某个变量，记得把它声明为<code>public</code>。</p><p><strong>Mapping或数组。</strong>（译注：Mapping类似Hash, Directory等数据类型，不做翻译。）在Solidity加入数组类型之前，大家都使用类似<code>mapping (address =&gt; uint)</code>的Mapping类型。这个声明也可以写作<code>address registrantsPaid[]</code>，不过Mapping的存储占用更小(smaller footprint)。这个Mapping变量会用来保存参加者（用他们的钱包地址表示）的付款数量以便在退款时使用。</p><p><strong>关于地址。</strong> 你的客户端（比如testrpc或者geth）可以生成一个或多个账户/地址。testrpc启动时会显示10个可用地址：</p><p><img src="https://ethfans.org/uploads/photo/2015/26c59b073b0d405cd482e2690e47639a.png" alt=""></p><p>第一个地址, <code>accounts[0]</code>，是发起调用的默认地址，如果没有特别指定的话。</p><p><strong>组织者地址 vs 合约地址。</strong> 部署好的合约会在区块链上拥有自己的地址（与组织者拥有的是不同的地址）。在Solidity合约中可以使用<code>this</code>来访问这个合约地址，正如<code>refundTicket</code>函数所展示的：<code>address myAddress = this;</code></p><p><strong>Suicide, Solidity的好东西。</strong>（译注：<code>suicide</code>意为’自杀’, 为Solidity提供的关键字，不做翻译。）转给合约的资金会保存于合约（地址）中。最终这些资金通过<code>destroy</code>函数被释放给了构造函数中设置的组织者地址。这是通过<code>suicide(orgnizer);</code>这行代码实现的。没有这个，资金可能被永远锁定在合约之中（reddit上有些人就遇到过），因此如果你的合约会接受资金一定要记得在合约中使用这个方法！</p><p>如果想要模拟另一个用户或者对手方（例如你是卖家想要模拟一个买家），你可以使用可用地址数组中另外的地址。假设你要以另一个用户，<code>accounts[1]</code>, 的身份来买票，可以通过<code>from</code>参数设置：</p><pre><code>conference.buyTicket({ from: accounts[1], value: some_ticket_price_integer });</code></pre><p><strong>函数调用可以是交易。</strong> 改变合约状态（修改变量值，添加记录，等等）的函数调用本身也是转账交易，隐式的包含了发送人和交易价值。因此web3.js的函数调用可以通过指定<code>{ from: __, value: __ }</code>参数来发送以太币。在Solidity合约中，你可以通过<code>msg.sender</code>和<code>msg.value</code>来获取这些信息：</p><pre><code>function buyTicket() public {    ...    registrantsPaid[msg.sender] = msg.value;    ...}</code></pre><p><strong>事件(Event)。</strong> 可选的功能。合约中的<code>Deposit</code>（充值）和<code>Send</code>（发送）事件是会被记录在以太坊虚拟机日志中的数据。它们实际上没有任何作用，但是用事件(Event)把交易记录进日志是好的做法。</p><p>好了，现在让我们给这个智能合约写一个测试，来确保它能工作。</p><h3 id="写测试"><a href="#写测试" class="headerlink" title="写测试"></a>写测试</h3><p>把项目目录<code>test/</code>中的<code>example.js</code>文件重命名为<code>conference.js</code>，文件中所有的’Example’替换为’Conference’。</p><pre><code>contract(&apos;Conference&apos;, function(accounts) {  it(&quot;should assert true&quot;, function(done) {    var conference = Conference.at(Conference.deployed_address);    assert.isTrue(true);    done();   // stops tests at this point  });});</code></pre><p>在项目根目录下运行<code>truffle test</code>，你应该看到测试通过。在上面的测试中truffle通过<code>Conference.deployed_address</code>获得合约部署在区块链上的地址。</p><p>让我们写一个测试来初始化一个新的Conference，然后检查变量都正确赋值了。将<code>conference.js</code>中的测试代码替换为：</p><pre><code>contract(&apos;Conference&apos;, function(accounts) {  it(&quot;Initial conference settings should match&quot;, function(done) {    var conference = Conference.at(Conference.deployed_address);      // same as previous example up to here    Conference.new({ from: accounts[0]  })    .then(function(conference) {      conference.quota.call().then(          function(quota) {            assert.equal(quota, 500, &quot;Quota doesn&apos;t match!&quot;);           }).then( function() {            return conference.numRegistrants.call();          }).then( function(num) {            assert.equal(num, 0, &quot;Registrants should be zero!&quot;);            return conference.organizer.call();          }).then( function(organizer) {            assert.equal(organizer, accounts[0], &quot;Owner doesn&apos;t match!&quot;);            done();   // to stop these tests earlier, move this up        }).catch(done);      }).catch(done);    });  });</code></pre><p><strong>构造函数。</strong> <code>Conference.new({ from: accounts[0] })</code>通过调用合约构造函数创造了一个新的Conference实例。由于不指定<code>from</code>时会默认使用<code>accounts[0]</code>，它其实可以被省略掉：</p><pre><code>Conference.new({ from: accounts[0] }); // 和Conference.new()效果相同</code></pre><p><strong>Promise。</strong> 代码中的那些<code>then</code>和<code>return</code>就是Promise。它们的作用写成一个深深的嵌套调用链的话会是这样：</p><pre><code>conference.numRegistrants.call().then(  function(num) {    assert.equal(num, 0, &quot;Registrants should be zero!&quot;);    conference.organizer.call().then(     function(organizer) {        assert.equal(organizer, accounts[0], &quot;Owner doesn&apos;t match!&quot;);        }).then(          function(...))            }).then(              function(...))            // Because this would get hairy...</code></pre><p>Promise减少嵌套，使代码变得扁平，允许调用异步返回，并且简化了表达“成功时做这个”和“失败时做那个”的语法。Web3.js通过<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#using-callbacks" target="_blank" rel="noopener">回调函数</a>实现异步调用，因此你不需要等到交易完成就可以继续执行前端代码。Truffle借助了用Promise封装web3.js的一个框架，叫做<a href="https://github.com/ConsenSys/ether-pudding" target="_blank" rel="noopener">Pudding</a>，这个框架本身又是基于<a href="http://ricostacruz.com/cheatsheets/bluebird.html" target="_blank" rel="noopener">Bluebird</a>的，它支持Promise的高级特性。</p><p><strong>call。</strong> 我们使用<code>call</code>来检查变量的值，例如<code>conference.quota.call().then(...</code>，还可以通过传参数，例如<code>call(0)</code>, 来获取mapping在index 0处的元素。Solidity的文档说这是一种特殊的“消息调用”因为 1.不会为矿工记录和 2.不需要从钱包账户/地址发起（因此它没有被账户持有者私钥做签名）。另一方面，交易/事务(Transaction)会被矿工记录，必须来自于一个账户（也就是有签名），会被记录到区块链上。对合约中数据做的任何修改都是交易。仅仅是检查一个变量的值则不是。因此在读取变量时不要忘记加上<code>call()</code>！否则会发生奇怪的事情。（此外如果在读取变量是遇到问题别忘记检查它是否是<code>public</code>。）<code>call()</code>也能用于调用不是交易的函数。如果一个函数本来是交易，但你却用<code>call()</code>来调用，则不会在区块链上产生交易。</p><p><strong>断言。</strong> 标准JS测试中的断言（如果你不小心拼成了复数形式’asserts’，truffle会报错，让你一头雾水），<code>assert.equal</code>是最常用的，其他类型的断言可以在<a href="http://chaijs.com/api/assert/" target="_blank" rel="noopener">Chai的文档</a>中找到。</p><p>再一次运行<code>truffle test</code>确保一切工作正常。</p><h3 id="测试合约函数调用"><a href="#测试合约函数调用" class="headerlink" title="测试合约函数调用"></a>测试合约函数调用</h3><p>现在我们测试一下改变<code>quote</code>变量的函数能工作。在<code>tests/conference.js</code>文件的<code>contract(&#39;Conference&#39;, function(accounts) {...};)</code>的函数体中添加如下测试用例：</p><pre><code>it(&quot;Should update quota&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({from: accounts[0] }).then(    function(conference) {      conference.quota.call().then(         function(quota) {           assert.equal(quota, 500, &quot;Quota doesn&apos;t match!&quot;);         }).then( function() {           return conference.changeQuota(300);        }).then( function(result) {  // result here is a transaction hash          console.log(result);  // if you were to print this out it’d be long hex - the transaction hash          return conference.quota.call()        }).then( function(quota) {           assert.equal(quota, 300, &quot;New quota is not correct!&quot;);          done();        }).catch(done);    }).catch(done);});</code></pre><p>这里的新东西是调用<code>changeQuota</code>函数的那一行。<code>console.log</code>对于调试很有用，用它能在运行truffle的终端中输出信息。在关键点插入<code>console.log</code>可以查看执行到了哪一步。记得把Solidity合约中<code>changeQuota</code>函数被声明为<code>public</code>，否则你不能调用它：</p><pre><code>function changeQuota(uint newquota) public {  }</code></pre><h3 id="测试交易"><a href="#测试交易" class="headerlink" title="测试交易"></a>测试交易</h3><p>现在让我们调用一个需要发起人发送资金的函数。</p><p><strong>Wei。</strong> 以太币有很多种单位（这里有个很有用的<a href="http://ether.fund/tool/converter" target="_blank" rel="noopener">转换器</a>）,在合约中通常用的是Wei，最小的单位。Web3.js提供了在各单位与Wei之间互相转换的便利方法，形如<code>web3.toWei(.05, &#39;ether&#39;)</code>。JavaScript在处理很大的数字时有问题，因此web3.js使用了<a href="https://github.com/MikeMcl/bignumber.js/" target="_blank" rel="noopener">程序库BigNumber</a>，并建议在代码各处都以Wei做单位，直到要给用户看的时候（<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#a-note-on-big-numbers-in-web3js" target="_blank" rel="noopener">文档</a>。</p><p><strong>账户余额。</strong> Web3.js提供了许多提供方便的<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3-javascript-%C3%90app-api-reference" target="_blank" rel="noopener">方法</a>，其中另一个会在下面测试用到的是<code>web3.eth.getBalance(some_address)</code>。记住发送给合约的资金会由合约自己持有直到调用<code>suicide</code>。</p><p>在<code>contract(Conference, function(accounts) {...};)</code>的函数体中插入下面的测试用例。在高亮显示的方法中，测试用例让另一个用户(<code>accounts[1]</code>)以<code>ticketPrice</code>的价格买了一张门票。然后它检查合约的账户余额增加了<code>ticketPrice</code>，以及购票用户被加入了参会者列表。</p><p>这个测试中的<code>buyTicket</code>是一个交易函数：</p><pre><code>it(&quot;Should let you buy a ticket&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {      var ticketPrice = web3.toWei(.05, &apos;ether&apos;);      var initialBalance = web3.eth.getBalance(conference.address).toNumber();      conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(        function() {          var newBalance = web3.eth.getBalance(conference.address).toNumber();          var difference = newBalance - initialBalance;          assert.equal(difference, ticketPrice, &quot;Difference should be what was sent&quot;);          return conference.numRegistrants.call();      }).then(function(num) {          assert.equal(num, 1, &quot;there should be 1 registrant&quot;);          return conference.registrantsPaid.call(accounts[1]);      }).then(function(amount) {          assert.equal(amount.toNumber(), ticketPrice, &quot;Sender&apos;s paid but is not listed&quot;);          done();      }).catch(done);  }).catch(done);});</code></pre><p><strong>交易需要签名。</strong> 和之前的函数调用不同，这个调用是一个会发送资金的交易，在这种情况下购票用户(<code>accounts[1]</code>)会用他的私钥对<code>buyTicket()</code>调用做签名。（在geth中用户需要在发送资金之前通过输入密码来批准这个交易或是解锁钱包的账户。）</p><p><strong>toNumber()。</strong> 有时我们需要把Solidity返回的十六进制结果转码。如果结果可能是个很大的数字可以用<code>web3.toBigNumber(numberOrHexString)</code>来处理因为JavaScript直接对付大数要糟。</p><h3 id="测试包含转账的合约"><a href="#测试包含转账的合约" class="headerlink" title="测试包含转账的合约"></a>测试包含转账的合约</h3><p>最后，为了完整性，我们确认一下<code>refundTicket</code>方法能正常工作，而且只有会议组织者能调用。下面是测试用例：</p><pre><code>it(&quot;Should issue a refund by owner only&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {      var ticketPrice = web3.toWei(.05, &apos;ether&apos;);      var initialBalance = web3.eth.getBalance(conference.address).toNumber();       conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(        function() {          var newBalance = web3.eth.getBalance(conference.address).toNumber();          var difference = newBalance - initialBalance;          assert.equal(difference, ticketPrice, &quot;Difference should be what was sent&quot;);  // same as before up to here          // Now try to issue refund as second user - should fail          return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[1]});          }).then(          function() {            var balance = web3.eth.getBalance(conference.address).toNumber();            assert.equal(web3.toBigNumber(balance), ticketPrice, &quot;Balance should be unchanged&quot;);            // Now try to issue refund as organizer/owner - should work            return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[0]});          }).then(          function() {            var postRefundBalance = web3.eth.getBalance(conference.address).toNumber();            assert.equal(postRefundBalance, initialBalance, &quot;Balance should be initial balance&quot;);            done();        }).catch(done);    }).catch(done); });</code></pre><p>这个测试用例覆盖的Solidity函数如下：</p><pre><code>function refundTicket(address recipient, uint amount) public returns (bool success) {  if (msg.sender != organizer) { return false; }  if (registrantsPaid[recipient] == amount) {     address myAddress = this;    if (myAddress.balance &gt;= amount) {       recipient.send(amount);      Refund(recipient, amount);      registrantsPaid[recipient] = 0;      numRegistrants--;      return true;    }  }  return false;}</code></pre><p><strong>合约中发送以太币。</strong> <code>address myAddress = this</code>展示了如何获取该会议合约实例的地址，以变接下来检查这个地址的余额（或者直接使用<code>this.balance</code>）。合约通过<code>recipient.send(amount)</code>方法把资金发回了购票人。</p><p><strong>交易无法返回结果给web3.js。</strong> 注意这一点！<code>refundTicket</code>函数会返回一个布尔值，但是这在测试中无法检查。因为这个方法是一个交易函数（会改变合约内数据或是发送以太币的调用），而web3.js得到的交易运行结果是一个交易哈希（如果打印出来是一个长长的十六进制/怪怪的字符串）。既然如此为什么还要让<code>refundTicket</code>返回一个值？因为在Solidity合约内可以读到这个返回值，例如当另一个合约调用<code>refundTicket()</code>的时候。也就是说Solidity合约可以读取交易运行的返回值，而web3.js不行。另一方面，在web3.js中你可以用事件机制（Event, 下文会解释）来监控交易运行，而合约不行。合约也无法通过<code>call()</code>来检查交易是否修改了合约内变量的值。</p><p><strong>关于sendTransaction()。</strong> 当你通过web3.js调用类似<code>buyTicket()</code>或者<code>refundTicket()</code>的交易函数时（使用<code>web3.eth.sendTransaction</code>），交易并不会立即执行。事实上交易会被提交到矿工网络中，交易代码直到其中一位矿工产生一个新区块把交易记录进区块链之后才执行。因此你必须等交易进入区块链并且同步回本地节点之后才能验证交易执行的结果。用testrpc的时候可能看上去是实时的，因为测试环境很快，但是正式网络会比较慢。</p><p><strong>事件/Event。</strong> 在web3.js中你应该监听<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">事件</a>而不是返回值。我们的智能合约示例定义了这些事件：</p><pre><code>event Deposit(address _from, uint _amount);event Refund(address _to, uint _amount);</code></pre><p>它们在<code>buyTicket()</code>和<code>refundTicket()</code>中被触发。触发时你可以在testrpc的输出中看到日志。要监听事件，你可以使用web.js监听器(listener)。在写本文时我还不能在truffle测试中记录事件，但是在应用中没问题：</p><pre><code>Conference.new({ from: accounts[0] }).then(  function(conference) {    var event = conference.allEvents().watch({}, &apos;&apos;); // or use conference.Deposit() or .Refund()    event.watch(function (error, result) {      if (error) {        console.log(&quot;Error: &quot; + error);      } else {        console.log(&quot;Event: &quot; + result.event);      }    });    // ...</code></pre><p><strong>过滤器/Filter。</strong> 监听所有事件可能会产生大量的轮询，作为替代可以使用过滤器。它们可以更灵活的开始或是停止对事件的监听。更多过滤器的信息可查看<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter" target="_blank" rel="noopener">Solidity文档</a>。</p><p>总的来说，使用事件和过滤器的组合比检查变量消耗的Gas更少，因而在验证正式网络的交易运行结果时非常有用。</p><p><strong>Gas。</strong> （译注：以太坊上的燃料，因为代码的执行必须消耗Gas。直译为汽油比较突兀，故保留原文做专有名词。）直到现在我们都没有涉及Gas的概念，因为在使用testrpc时通常不需要显式的设置。当你转向geth和正式网络时会需要。在交易函数调用中可以在<code>{from: __, value: __, gas: __}</code>对象内设置Gas参数。Web3.js提供了<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgasprice" target="_blank" rel="noopener"><code>web3.eth.gasPrice</code></a>调用来获取当前Gas的价格，Solidity编译器也提供了一个参数让你可以从命令行获取合约的Gas开销概要：<code>solc --gas YouContract.sol</code>。下面是<code>Conference.sol</code>的结果：</p><p><img src="https://ethfans.org/uploads/photo/2015/afa43126d926ed3db1915718900c69c7.png" alt=""></p><h3 id="为合约创建DApp界面"><a href="#为合约创建DApp界面" class="headerlink" title="为合约创建DApp界面"></a>为合约创建DApp界面</h3><p><em>下面的段落会假设你没有网页开发经验。</em></p><p>上面编写的测试用例用到的都是在前端界面中也可以用的方法。你可以把前端代码放到<code>app/</code>目录中，运行<code>truffle build</code>之后它们会和合约配置信息一起编译输出到<code>build/</code>目录。在开发时可以使用<code>truffle watch</code>命令在<code>app/</code>有任何变动时自动编译输出到<code>build/</code>目录。然后在浏览器中刷新页面即可看到<code>build/</code>目录中的最新内容。（<code>truffle serve</code>可以启动一个基于<code>build/</code>目录的网页服务器。）</p><p><code>app/</code>目录中有一些样板文件帮助你开始：</p><p><img src="https://ethfans.org/uploads/photo/2015/a6a8374e2ee98c702455fdfa93b5e117.png" alt=""></p><p><code>index.html</code>会加载<code>app.js</code>：</p><p><img src="https://ethfans.org/uploads/photo/2015/91153d00abd7361d997276e252a3ac75.png" alt=""></p><p>因此我们只需要添加代码到<code>app.js</code>就可以了。</p><p>默认的<code>app.js</code>会在浏览器的console(控制台)中输出一条”Hello from Truffle!”的日志。在项目根目录中运行<code>truffle watch</code>，然后在浏览器中打开<code>build/index.html</code>文件，再打开浏览器的console就可以看到。（大部分浏览器例如Chrome中，单击右键 -&gt; 选择Inspect Element然后切换到Console即可。）</p><p><img src="https://ethfans.org/uploads/photo/2015/18b1dd84faa4aa16a841f6fe7ab0093e.png" alt=""></p><p>在<code>app.js</code>中，添加一个在页面加载时会运行的<code>window.onload</code>调用。下面的代码会确认web3.js已经正常载入并显示所有可用的账户。（注意：你的testrpc节点应该保持运行。）</p><pre><code>window.onload = function() {  var accounts = web3.eth.accounts;  console.log(accounts);}</code></pre><p>看看你的浏览器console中看看是否打印出了一组账户地址。</p><p>现在你可以从<code>tests/conference.js</code>中复制一些代码过来（去掉只和测试有关的断言），将调用返回的结果输出到console中以确认代码能工作。下面是个例子：</p><pre><code>window.onload = function() {  var accounts = web3.eth.accounts;  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {    var ticketPrice = web3.toWei(.05, &apos;ether&apos;);    var initialBalance = web3.eth.getBalance(conference.address).toNumber();     console.log(&quot;The conference&apos;s initial balance is: &quot; + initialBalance);    conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(      function() {        var newBalance = web3.eth.getBalance(conference.address).toNumber();        console.log(&quot;After someone bought a ticket it&apos;s: &quot; + newBalance);        return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[0]});      }).then(        function() {            var balance = web3.eth.getBalance(conference.address).toNumber();          console.log(&quot;After a refund it&apos;s: &quot; + balance);      });  });};</code></pre><p>上面的代码应该输出如下：</p><p><img src="https://ethfans.org/uploads/photo/2015/f093c01e94c9d56b8f58202edb42a27e.png" alt=""></p><p>(console输出的warning信息可忽略。)</p><p>现在起你就可以使用你喜欢的任何前端工具，jQuery, ReactJS, Meteor, Ember, AngularJS，等等等等，在<code>app/</code>目录中构建可以与以太坊智能合约互动的DApp界面了！接下来我们给出一个极其简单基于jQuery的界面作为示例。</p><p><img src="https://ethfans.org/uploads/photo/2015/a85ed594ffaceef763fb249508d855eb.png" alt=""></p><p>这里是<a href="https://github.com/eshon/conference/blob/master/app/index.html" target="_blank" rel="noopener">index.html的代码</a>，这里是<a href="https://github.com/eshon/conference/blob/master/app/javascripts/app.js" target="_blank" rel="noopener">app.js的代码</a>。</p><p>通过界面测试了智能合约之后我意识到最好加入检查以保证相同的用户不能注册两次。另外由于现在是运行在testrpc节点上，速度很快，最好是切换到geth节点并确认交易过程依然能及时响应。否则的话界面上就应该显示提示信息并且在处理交易时禁用相关的按钮。</p><p><strong>尝试geth。</strong> 如果你使用<a href="https://github.com/ethereum/go-ethereum/" target="_blank" rel="noopener">geth</a>, 可以尝试以下面的命令启动 - 在我这儿(geth v1.2.3)工作的很好：</p><pre><code>build/bin/geth --rpc --rpcaddr=&quot;0.0.0.0&quot; --rpccorsdomain=&quot;*&quot; --mine --unlock=&apos;0 1&apos; --verbosity=5 --maxpeers=0 --minerthreads=&apos;4&apos;  --networkid &apos;12345&apos; --genesis test-genesis.json</code></pre><p>这条命令解锁了两个账户, <code>0</code>和<code>1</code>。1. 在geth控制台启动后你可能需要输入这两个账户的密码。2. 你需要在<a href="https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network#custom-networks" target="_blank" rel="noopener"><code>test-genesis.json</code></a>文件里面的’alloc’配置中加入你的这两个账户，并且给它们充足的资金。3. 最后，在创建合约实例时加上gas参数：</p><pre><code>Conference.new({from: accounts[0], gas: 3141592})</code></pre><p>然后把整个<code>truffle deploy</code>, <code>truffle build</code>流程重来一遍。</p><p><strong>教程中的代码。</strong> 在这篇基础教程中用到的所有代码都可以在这个<a href="https://github.com/eshon/conference" target="_blank" rel="noopener">代码仓库</a>中找到。</p><p><strong>自动为合约生成界面。</strong> <a href="https://github.com/SilentCicero" target="_blank" rel="noopener">SilentCicero</a>制作了一个叫做<a href="http://dapp-builder.meteor.com/" target="_blank" rel="noopener">DApp Builder</a>的工具，可以用Solidity合约自动生成HTML, jQuery和web.js的代码。这种模式也正在被越来越多的正在开发中的开发者工具采用。</p><p><strong>教程到此结束！</strong> 最后一章我们仅仅学习了一套工具集，主要是Truffle和testrpc. 要知道即使在ConsenSys内部，不同的开发者使用的工具和框架也不尽相同。你可能会发现更适合你的工具，这里所说的工具可能很快也会有改进。但是本文介绍的工作流程帮助我走上了DApp开发之路。</p><p>(⊙ω⊙) wonk wonk</p><p><em>感谢Joseph Chow的校阅和建议，Christian Lundkvist, Daniel Novy, Jim Berry, Peter Borah和Tim Coulter帮我修改文字和debug，以及Tim Coulter, Nchinda Nchinda和Mike Goldin对DApp前端步骤图提供的帮助。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链：教程 | 以太坊智能合约编程之菜鸟教程。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/categories/Blockchain/"/>
    
      <category term="以太坊" scheme="https://www.oxysun.cn/categories/Blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="智能合约" scheme="https://www.oxysun.cn/categories/Blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="区块链" scheme="https://www.oxysun.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://www.oxysun.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
</feed>
