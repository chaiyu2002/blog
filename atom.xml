<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT老兵驿站</title>
  
  <subtitle>一个IT老兵的驿站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.oxysun.cn/"/>
  <updated>2018-08-04T01:07:47.284Z</updated>
  <id>https://www.oxysun.cn/</id>
  
  <author>
    <name>荒于嬉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git：git-checkout的用法总结（2）</title>
    <link href="https://www.oxysun.cn/git/git-checkout-2.html"/>
    <id>https://www.oxysun.cn/git/git-checkout-2.html</id>
    <published>2018-08-04T01:00:00.000Z</published>
    <updated>2018-08-04T01:07:47.284Z</updated>
    
    <content type="html"><![CDATA[<p>Git的git-checkout的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结合前一篇文章，再认真总结一下<code>git-checkout</code>的用法，因为可能一次总结到不了位，那么就不怕啰嗦，不怕重复，多总结几次，这样可能会造成每篇文章内容之间的分布不是那么清晰，将来再做更好的整理吧，因为现在这种方式，对于当前的学习是有帮助的，是从浅入深的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-checkout - Switch branches or restore working tree files</span><br></pre></td></tr></table></figure><p>从上面可见，git checkout是用来切换分支或者回复工作目录的，看到这里，记住这一点，会有很大帮助。（备注：我发现，有的时候，学习的节奏放慢一些，反而其实是更有效率的，反而是更快的。多思考一些，记的更准确，因慢得快）</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout [-q] [-f] [-m] [&lt;branch&gt;]</span><br><span class="line">git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;]</span><br><span class="line">git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt;</span><br><span class="line">git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]</span><br><span class="line">git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</span><br><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br><span class="line">git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</span><br></pre></td></tr></table></figure><h3 id="用法1"><a href="#用法1" class="headerlink" title="用法1"></a>用法1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>用来切换到一个分支上。切换<code>index</code>和工作目录，还有<code>HEAD</code> 指针到这个分支上。本地发生的修改也会被保留。如果本地不存在这个分支而远程存在同名分支的话，则这个命令相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;]</span><br></pre></td></tr></table></figure><p><code>-b</code>表示创建新分支；如果分支存在的话，不进行任何处理。<br><code>-B</code> 在创建新分支的功能和<code>-b</code> 是一样的；但是，如果分支存在的话，它会重置<code>&lt;start_point&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Specifying -b causes a new branch to be created as if git-branch[1] were called and then checked out. In this case you can use the --track or --no-track options, which will be passed to git branch. As a convenience, --track without -b implies branch creation; see the description of --track below.</span><br><span class="line"></span><br><span class="line">If -B is given, &lt;new_branch&gt; is created if it doesn’t exist; otherwise, it is reset. This is the transactional equivalent of</span><br><span class="line"></span><br><span class="line">$ git branch -f &lt;branch&gt; [&lt;start point&gt;]</span><br><span class="line">$ git checkout &lt;branch&gt;</span><br><span class="line">that is to say, the branch is not reset/created unless &quot;git checkout&quot; is successful.</span><br></pre></td></tr></table></figure><p>这里涉及到<code>track</code> 和<code>&lt;start point&gt;</code>的概念。<br><code>track</code>表示的是远程仓库与之对应的分支，这个信息被称为<code>upstream</code>，上游，远程仓库的，是上游。本地的，是下游，有一个对应的关系。<code>track</code> 本意是轨迹、跟踪的意思，使用了<code>--track</code>或者<code>--no-track</code> 来设置这个，这个信息会传递给<code>git branch</code>。</p><h3 id="用法2"><a href="#用法2" class="headerlink" title="用法2"></a>用法2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --detach [&lt;branch&gt;]</span><br><span class="line">git checkout [--detach] &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>切换代码到某一个提交号或者分支上，并且分离了<code>HEAD</code>指针，指向了这个提交。这块有点复杂，还需要理解深度理解一下，这个可能要留到下一篇帖子来完成了，争取每天整理一些（2018-08-03）。</p><p>整理完成，可以参考<a href="https://www.oxysun.cn/git/git-DETACHED-HEAD.html">这里</a>（2018-08-04）。</p><h3 id="用法3"><a href="#用法3" class="headerlink" title="用法3"></a>用法3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br><span class="line">git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…​]</span><br></pre></td></tr></table></figure><p>从<code>index</code>或者<code>&lt;tree-ish&gt;</code> 检出代码来替换<code>&lt;pathspec&gt;</code> 处的代码。如果<code>&lt;tree-ish&gt;</code> 被指定了，那么<code>index</code>和工作空间的代码都会被更新。</p><blockquote><p>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using -f will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using –ours or –theirs. With -m, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</p></blockquote><p><code>index</code>区域可能还有一些没有<code>merge</code>的条目，因为之前有失败的<code>merge</code>。</p><p>后一种用法使用互动的方式来完成这个功能。</p><p>到此，这个命令的用法基本整理完，下一步，要实践一些实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git的git-checkout的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="checkout" scheme="https://www.oxysun.cn/tags/checkout/"/>
    
  </entry>
  
  <entry>
    <title>Git：DETACHED HEAD的概念</title>
    <link href="https://www.oxysun.cn/git/git-DETACHED-HEAD.html"/>
    <id>https://www.oxysun.cn/git/git-DETACHED-HEAD.html</id>
    <published>2018-08-03T13:58:00.000Z</published>
    <updated>2018-08-03T14:01:51.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-DETACHED-HEAD.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>Git：DETACHED HEAD的概念。<br><a id="more"></a></p><p>原帖收藏于IT老兵驿站，传递一个IT老兵凋零前的光和氧。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<code>git</code>使用的时候，经常会碰到<code>DETACHED HEAD</code>，在此总结一下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>HEAD normally refers to a named branch (e.g. master). Meanwhile, each branch refers to a specific commit. Let’s look at a repo with three commits, one of them tagged, and with branch master checked out:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   HEAD (refers to branch &apos;master&apos;)</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">a---b---c  branch &apos;master&apos; (refers to commit &apos;c&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>上面是一个常见的例子，三个提交，<code>HEAD</code>指针指向<code>c</code>，往往是这个分支上最后的提交。然后又进行了一次修改和提交，生成了<code>d</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ edit; git add; git commit</span><br><span class="line"></span><br><span class="line">       HEAD (refers to branch &apos;master&apos;)</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>这个时候我们需要重新检出<code>v2.0</code>版本（这种可能性是很大，经常容易出现的），如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout v2.0  # or</span><br><span class="line">$ git checkout master^^</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   HEAD (refers to commit &apos;b&apos;)</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>这个时候<code>HEAD</code>指针就指向了<code>b</code>，这就是<code>detached HEAD</code>状态，这意味着<code>HEAD</code>指向了某一个提交了，而不再指向当前分支的最后一个提交了。</p><p>然后我们又进行了一次提交，就会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ edit; git add; git commit</span><br><span class="line"></span><br><span class="line">     HEAD (refers to commit &apos;e&apos;)</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">      e</span><br><span class="line">     /</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>one more time，再来一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ edit; git add; git commit</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> HEAD (refers to commit &apos;f&apos;)</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line">      e---f</span><br><span class="line">     /</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>我们可以做任何正常的<code>git</code>操作，如果你想回到<code>master</code>分支，那么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line">       HEAD (refers to branch &apos;master&apos;)</span><br><span class="line">      e---f     |</span><br><span class="line">     /          v</span><br><span class="line">a---b---c---d  branch &apos;master&apos; (refers to commit &apos;d&apos;)</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">  tag &apos;v2.0&apos; (refers to commit &apos;b&apos;)</span><br></pre></td></tr></table></figure><p>这个时候要意识到没有指针指向<code>f</code>提交，最后<code>e</code>和<code>f</code> 都会被常规的Git垃圾回收所删除掉，除非我们创建一个指针，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b foo   (1)</span><br><span class="line">$ git branch foo        (2)</span><br><span class="line">$ git tag foo           (3)</span><br></pre></td></tr></table></figure><ol><li>创建了一个新的分支指向<code>f</code>，并且更新了<code>HEAD</code>指针，这样<code>HEAD</code>指针就不再是<code>detached</code>状态了</li><li>简单创建了一个新的分支指向<code>f</code>，这个时候<code>HEAD</code>指针仍然是<code>detached</code>状态。<br>3.创建了一个新<code>tag</code>，指向<code>f</code>，这个时候<code>HEAD</code>指针仍然是<code>detached</code>状态。</li></ol><p>If we have moved away from commit f, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which HEAD referred, we can use either of these commands:</p><p>如果<code>f</code>已经被移除了，我们首先需要恢复它的对象名，使用<code>git reflog</code>，然后我们创建一个指针指向它。例如，想看到<code>HEAD</code>之前的最后两个提交，我们可以使用下面的命令（二选一）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog -2 HEAD # or</span><br><span class="line">$ git log -g -2 HEAD</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇总结基本上还是以翻译为主，留了一个问题，就是<code>reflog</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-DETACHED-HEAD.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;Git：DETACHED HEAD的概念。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="DETACHED HEAD" scheme="https://www.oxysun.cn/tags/DETACHED-HEAD/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-tag的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-tag.html"/>
    <id>https://www.oxysun.cn/git/git-tag.html</id>
    <published>2018-08-01T08:23:00.000Z</published>
    <updated>2018-08-03T14:00:27.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-tag.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>Git：git-tag的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git的tag和SVN不一样，SVN的tag其实还是一个分支，Git的tag则真的是一个标签，是给某一个commit打上一个标签，这个说明了Linus的巧妙设计，那么，对这个tag做一个笔记。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>记录几个主要的命令，用于速查：<br><strong>实例：</strong>列显已有的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>只看某一个tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l &apos;v1.4.2.*&apos;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>新建含附注的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &apos;my version 1.4&apos;</span><br></pre></td></tr></table></figure><p><code>-a</code>相当于给标签起个名字，<code>-m</code>是写一些注释。</p><p><strong>实例：</strong>查看相应标签的版本信息，并连同显示打标签时的提交对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>签署标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong>轻量级标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong>验证标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -v v1.4.2.1</span><br></pre></td></tr></table></figure></p><p>这个功能的具体意义还没有搞明白。</p><p><strong>实例：</strong>后期加注标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure><p><strong>实例：</strong>推送某一标签到服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.5</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong>推送所有标签到服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-tag.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;Git：git-tag的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="git tag" scheme="https://www.oxysun.cn/tags/git-tag/"/>
    
      <category term="标签" scheme="https://www.oxysun.cn/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-reset的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-reset.html"/>
    <id>https://www.oxysun.cn/git/git-reset.html</id>
    <published>2018-07-31T09:23:00.000Z</published>
    <updated>2018-08-02T00:39:42.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-reset.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>Git：git-reset的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Git reset</code>感觉是相当复杂的一个指令，用了快一年了，总感觉还没有用明白，所以，需要好好总结一下。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</span><br><span class="line">git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</span><br><span class="line">git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>In the first and second form, copy entries from <tree-ish> to the index. In the third form, set the current branch head (HEAD) to <commit>, optionally modifying index and working tree to match. The <tree-ish>/<commit> defaults to HEAD in all forms.</commit></tree-ish></commit></tree-ish></p></blockquote><p>这个命令有三种用法，前两种用来从<code>&lt;tree-ish&gt;</code>所指定的地方拷贝条目到index（其实是说从仓库的某一个版本获取到<code>index</code>区域）。第三种格式，将当前分支的<code>HEAD</code>指针设定为<code>&lt;commit&gt;</code> 这个提交号，同时可以选择性地修改<code>index</code>和工作区域。</p><p><code>tree-ish</code>是什么意思呢？要参考<a href="https://stackoverflow.com/questions/4044368/what-does-tree-ish-mean-in-git" target="_blank" rel="noopener">这里</a>，是Git所使用的指明路径的语法。类似以下这样的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;rev&gt;:&lt;path&gt;, e.g. HEAD:README, :README, master:./README</span><br><span class="line"></span><br><span class="line">A suffix : followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon.</span><br></pre></td></tr></table></figure><p><strong>备注：</strong>但是感觉这里这个解释放在这里不是很准确，这里的<code>&lt;tree-ish&gt;</code> 似乎是指类似<code>HEAD</code>、<code>master~3</code>、<code>&lt;sha1&gt;</code> 而不包含冒号以及后面的部分。</p><h2 id="用法1"><a href="#用法1" class="headerlink" title="用法1"></a>用法1</h2><p><code>git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</code></p><blockquote><p>This form resets the index entries for all <paths> to their state at <tree-ish>. (It does not affect the working tree or the current branch.)</tree-ish></paths></p></blockquote><blockquote><p>This means that git reset <paths> is the opposite of git add <paths>.</paths></paths></p></blockquote><blockquote><p>After running git reset <paths> to update the index entry, you can use git-checkout[1] to check the contents out of the index to the working tree. Alternatively, using git-checkout[1] and specifying a commit, you can copy the contents of a path out of a commit to the index and to the working tree in one go.</paths></p></blockquote><p>这个用法将<code>index</code>区域所有符合<paths>的条目修改为<code>&lt;tree-ish&gt;</code> 的状态。（这并不影响工作目录或者当前分支。）<br>这个<code>reset</code>是更新<code>index</code>条目，更新后，可以从<code>index</code>中通过<code>checkout</code>指令获取内容到工作目录。如果<code>git checkout</code>指定了一个提交号，那么就可以根据这个提交号更新内容到<code>index</code>和工作目录。</paths></p><p>关于<code>ORIG_HEAD</code>的介绍：需要参考<a href="https://stackoverflow.com/questions/964876/head-and-orig-head-in-git" target="_blank" rel="noopener">这里</a>。</p><blockquote><p>HEAD is (direct or indirect, i.e. symbolic) reference to the current commit. It is a commit that you have checked in the working directory (unless you made some changes, or equivalent), and it is a commit on top of which “git commit” would make a new one. Usually HEAD is symbolic reference to some other named branch; this branch is currently checked out branch, or current branch. HEAD can also point directly to a commit; this state is called “detached HEAD”, and can be understood as being on unnamed, anonymous branch.</p></blockquote><blockquote><p>And @ alone is a shortcut for HEAD, since Git 1.8.5</p></blockquote><blockquote><p>ORIG_HEAD is previous state of HEAD, set by commands that have possibly dangerous behavior, to be easy to revert them. It is less useful now that Git has reflog: HEAD@{1} is roughly equivalent to ORIG_HEAD (HEAD@{1} is always last value of HEAD, ORIG_HEAD is last value of HEAD before dangerous operation).</p></blockquote><blockquote><p>For more information read git(1) manpage, Git User’s Manual, the Git Community Book and Git Glossary</p></blockquote><p><code>HEAD</code>是指当前分支上当前的提交号。<br><code>ORIG_HEAD</code> 是指上一个HEAD所指向的提交号。<br>这其实是两个指针，第二个指针的设计其实是为了做保护，一旦第一个指针被误操作了，还有机会去挽回。</p><p><strong>实例：</strong><br>将发生改变的文件 <code>_config.yml</code>加入<code>index</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add _config.yml</span><br></pre></td></tr></table></figure></p><p>这样<code>_config.yml</code> 文件就被加入到<code>index</code>区域中，显示成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   _config.yml</span><br></pre></td></tr></table></figure></p><p>撤销上面的操作，恢复<code>_config.yml</code>为版本库中的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset _config.yml</span><br></pre></td></tr></table></figure></p><p>这种用法相当于<code>&lt;tree-ish&gt;</code>的参数设置为<code>HEAD</code>。</p><h2 id="用法2"><a href="#用法2" class="headerlink" title="用法2"></a>用法2</h2><p><code>git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</code></p><blockquote><p>Interactively select hunks in the difference between the index and <tree-ish> (defaults to HEAD). The chosen hunks are applied in reverse to the index.</tree-ish></p></blockquote><blockquote><p>This means that git reset -p is the opposite of git add -p, i.e. you can use it to selectively reset hunks. See the “Interactive Mode” section of git-add[1] to learn how to operate the –patch mode.</p></blockquote><p>这个用法是以<code>patch</code> 的方式展示出来需要<code>reset</code>的代码， <code>git reset -p</code> 和<code>git add -p</code> 就是一对互为反向的操作，后者是把工作目录下变更的代码以<code>patch</code> 的方式展示出来，以互动的方式应用到<code>index</code>上，前者则是一个反向操作。</p><p><strong>实例：</strong><br>将发生改变的文件 <code>_config.yml</code>加入<code>index</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -p  _config.yml</span><br></pre></td></tr></table></figure></p><p>撤销上面的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset -p  _config.yml</span><br></pre></td></tr></table></figure></p><p>可以看到，这种用法相对上面那一种用法其实是增加了互动的提醒。</p><h2 id="用法3"><a href="#用法3" class="headerlink" title="用法3"></a>用法3</h2><p><code>git reset [&lt;mode&gt;] [&lt;commit&gt;]</code></p><p>This form resets the current branch head to <commit> and possibly updates the index (resetting it to the tree of <commit>) and the working tree depending on <mode>. If <mode> is omitted, defaults to “–mixed”. The <mode> must be one of the following:</mode></mode></mode></commit></commit></p><p>这个用法是用来设置当前的分支的<code>HEAD</code>指针，或者<code>index</code> 的指向当前版本的指针，或者工作空间指向当前版本的指针。</p><blockquote><p>–soft<br>Does not touch the index file or the working tree at all (but resets the head to <commit>, just like all modes do). This leaves all your changed files “Changes to be committed”, as git status would put it.</commit></p></blockquote><p><code>soft</code>参数用来设置<code>HEAD</code>指针。</p><blockquote><p>–mixed<br>Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.</p></blockquote><p><code>mixed</code>参数用来设置<code>index</code>指针，文件的修改仍然会被保留，但是没有纳入到<code>index</code>中。</p><blockquote><p>If -N is specified, removed paths are marked as intent-to-add (see git-add[1]).</p></blockquote><blockquote><p>–hard<br>Resets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded.</commit></p></blockquote><p><code>hard</code>重置<code>index</code>和工作区域，所有在这个<code>&lt;commit&gt;</code>之后的修改将被丢弃。</p><blockquote><p>–merge<br>Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted.</commit></commit></p></blockquote><blockquote><p>In other words, –merge does something like a git read-tree -u -m <commit>, but carries forward unmerged index entries.</commit></p></blockquote><p><code>merge</code>重置<code>index</code> ，并且更新那些工作区的文件（在<code>&lt;commit&gt;</code>和<code>HEAD</code>中不同的）。这个还需要进一步理解一下。</p><blockquote><p>–keep<br>Resets index entries and updates files in the working tree that are different between <commit> and HEAD. If a file that is different between <commit> and HEAD has local changes, reset is aborted.</commit></commit></p></blockquote><blockquote><p>If you want to undo a commit other than the latest on a branch, git-revert[1] is your friend.</p></blockquote><p><strong>实例</strong> 版本库中的提交如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">commit cac453cf6501c3ea3b626636bc4399ed48704543 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: xxx &lt;xxx@xxx.xxx&gt;</span><br><span class="line">Date:   Fri Jul 27 18:08:46 2018 +0800</span><br><span class="line"></span><br><span class="line">    从版本库中移除项目配置文件和日志配置文件</span><br><span class="line"></span><br><span class="line">commit cd36b7297106a871ae331f487179fd5584fb38cd</span><br><span class="line">Author: xxx &lt;xxx@xxx.xxx&gt;</span><br><span class="line">Date:   Fri Jul 27 18:06:37 2018 +0800</span><br><span class="line"></span><br><span class="line">    暂时参考原来的逻辑，使用硬编码的方式，新增了权限</span><br><span class="line"></span><br><span class="line">commit 24f19e80b5b8e2c05faf04706d95b5ac538ddbdd (f_1486)</span><br><span class="line">Author: xxx &lt;xxx@xxx.xxx&gt;</span><br><span class="line">Date:   Wed Jul 11 22:00:43 2018 +0800</span><br><span class="line"></span><br><span class="line">    修改了login的登录按钮的宽度</span><br><span class="line"></span><br><span class="line">commit e948bb044676ff917be862d9fae8391ba1b82351</span><br><span class="line">Author: xxx &lt;xxx@xxx.xxx&gt;</span><br><span class="line">Date:   Tue Jul 10 23:39:28 2018 +0800</span><br><span class="line"></span><br><span class="line">    完成初步的修改</span><br></pre></td></tr></table></figure></p><p>现在发现最后三次提交是存在问题的，不应该直接提交到<code>master</code>上，这个时候需要把<code>HEAD</code>指针恢复到倒数第四次提交上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft e948bb044676ff917be862d9fae8391ba1b82351</span><br></pre></td></tr></table></figure></p><p>这样后面三次提交的改变从版本库还原出来，变成尚未提交的状态，这样我们就可以新开一个临时的<code>dev</code>分支，继续我们之前的工作（参考Git Flow一篇文章）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-reset.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;Git：git-reset的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="git reset" scheme="https://www.oxysun.cn/tags/git-reset/"/>
    
  </entry>
  
  <entry>
    <title>区块链：比特币难度的概念</title>
    <link href="https://www.oxysun.cn/blockchain/bitcoin-difficulty.html"/>
    <id>https://www.oxysun.cn/blockchain/bitcoin-difficulty.html</id>
    <published>2018-07-30T08:46:00.000Z</published>
    <updated>2018-08-02T00:39:42.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/blockchain/bitcoin-difficulty.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>区块链：比特币难度的概念。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇笔记记录一下对于比特币难度的学习，参考<a href="https://en.bitcoin.it/wiki/Difficulty" target="_blank" rel="noopener">这里</a>，记录下来自己的理解，哩哩啦啦地写了两天，边看边查，还是没有理解到位，等待之后再补充吧。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>Difficulty is a measure of how difficult it is to find a hash below a given target.</p></blockquote><p><code>Difficulty</code> 是用来衡量找到一个低于给定目标的<code>hash</code>的困难程度。</p><h3 id="难度公式："><a href="#难度公式：" class="headerlink" title="难度公式："></a>难度公式：</h3><blockquote><p>difficulty = difficulty_1_target / current_target<br>(target is a 256 bit number)</p></blockquote><p>有许多不同测量难度的方法，得到的difficulty_1_target可能不同。传统地，它表示一个<code>HASH</code>值，前32位为0，后面都为1（也就是被称为“矿池难度”或“pdiff”的值），比特币协议把目标<code>HASH</code>表示成一个有限精度的自定义浮点类型。因而，比特币客户端用该值来估计难度(称之为：“bdiff”)。</p><h3 id="难度如何保存在区块上呢？"><a href="#难度如何保存在区块上呢？" class="headerlink" title="难度如何保存在区块上呢？"></a>难度如何保存在区块上呢？</h3><p>每一个区块会用一种压缩的格式（被称为“Bits”）来表示实际的16进制的目标值。目标值通过一个预先定义好的公式，从这个压缩值中得出。举一个例子，压缩值为<code>0x1b0404cb</code>，16进制的目标值则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><blockquote><p>Note that the 0x0404cb value is a signed value in this format. The largest legal value for this field is 0x7fffff. To make a larger value you must shift it down one full byte. Also 0x008000 is the smallest positive valid value.</p></blockquote><p>注意<code>0x0404cb</code> 是一个符号数，最大值是<code>0x7fffff</code>，这个明白，下面两句就不明白了：如果想生成一个更大的值，你需要向下移动一整个字节。同时，<code>0x008000</code> 是最小的正值（为什么不是<code>0x000001</code>呢？）。</p><h3 id="难度如何计算？"><a href="#难度如何计算？" class="headerlink" title="难度如何计算？"></a>难度如何计算？</h3><p>最大目标难度（1）被定义成<code>0x1d00ffff</code>， 那么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00ffff * 2**(8*(0x1d - 3)) = 0x00000000FFFF0000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>这个是截断后的目标值，就是上文所说的比特币协议定义的格式，如果没有截断，那么就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure><p>所以<code>0x1b0404cb</code> 位置的难度是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00000000FFFF0000000000000000000000000000000000000000000000000000 /</span><br><span class="line">0x00000000000404CB000000000000000000000000000000000000000000000000 </span><br><span class="line">= 16307.420938523983 (bdiff)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF /</span><br><span class="line">0x00000000000404CB000000000000000000000000000000000000000000000000 </span><br><span class="line">= 16307.669773817162 (pdiff)</span><br></pre></td></tr></table></figure><h3 id="当前难度是什么"><a href="#当前难度是什么" class="headerlink" title="当前难度是什么"></a>当前难度是什么</h3><p><a href="https://blockexplorer.com/api/status?q=getDifficulty" target="_blank" rel="noopener">Current difficulty</a>。这个是比特币浏览器提供的接口，给出了当前难度。</p><h3 id="什么是最大难度"><a href="#什么是最大难度" class="headerlink" title="什么是最大难度"></a>什么是最大难度</h3><blockquote><p>There is no minimum target. The maximum difficulty is roughly: maximum_target / 1 (since 0 would result in infinity), which is a ridiculously huge number (about 2^224).</p></blockquote><blockquote><p>The actual maximum difficulty is when current_target=0, but we would not be able to calculate the difficulty if that happened. (fortunately it never will, so we’re ok.)</p></blockquote><p>不存在最小的目标。最大难度可以粗暴地认为是：maximum_target / 1（因为0会产生无限值），这个数很大，大约是2的224次方。</p><h3 id="网络难度是否可以降低"><a href="#网络难度是否可以降低" class="headerlink" title="网络难度是否可以降低"></a>网络难度是否可以降低</h3><p>可以，参考上面的内容。</p><h3 id="最小难度是什么"><a href="#最小难度是什么" class="headerlink" title="最小难度是什么"></a>最小难度是什么</h3><blockquote><p>The minimum difficulty, when the target is at the maximum allowed value, is 1.</p></blockquote><p>当targe是最大允许值的时候，最小难度，也就是1。这里说的target应该是分母，分子的最大值是确定的，上文已经说过了。</p><h3 id="在给定难度的情况下，网络hash率是如何得出的"><a href="#在给定难度的情况下，网络hash率是如何得出的" class="headerlink" title="在给定难度的情况下，网络hash率是如何得出的"></a>在给定难度的情况下，网络hash率是如何得出的</h3><p>根据10分钟一块的平均速度，产生2016个块应该需要两周。每产生2016个块，会调整一下难度，根据之前产生这2016个块花费的时间，和理论上应该花费的时间–两周做一下对比。</p><p>难度为1时的目标值（上文提到的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xffff * 2**208</span><br></pre></td></tr></table></figure><p>难度为D时的目标值应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0xffff * 2**208) / D</span><br></pre></td></tr></table></figure><p>所需要的<code>hash</code>计算数（2**256是最大<code>hash</code>计算数，除以当前的目标值，也是一个256位的数，例如上面的<code>0x00000000000404CB000000000000000000000000000000000000000000000000</code> ，这个地方不是太理解，这样除，就可以算出总共需要的计算数？翻了一些帖子，还是没有找到答案）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D * 2**256 / (0xffff * 2**208)</span><br></pre></td></tr></table></figure></p><p>简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D * 2**48 / 0xffff</span><br></pre></td></tr></table></figure><p>以上是10分钟的<code>hash</code>数，<code>hash</code>率是以秒为单位的，所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D * 2**48 / 0xffff / 600</span><br></pre></td></tr></table></figure></p><p>最后简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D * 2**32 / 600</span><br></pre></td></tr></table></figure><p>如果难度为1的话，每秒钟7 Mhashes。<br>原文写作时，难度是 22012.4941572，那么过去2016个块的<code>hash</code>率是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22012.4941572 * 2**32 / 600 = around 157 Ghashes per second.</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.bitcoin.it/wiki/Difficulty。" target="_blank" rel="noopener">https://en.bitcoin.it/wiki/Difficulty。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/blockchain/bitcoin-difficulty.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;区块链：比特币难度的概念。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-branch的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-branch.html"/>
    <id>https://www.oxysun.cn/git/git-branch.html</id>
    <published>2018-07-30T03:37:00.000Z</published>
    <updated>2018-08-02T00:39:42.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"><a href="#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。" class="headerlink" title="原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。"></a>原帖收藏于<a href="https://www.oxysun.cn/git/git-branch.html">IT老兵驿站</a>，传递一个IT老兵在凋零前的光和氧。</h2><p>git-branch的用法总结。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>git branch的用法。这个命令使用频度很高，还有一些没有搞明白，在这里总结梳理一下。</p><p>PS：之前的文章题目命名都用空格，以前一直不理解git的官网为什么多加一个“-”，现在明白了，为了用作文章名和题目比较方便，解了一个惑。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git branch [--color[=&lt;when&gt;] | --no-color] [-r | -a] [--list] [-v [--abbrev=&lt;length&gt; | --no-abbrev]]</span><br><span class="line">[--column[=&lt;options&gt;] | --no-column] [--sort=&lt;key&gt;]</span><br><span class="line">[(--merged | --no-merged) [&lt;commit&gt;]]</span><br><span class="line">[--contains [&lt;commit]] [--no-contains [&lt;commit&gt;]]</span><br><span class="line">[--points-at &lt;object&gt;] [--format=&lt;format&gt;] [&lt;pattern&gt;…​] // 列出分支（这个用法有点复杂）</span><br><span class="line"></span><br><span class="line">git branch [--track | --no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;] // 设置分支本地和远程的关系（上流）</span><br><span class="line">git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;] // 设置分支上流</span><br><span class="line">git branch --unset-upstream [&lt;branchname&gt;] // 取消分支上流的设置</span><br><span class="line">git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt; // 重命名分支</span><br><span class="line">git branch (-c | -C) [&lt;oldbranch&gt;] &lt;newbranch&gt; // 拷贝分支</span><br><span class="line">git branch (-d | -D) [-r] &lt;branchname&gt;…​ // 删除分支</span><br><span class="line">git branch --edit-description [&lt;branchname&gt;] //修改分支描述</span><br></pre></td></tr></table></figure><p>git branch有以上这么多种用法，原本我看了几遍，也感觉云山雾绕，需要在上面加了一些备注。</p><h2 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h2><p><strong>实例：</strong> 展示分支<br>最简单的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p><p>较为详细的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">* master cac453c 从版本库中移除项目配置文件和日志配置文件</span><br></pre></td></tr></table></figure></p><p>可以看到，加了<code>-v</code>，显示出了提交号。</p><p>更为详细的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">* master cac453c [origin/master] 从版本库中移除项目配置文件和日志配置文件</span><br></pre></td></tr></table></figure></p><p>可以看到，加两个<code>v</code>，除了显示出了提交号，还显示出了上流分支（upstream）的名称。。</p><p><strong>实例：</strong> 查看所有分支（包括远程的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/f_1123</span><br><span class="line">  remotes/origin/f_1268</span><br><span class="line">  remotes/origin/f_1316</span><br><span class="line">  remotes/origin/f_1317</span><br><span class="line">  remotes/origin/f_1346</span><br><span class="line">  remotes/origin/f_1347</span><br><span class="line">  remotes/origin/f_1490</span><br><span class="line">  remotes/origin/f_english</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p><code>-a</code>就是<code>-all</code>的意思，显示所有。</p><p><strong>实例：</strong> 查看远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/dev</span><br><span class="line">  origin/f_1123</span><br><span class="line">  origin/f_1268</span><br><span class="line">  origin/f_1316</span><br><span class="line">  origin/f_1317</span><br><span class="line">  origin/f_1346</span><br><span class="line">  origin/f_1347</span><br><span class="line">  origin/f_1490</span><br><span class="line">  origin/f_english</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure><p>比上面那个指令少了一项<code>master</code>。<br><code>-r</code>的意思是<code>remote</code>，显示远程的分支情况。</p><p><strong>实例：</strong>修改分支名<br>把<code>master</code>分支名称修改成<code>dev</code>，这里仅仅是举一个例子，正常工作中一般是不应该发生这样的修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master dev</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong>删除分支<br>删除dev分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D dev</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/docs/git-branch。" target="_blank" rel="noopener">https://git-scm.com/docs/git-branch。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;a href=&quot;#原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot; class=&quot;headerlink&quot; title=&quot;原帖收藏于IT老兵驿站，传递一个IT老兵在凋零前的光和氧。&quot;&gt;&lt;/a&gt;原帖收藏于&lt;a href=&quot;https://www.oxysun.cn/git/git-branch.html&quot;&gt;IT老兵驿站&lt;/a&gt;，传递一个IT老兵在凋零前的光和氧。&lt;/h2&gt;&lt;p&gt;git-branch的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="git branch" scheme="https://www.oxysun.cn/tags/git-branch/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="分支" scheme="https://www.oxysun.cn/tags/%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java：“目标服务器没有返回一个X-Frame-Options头”的解决方案</title>
    <link href="https://www.oxysun.cn/java/java-springmvc-X-Frame-Options.html"/>
    <id>https://www.oxysun.cn/java/java-springmvc-X-Frame-Options.html</id>
    <published>2018-07-29T03:25:00.000Z</published>
    <updated>2018-08-02T00:39:42.489Z</updated>
    
    <content type="html"><![CDATA[<p>原帖位于<a href="https://www.oxysun.cn/java/java-springmvc-X-Frame-Options.html">IT老兵博客</a>，沉淀着一个IT老兵对于这个行业的认知。</p><p>Java：“目标服务器没有返回一个X-Frame-Options头”的解决方案。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在涉及网站安全时遇到一个问题（360网站安全测试也会报告），“目标服务器没有返回一个X-Frame-Options头”，找了网上的帖子，说的都不是太清楚，所以研究总结一下，方便后人。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>以下摘录一下对于安全网站这个问题的描述和建议解决方案：</p><blockquote><p>概要<br>目标服务器没有返回一个X-Frame-Options头。<br>攻击者可以使用一个透明的、不可见的iframe，覆盖在目标网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击iframe页面的一些功能性按钮上，导致被劫持。<br><br><br>解决方案<br>修改web服务器配置，添加X-frame-options响应头。赋值有如下三种：<br>（1）DENY：不能被嵌入到任何iframe或frame中。<br>（2）SAMEORIGIN：页面只能被本站页面嵌入到iframe或者frame中。<br>（3）ALLOW-FROM uri：只能被嵌入到指定域名的框架中。<br>也可在代码中加入，在PHP中加入：<br>header(‘X-Frame-Options: deny’);</p></blockquote><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>但是我们的环境是<code>Java</code>的<code>Springmvc</code>，这个应该怎么解决呢？其实<code>Spring</code>框架中的<code>security</code>本身有对这个问题的解决方案，但是这是之前的<code>Spring</code>框架中的（<code>SSH</code>那会的），现在用了<code>SpringMVC</code>了，应该怎么去解决这个问题呢？</p><p>参考<a href="https://blog.csdn.net/princeluan/article/details/73268637" target="_blank" rel="noopener">这里</a>，这里介绍说配置项目的web.xml文件如下，即可解决问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.apache.catalina.filters.HttpHeaderSecurityFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;antiClickJackingOption&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;SAMEORIGIN&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;async-supported&gt;true&lt;/async-supported&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><p>但是我这里又引出一个新的问题：</p><blockquote><p>cvc-complex-type.2.4.a: Invalid content was found starting with element ‘async-supported’. One of ‘{“<a href="http://java.sun.com/xml/ns/javaee&quot;:run-as" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee&quot;:run-as</a>, “<a href="http://java.sun.com/xml/ns/javaee&quot;:security-role-ref}&#39;" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee&quot;:security-role-ref}&#39;</a> is expected.</p></blockquote><p>意思是说<code>async-supported</code>这个元素不被识别。继续探索，找到<a href="https://blog.csdn.net/DouBoomFly/article/details/70200740" target="_blank" rel="noopener">这里</a>说的：</p><blockquote><p>xmlns中再加两行：<br><a href="http://www.springmodules.org/schema/cache/springmodules-cache.xsd" target="_blank" rel="noopener">http://www.springmodules.org/schema/cache/springmodules-cache.xsd</a><br><a href="http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd" target="_blank" rel="noopener">http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd</a></p></blockquote><p>要在web.xml顶部的<code>xmlns</code>里面再加两行，问题才真正得到了解决。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>问题是解决了，但是问题产生的原因和解决的方法又是什么呢？</p><p>###首先，这样设置web.xml的目的是什么？</p><p>找到<a href="https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html" target="_blank" rel="noopener"><code>Tomcat</code>官网</a>的讲解：</p><blockquote><p>org.apache.catalina.filters.HttpHeaderSecurityFilter .//过滤器的类名<br>……<br>antiClickJackingOption //参数配置，可以设置成DENY（拒绝），SAMEORIGIN（同源），ALLOW-FROM（允许从哪里来的）<br>What value should be used for the anticlick-jacking header? Must be one of DENY, SAMEORIGIN, ALLOW-FROM (case-insensitive). If not specified, the default value of DENY will be used.</p></blockquote><p>意思是说<code>HttpHeaderSecurityFilter</code> 这个过滤器是用来做<code>anticlick-jacking</code>（防止点击劫持，<code>Java</code>做<code>Web</code>服务的优越性就在这里，很多功能都已经做成了工具类，只需要配置一下即可）。三个配置选项，我们上文中配置成了SAMEORIGIN（同源），安全性就大大提高了。<br>那么，上面配置这个过滤器就搞明白了，那么后面出现的那个问题又是怎么回事呢？</p><h3 id="其次，web-xml的这个设置错误又是怎么回事？"><a href="#其次，web-xml的这个设置错误又是怎么回事？" class="headerlink" title="其次，web.xml的这个设置错误又是怎么回事？"></a>其次，web.xml的这个设置错误又是怎么回事？</h3><p>这里要研究一下这段语句的意思，在web.xml的头部，可能很多人总会看到它，但不会去思考它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app version=&quot;3.0&quot; </span><br><span class="line">    xmlns=&quot;http://java.sun.com/xml/ns/javaee </span><br><span class="line">    http://www.springmodules.org/schema/cache/springmodules-cache.xsd </span><br><span class="line">    http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee </span><br><span class="line">    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><code>xmlns</code>：<code>xml</code>的<code>namespace</code>，这个是为了解决多个开发者对于xml的命名会产生冲突的问题。<br><code>xmlns:xsi</code>：定义了<code>xml</code>的标准前缀。<br><code>xsi:schemaLocation</code>：<code>xml</code>的<code>schema</code>定义的位置。</p><p>简言之，<code>Java</code>对于<code>xml</code>的名值设置了一套定义规则，发布在上面的地方，我们上面使用的这个元素名<code>async-supported</code> ，在之前的<code>web.xml</code>中所定义的位置是没有找到的，加了那两行的命名空间的定义，才可以找到这个元素定义的位置。</p><p>至此，问题基本搞明白了。</p><p>参考<br><a href="https://www.w3schools.com/xml/schema_intro.asp。" target="_blank" rel="noopener">https://www.w3schools.com/xml/schema_intro.asp。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原帖位于&lt;a href=&quot;https://www.oxysun.cn/java/java-springmvc-X-Frame-Options.html&quot;&gt;IT老兵博客&lt;/a&gt;，沉淀着一个IT老兵对于这个行业的认知。&lt;/p&gt;
&lt;p&gt;Java：“目标服务器没有返回一个X-Frame-Options头”的解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.oxysun.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.oxysun.cn/tags/Java/"/>
    
      <category term="tomcat" scheme="https://www.oxysun.cn/tags/tomcat/"/>
    
      <category term="linux" scheme="https://www.oxysun.cn/tags/linux/"/>
    
      <category term="X-Frame-Options" scheme="https://www.oxysun.cn/tags/X-Frame-Options/"/>
    
  </entry>
  
  <entry>
    <title>Git：git diff发现windows下会出现&quot;^M&quot;符号</title>
    <link href="https://www.oxysun.cn/git/git-diff-m-symbol.html"/>
    <id>https://www.oxysun.cn/git/git-diff-m-symbol.html</id>
    <published>2018-07-28T13:53:00.000Z</published>
    <updated>2018-08-02T00:39:42.485Z</updated>
    
    <content type="html"><![CDATA[<p>原帖收藏于IT老兵驿站，传递一个IT老兵凋零前的光和氧。</p><p>Git：git diff发现windows下会出现”^M”符号。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在不同操作系统上编译Git仓库的文件，经常在<code>git diff</code> 时发现很多文件的变化是尾部多了一个<code>^M</code> 的符号。这给工作带来很多困扰，研究一下这个问题。</p><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><p>翻到这个<a href="https://stackoverflow.com/questions/1889559/git-diff-to-ignore-m" target="_blank" rel="noopener">帖子</a>：</p><blockquote><p><a href="https://help.github.com/articles/dealing-with-line-endings/" target="_blank" rel="noopener">GitHub</a> suggests that you should make sure to only use \n as a newline character in git-handled repos. There’s an option to auto-convert:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf true</span><br></pre></td></tr></table></figure><p>大体翻译：GitHub建议你应该只用<code>\n</code> 来做为新行的开始，用上面那样的设置就可以做到自动的转换，这样也就解决了问题，Git不会再报告差异。</p><p>那这是为什么呢？</p><p>阅读一下这里所介绍的这个帖子。</p><blockquote><p>If you’re using Git to collaborate with others on GitHub, ensure that Git is properly configured to handle line endings.</p></blockquote><blockquote><p>Every time you press return on your keyboard you’re actually inserting an invisible character called a line ending. Historically, different operating systems have handled line endings differently.</p></blockquote><blockquote><p>When you view changes in a file, Git handles line endings in its own way. Since you’re collaborating on projects with Git and GitHub, Git might produce unexpected results if, for example, you’re working on a Windows machine, and your collaborator has made a change in OS X.</p></blockquote><p>这里大概是说每个操作系统有自己的换行符（就是当你按下”回车”后，系统会自动插入一些不可见的符号来表示一行的结束），<code>Linux</code>和<code>Mac</code>都是使用<code>LF</code> ，<code>Windows</code> 则是<code>CRLF</code> ，这样就造成了差异。</p><p>Git会对此进行一些处理，但是做什么处理呢？这里没有说清楚，只是说要用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.autocrlf</span><br></pre></td></tr></table></figure><p>来控制，和上面说的是一样的，但是原理还是没有搞明白。</p><p>只好来看<a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">官网</a>。</p><blockquote><p>core.autocrlf<br>Setting this variable to “true” is the same as setting the text attribute to “auto” on all files and core.eol to “crlf”. Set to true if you want to have CRLF line endings in your working directory and the repository has LF line endings. This variable can be set to input, in which case no output conversion is performed.</p></blockquote><p>这个变量设置为<code>true</code> 等同于在所有文件上设置<code>text attribute</code> 为<code>auto</code> 并且把<code>core.eol</code> 设置为<code>crlf</code>。设成<code>true</code> ， 如果你的工作空间用的是<code>CRLF</code> 作为行结束符，同时仓库用的是<code>LF</code> 行结束符。这个变量也可以设置成<code>input</code>，这样在输出时就不做转换了。</p><p>对上面说的<code>core.eol</code> 又不明白了，继续查看：</p><blockquote><p>core.eol<br>Sets the line ending type to use in the working directory for files that have the text property set when core.autocrlf is false. Alternatives are lf, crlf and native, which uses the platform’s native line ending. The default value is native. See gitattributes[5] for more information on end-of-line conversion.</p></blockquote><p>这个变量是用来设置行结束符的，在<code>core.autocrlf</code> 是<code>false</code>的时候。可以设置成<code>lf</code>，<code>crlf</code>和<code>native</code> ， <code>native</code>是说使用当前平台自己的行结束符。</p><p>到这里，大体就明白了，还留有一个问题，就是<code>attribute</code>的问题，留在下一次来研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原帖收藏于IT老兵驿站，传递一个IT老兵凋零前的光和氧。&lt;/p&gt;
&lt;p&gt;Git：git diff发现windows下会出现”^M”符号。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="diff" scheme="https://www.oxysun.cn/tags/diff/"/>
    
      <category term="windows" scheme="https://www.oxysun.cn/tags/windows/"/>
    
      <category term="^M" scheme="https://www.oxysun.cn/tags/M/"/>
    
      <category term="符号" scheme="https://www.oxysun.cn/tags/%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>区块链：Base64编码和Base58编码</title>
    <link href="https://www.oxysun.cn/blockchain/base64-base58.html"/>
    <id>https://www.oxysun.cn/blockchain/base64-base58.html</id>
    <published>2018-07-27T03:10:00.000Z</published>
    <updated>2018-07-29T12:12:38.496Z</updated>
    
    <content type="html"><![CDATA[<p>区块链：Base64编码和Base58编码。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接触base64有很久了，其实一直没有理解base64这种编码的根本原理，或者说是设计意图，今天又读了一遍，终于开窍了，请看下图。</p><p>Base64 table</p><table><thead><tr><th>原始值</th><th>显示值</th><th>原始值</th><th>显示值</th><th>原始值</th><th>显示值</th><th>原始值</th><th>显示值</th></tr></thead><tbody><tr><td>0</td><td><code>A</code></td><td>16</td><td><code>Q</code></td><td>32</td><td><code>g</code></td><td>48</td><td><code>w</code></td></tr><tr><td>1</td><td><code>B</code></td><td>17</td><td><code>R</code></td><td>33</td><td><code>h</code></td><td>49</td><td><code>x</code></td></tr><tr><td>2</td><td><code>C</code></td><td>18</td><td><code>S</code></td><td>34</td><td><code>i</code></td><td>50</td><td><code>y</code></td></tr><tr><td>3</td><td><code>D</code></td><td>19</td><td><code>T</code></td><td>35</td><td><code>j</code></td><td>51</td><td><code>z</code></td></tr><tr><td>4</td><td><code>E</code></td><td>20</td><td><code>U</code></td><td>36</td><td><code>k</code></td><td>52</td><td><code>0</code></td></tr><tr><td>5</td><td><code>F</code></td><td>21</td><td><code>V</code></td><td>37</td><td><code>l</code></td><td>53</td><td><code>1</code></td></tr><tr><td>6</td><td><code>G</code></td><td>22</td><td><code>W</code></td><td>38</td><td><code>m</code></td><td>54</td><td><code>2</code></td></tr><tr><td>7</td><td><code>H</code></td><td>23</td><td><code>X</code></td><td>39</td><td><code>n</code></td><td>55</td><td><code>3</code></td></tr><tr><td>8</td><td><code>I</code></td><td>24</td><td><code>Y</code></td><td>40</td><td><code>o</code></td><td>56</td><td><code>4</code></td></tr><tr><td>9</td><td><code>J</code></td><td>25</td><td><code>Z</code></td><td>41</td><td><code>p</code></td><td>57</td><td><code>5</code></td></tr><tr><td>10</td><td><code>K</code></td><td>26</td><td><code>a</code></td><td>42</td><td><code>q</code></td><td>58</td><td><code>6</code></td></tr><tr><td>11</td><td><code>L</code></td><td>27</td><td><code>b</code></td><td>43</td><td><code>r</code></td><td>59</td><td><code>7</code></td></tr><tr><td>12</td><td><code>M</code></td><td>28</td><td><code>c</code></td><td>44</td><td><code>s</code></td><td>60</td><td><code>8</code></td></tr><tr><td>13</td><td><code>N</code></td><td>29</td><td><code>d</code></td><td>45</td><td><code>t</code></td><td>61</td><td><code>9</code></td></tr><tr><td>14</td><td><code>O</code></td><td>30</td><td><code>e</code></td><td>46</td><td><code>u</code></td><td>62</td><td><code>+</code></td></tr><tr><td>15</td><td><code>P</code></td><td>31</td><td><code>f</code></td><td>47</td><td><code>v</code></td><td>63</td><td><code>/</code></td></tr></tbody></table><p>什么意思呢？我这样理解，在计算机里面，所有信息都是以二进制的方式承载的，即<code>0</code>和<code>1</code>，这二进制如何去表达我们想要显示（printable）的信息呢？这个时候ASCII码就出现了，以及后来的UniCode等等，它们是以字节为单位来处理，一个字节是8位，这也是计算机系统里面的一个标准处理单位。</p><p>而Base64的目的不是这个，它是要把一段信息显示成另外的一个形式，变成不可直接读，这样尤其是在邮件传输时，可以增加一点安全性。所以，它是以6位为一个单位来处理，对应上面的这个码表，来显示的。Base58是Base64的子集，它的码表元素就更少了，少了8个（ <code>0 , O (大写O)，I (大写i) ，l (小写L) ， + (加号) ，/ (后倒线)</code>），现在被用于区块链领域。</p><p>6位的处理会造成有的时候，不够一个字节，后面需要多补一个到两个字节的<code>0</code>来补齐长度，统一用<code>=</code>显示。</p><p>以下这个例子取自<a href="https://en.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">维基百科</a>，一个表用MD不好展示，分成了两个表：</p><table><thead><tr><th>Source text (ASCII)</th><th>M</th><th>a</th><th></th></tr></thead><tbody><tr><td>Source octets</td><td>77 (0x4d)</td><td>97 (0x61)</td><td></td></tr><tr><td>Bit pattern</td><td>0 1 0 0 1 1 0 1</td><td>0 1 1 0 0 0 0 1</td><td>0 0 0 0 0 0 0 0</td></tr></tbody></table><table><thead><tr><th>Source text (ASCII)</th><th>M</th><th>a</th><th></th><th></th></tr></thead><tbody><tr><td>Bit pattern</td><td>0 1 0 0 1 1</td><td>0 1 0 1 1 0</td><td>0 0 0 1 0 0</td><td>0 0 0 0 0 0</td></tr><tr><td>Index</td><td>19</td><td>22</td><td>4</td><td>(padding)</td></tr><tr><td>Base64-encoded</td><td>T</td><td>W</td><td>E</td><td>=</td></tr><tr><td>Encoded octets</td><td>84 (0x54)</td><td>87 (0x57)</td><td>69 (0x45)</td><td>61 (0x3D)</td></tr></tbody></table><p>这样<code>MA</code>就变成了<code>TWE=</code>，这样就清楚了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链：Base64编码和Base58编码。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：which</title>
    <link href="https://www.oxysun.cn/linux/shell-command-which.html"/>
    <id>https://www.oxysun.cn/linux/shell-command-which.html</id>
    <published>2018-07-26T15:03:07.000Z</published>
    <updated>2018-07-26T15:13:49.679Z</updated>
    
    <content type="html"><![CDATA[<p><code>which</code>命令用于查找并显示给定命令的绝对路径，环境变量<code>$PATH</code>中保存了查找命令时需要遍历的目录。<code>which</code>指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用<code>which</code>命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><a id="more"></a><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>今天有点累，也已经很晚了，总结一个较为简单的命令吧，20英里法则，每天尽量坚持往前走一点。</p><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p><code>which</code>命令是查找某个命令的完整路径。它是用来在当前登录用户的<code>$PATH</code>环境变量记录的路径中查找可执行文件（即二进制文件）的路径。默认情况下，只返回第一个搜索结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHICH(1)                                                        General Commands Manual                                                       WHICH(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       which - shows the full path of (shell) commands.</span><br></pre></td></tr></table></figure><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>which [选项] 命令</code></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>实例：</strong>查看ls命令的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz90drrwkerfi7bc8mqiZ ~]# which ls</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br><span class="line">/usr/bin/ls</span><br></pre></td></tr></table></figure><p>第一行输出暂时没有搞明白是哪里来的，第二行就是<code>ls</code>命令的位置了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;which&lt;/code&gt;命令用于查找并显示给定命令的绝对路径，环境变量&lt;code&gt;$PATH&lt;/code&gt;中保存了查找命令时需要遍历的目录。&lt;code&gt;which&lt;/code&gt;指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用&lt;code&gt;which&lt;/code&gt;命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Shell" scheme="https://www.oxysun.cn/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git：修改远程仓库地址</title>
    <link href="https://www.oxysun.cn/git/git-remote-set-url.html"/>
    <id>https://www.oxysun.cn/git/git-remote-set-url.html</id>
    <published>2018-07-25T14:58:00.000Z</published>
    <updated>2018-08-02T00:39:42.487Z</updated>
    
    <content type="html"><![CDATA[<p>Git：修改远程仓库地址。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有的时候，我们会遇到Git远程仓库IP发生改变，这样的改变可能是：</p><ol><li>远程服务器挂了：远程服务器上的Git仓库被一个爱折腾的同事给删掉了，这个时候把他骂死也没用了，这要是SVN就没办法了，还好是Git，可以从本机的仓库去恢复这个远程仓库。</li><li>远程服务器迁移了，IP变了。<br>这个时候就要用到这个命令了。</li></ol><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-remote - Manage set of tracked repositories（管理被追踪的仓库集合）</span><br></pre></td></tr></table></figure><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>修改远程仓库的url只是这个命令的一个功能。</p><p>记得很久以前（刚毕业的时候）从一本书中看到，中括号表示是可选项，尖括号表示为必选项，现在找不到了，上网查了查，可以参考<a href="https://stackoverflow.com/questions/23242493/linux-unix-man-page-syntax-conventions" target="_blank" rel="noopener">这里</a>。关于这个问题，接触过的很多同事都是糊里糊涂的，我觉得这样总是不好，搞计算机，应该严谨一些，做事情，还是应该寻根究底。</p><p>所以，要修改远程仓库，只需要进入代码目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"># 查看当前的远程仓库</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://where you want to put your repository to.git</span><br><span class="line"># 修改为想要设置的远程仓库</span><br><span class="line"></span><br><span class="line">git remote -v</span><br><span class="line">#验证一下</span><br></pre></td></tr></table></figure><p>大功告成，亲个嘴（韦小宝语）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/docs/git-remote。" target="_blank" rel="noopener">https://git-scm.com/docs/git-remote。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git：修改远程仓库地址。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="修改" scheme="https://www.oxysun.cn/tags/%E4%BF%AE%E6%94%B9/"/>
    
      <category term="远程仓库地址" scheme="https://www.oxysun.cn/tags/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Git：git-revert的用法总结</title>
    <link href="https://www.oxysun.cn/git/git-revert.html"/>
    <id>https://www.oxysun.cn/git/git-revert.html</id>
    <published>2018-07-24T14:10:00.000Z</published>
    <updated>2018-08-02T00:39:42.488Z</updated>
    
    <content type="html"><![CDATA[<p>Git：git-revert的用法总结。<br><a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-revert - Revert some existing commits // 撤销一些已经存在的提交</span><br></pre></td></tr></table></figure><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​</span><br><span class="line">git revert --continue</span><br><span class="line">git revert --quit</span><br><span class="line">git revert --abort</span><br></pre></td></tr></table></figure><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><blockquote><p>Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit).<br>Note: git revert is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see git-reset[1], particularly the –hard option. If you want to extract specific files as they were in another commit, you should see git-checkout[1], specifically the git checkout <commit> – <filename> syntax. Take care with these alternatives as both will discard uncommitted changes in your working directory.</filename></commit></p></blockquote><p>这个工具的使用场景有一点复杂，所以把原本的介绍贴在这里，下面附上翻译：<br>给定一个或多个现有提交，还原由这些提交引入的更改，并用新的提交去记录。 这需要您的工作树是干净的（没有对于<code>HEAD</code>的修改）。注意：<code>git revert</code>用于记录一些新的提交以还原某些早期提交的效果（通常是一个错误的提交）。 如果你想丢弃工作目录中所有未提交的更改，你应该看到<code>git-reset [1]</code>，特别是–hard选项。 如果你想在另一个提交中提取特定文件，你应该看到<code>git-checkout [1]</code>，特别是<code>git checkout &lt;commit&gt; - &lt;filename&gt;</code>语法。 请注意这些替代方案，因为它们都会丢弃工作目录中未提交的更改。</p><p>意思是，如果你想撤销之前的一个或几个提交带来的修改，那么使用这个工具；如果想放弃工作目录的修改（并没有提交），那么你应该使用<code>git reset</code>；或者你只是想检出一个文件的某一个版本，那么使用<code>git checkout</code>。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>摘录了官网的两个例子：<br><strong>实例：</strong> 撤销HEAD指针之前的第3个提交，并且生成一个新的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~3</span><br></pre></td></tr></table></figure><blockquote><p>Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes.</p></blockquote><p><strong>实例：</strong> 撤销从master之前第5个提交到之前第3个提交的变化（这么看来，前面是开区间，第6个没有被包含；后面是闭区间，包含了第3个）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert -n master~5..master~2</span><br></pre></td></tr></table></figure><blockquote><p>Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index.</p></blockquote><p><strong>实例：</strong> 撤销某个提交带来的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git：git-revert的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="git revert" scheme="https://www.oxysun.cn/tags/git-revert/"/>
    
  </entry>
  
  <entry>
    <title>区块链：教程 | 以太坊智能合约编程之菜鸟教程</title>
    <link href="https://www.oxysun.cn/blockchain/block-chain-ethereum-contract-program.html"/>
    <id>https://www.oxysun.cn/blockchain/block-chain-ethereum-contract-program.html</id>
    <published>2018-07-23T14:37:00.000Z</published>
    <updated>2018-07-29T12:12:38.502Z</updated>
    
    <content type="html"><![CDATA[<p>区块链：教程 | 以太坊智能合约编程之菜鸟教程。<br><a id="more"></a></p><blockquote><p>这篇介绍以太坊合约的文章写得很好，在查找了这么多资料，进行对比之后，感觉阅读这一篇就可以大体理解以太坊编程的原理，如果对个别的知识点还有点含糊，可以相应地去查一查，就是以这篇为主干，别的资料为辅。稍微整理了一下格式，以及修改了一些半角符号。</p></blockquote><p><em>译注：<a href="http://consensys.github.io/developers/articles/101-noob-intro/" target="_blank" rel="noopener">原文</a>首发于ConsenSys开发者博客，原作者为Eva以及ConsenSys的开发团队。如果您想要获取更多及时信息，可以访问<a href="https://consensys.net/" target="_blank" rel="noopener">ConsenSys</a>首页点击左下角Newsletter订阅邮件。本文的翻译获得了ConsenSys创始人Lubin先生的授权。</em></p><p>有些人说以太坊太难对付，于是我们(译注：指<a href="http://consensys.net" target="_blank" rel="noopener">Consensys</a>, 下同)写了这篇文章来帮助大家学习如何利用以太坊编写智能合约和应用。这里所用到的工具，钱包，应用程序以及整个生态系统仍处于开发状态，它们将来会更好用！</p><ul><li><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.%20%E6%A6%82%E8%BF%B0">第一部分</a>概述，讨论了关键概念，几大以太坊客户端以及写智能合约用到的编程语言。</li><li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.%20DApp%E6%A1%86%E6%9E%B6,%20%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">第二部分</a>讨论了总体的工作流程，以及目前流行的一些DApp框架和工具。</li><li><a href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86.%20%E7%BC%96%E7%A8%8B">第三部分</a>主要关于编程，我们将学习如何使用Truffle来为智能合约编写测试和构建DApp。</li></ul><h2 id="第一部分-概述"><a href="#第一部分-概述" class="headerlink" title="第一部分 概述"></a>第一部分 概述</h2><p>如果你对诸如比特币以及其工作原理等密码学货币的概念完全陌生，我们建议你先看看Andreas Antonopoulos所著的<a href="https://github.com/aantonop/bitcoinbook" target="_blank" rel="noopener">Bitcoin Book</a>的头几章，然后读一下<a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="noopener">以太坊白皮书</a>。(译注：以太坊白皮书中文版请看 <a href="http://ethfans.org/posts/ethereum-whitepaper" target="_blank" rel="noopener">http://ethfans.org/posts/ethereum-whitepaper</a>)</p><p>如果你觉得白皮书中的章节太晦涩，也可以直接动手来熟悉以太坊。在以太坊上做开发并不要求你理解所有那些“密码经济计算机科学”(crypto economic computer science)，而白皮书的大部分是关于以太坊想对于比特币架构上的改进。</p><h3 id="新手教程"><a href="#新手教程" class="headerlink" title="新手教程"></a>新手教程</h3><p><a href="http://ethereum.org" target="_blank" rel="noopener">ethereum.org</a>提供了官方的新手入门教程，以及一个代币合约和众筹合约的教程。合约语言Solidity也有<a href="https://ethereum.github.io/solidity/" target="_blank" rel="noopener">官方文档</a>。学习智能合约的另一份不错的资料（也是我的入门资料）是<a href="https://dappsforbeginners.wordpress.com/" target="_blank" rel="noopener">dappsForBeginners</a>，不过现在可能有些过时了。</p><p>这篇文章的目的是成为上述资料的补充，同时介绍一些基本的开发者工具，使入门以太坊，智能合约以及构建DApps(decentralized apps, 分布式应用)更加容易。我会试图按照我自己(依然是新手)的理解来解释工作流程中的每一步是在做什么，我也得到了ConsenSys酷酷的开发者们的许多帮助。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>了解这些名词是一个不错的开始：</p><p><strong>公钥加密系统。</strong> Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的<code>0xdf...5f</code>地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。过来人表示：通过踩坑学习到这一点是非常痛苦的…</p><p><strong>点对点网络。</strong> 就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。(未来会有半中心化的混合型服务出现为用户和开发者提供方便，这我们后面会讲到。)</p><p><strong>区块链。</strong> 区块链就像是一个全球唯一的帐簿，或者说是数据库，记录了网络中所有交易历史。</p><p><strong>以太坊虚拟机(EVM)。</strong> 它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。</p><p><strong>节点。</strong> 你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。</p><p><strong>矿工。</strong> 挖矿，也就是处理区块链上的区块的节点。这个网页可以看到当前活跃的一部分以太坊矿工：<a href="http://stats.ethdev.com" target="_blank" rel="noopener">stats.ethdev.com</a>。</p><p><strong>工作量证明。</strong> 矿工们总是在竞争解决一些数学问题。第一个解出答案的(算出下一个区块)将获得以太币作为奖励。然后所有节点都更新自己的区块链。所有想要算出下一个区块的矿工都有与其他节点保持同步，并且维护同一个区块链的动力，因此整个网络总是能达成共识。(注意：以太坊正计划转向没有矿工的权益证明系统(POS)，不过那不在本文讨论范围之内。)</p><p><strong>以太币。</strong> 缩写ETH。一种你可以购买和使用的真正的数字货币。这里是可以交易以太币的其中一家交易所的<a href="https://poloniex.com/exchange#usdt_eth" target="_blank" rel="noopener">走势图</a>。在写这篇文章的时候，1个以太币价值65美分。</p><p><strong>Gas。(汽油)</strong> 在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。</p><p><strong>DApp。</strong> 以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。(花一分钟思考一下：与一般的网站不同，DApp不能跑在普通的服务器上。他们需要提交交易到<strong>区块链</strong>并且从<strong>区块链</strong>而不是中心化数据库读取<strong>重要</strong>数据。相对于典型的用户登录系统，用户有可能被表示成一个钱包地址而其它用户数据保存在本地。许多事情都会与目前的web应用有不同架构。)</p><p>如果想看看从另一个新手视角怎么理解这些概念，请读<a href="https://medium.com/@user1/time-sure-does-fly-ed4518792679" target="_blank" rel="noopener">Just Enough Bitcoin for Ethereum</a>。</p><h3 id="以太坊客户端，智能合约语言"><a href="#以太坊客户端，智能合约语言" class="headerlink" title="以太坊客户端，智能合约语言"></a>以太坊客户端，智能合约语言</h3><p>编写和部署智能合约并不要求你运行一个以太坊节点。下面有列出<a href="#browser_ides">基于浏览器的IDE和API</a>。但如果是为了学习的话，还是应该运行一个以太坊节点，以便理解其中的基本组件，何况运行节点也不难。</p><h4 id="运行以太坊节点可用的客户端"><a href="#运行以太坊节点可用的客户端" class="headerlink" title="运行以太坊节点可用的客户端"></a>运行以太坊节点可用的客户端</h4><p>以太坊有许多不同语言的客户端实现（即多种与以太坊网络交互的方法），包括C++, Go, Python, Java, Haskell等等。为什么需要这么多实现？不同的实现能满足不同的需求（例如Haskell实现的目标是可以被数学验证），能使以太坊更加安全，能丰富整个生态系统。</p><p>在写作本文时，我使用的是Go语言实现的客户端geth (<a href="http://ethereum.github.io/go-ethereum/" target="_blank" rel="noopener">go-ethereum</a>)，其他时候还会使用一个叫testrpc的工具, 它使用了Python客户端<a href="https://github.com/ethereum/pyethereum" target="_blank" rel="noopener">pyethereum</a>。后面的例子会用到这些工具。</p><p>注: 我曾经使用过C++的客户端，现在仍然在用其中的ethminer组件和geth配合挖矿，因此这些不同的组件是可以一起工作的。<br>关于挖矿：挖矿很有趣，有点像精心照料你的室内盆栽，同时又是一种了解整个系统的方法。虽然以太币现在的价格可能连电费都补不齐，但以后谁知道呢。人们正在创造许多酷酷的DApp, 可能会让以太坊越来越流行。</p><p><strong>交互式控制台。</strong> 客户端运行起来后，你就可以同步区块链，建立钱包，收发以太币了。使用geth的一种方式是通过<a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console" target="_blank" rel="noopener">Javascript控制台</a>（JavaScript console, 类似你在chrome浏览器里面按F12出来的那个，只不过是跑在终端里）。此外还可以使用类似cURL的命令通过<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON RPC</a>来与客户端交互。本文的目标是带大家过一边DApp开发的流程，因此这块就不多说了。但是我们应该记住这些命令行工具是调试，配置节点，以及使用钱包的利器。</p><p><strong>在测试网络运行节点。</strong> 如果你在正式网络运行geth客户端，下载整个区块链与网络同步会需要相当时间。（你可以通过比较节点日志中打印的最后一个块号和<a href="http://stats.ethdev.com" target="_blank" rel="noopener">stats.ethdev.com</a>上列出的最新块来确定是否已经同步。) 另一个问题是在正式网络上跑智能合约需要实实在在的以太币。在测试网络上运行节点的话就没有这个问题。此时也不需要同步整个区块链，创建一个自己的私有链就勾了，对于开发来说更省时间。</p><p><strong>testrpc。</strong> 用geth可以创建一个测试网络，另一种更快的创建测试网络的方法是使用testrpc。Testrpc可以在启动时帮你创建一堆存有资金的测试账户。它的运行速度也更快因此更适合开发和测试。你可以从testrpc起步，然后随着合约慢慢成型，转移到geth创建的测试网络上 - 启动方法很简单，只需要指定一个networkid：<code>geth --networkid &quot;12345&quot;</code>。这里是<a href="https://github.com/ConsenSys/eth-testrpc" target="_blank" rel="noopener">testrpc的代码仓库</a>，下文我们还会再讲到它。</p><p>接下来我们来谈谈可用的编程语言，之后就可以开始真正的编程了。</p><h4 id="写智能合约用的编程语言"><a href="#写智能合约用的编程语言" class="headerlink" title="写智能合约用的编程语言"></a>写智能合约用的编程语言</h4><p><strong>用Solidity就好。</strong> 要写智能合约有好几种语言可选：有点类似Javascript的Solidity, 文件扩展名是<code>.sol</code>和Python接近的Serpent, 文件名以<code>.se</code>结尾。还有类似Lisp的LLL。Serpent曾经流行过一段时间，但现在最流行而且最稳定的要算是Solidity了，因此用Solidity就好。听说你喜欢Python? 用Solidity。</p><p><strong>solc编译器。</strong> 用Solidity写好智能合约之后，需要用solc来编译。它是一个来自C++客户端实现的组件（又一次，不同的实现产生互补），<a href="https://github.com/ethereum/webthree-umbrella/wiki" target="_blank" rel="noopener">这里</a>是安装方法。如果你不想安装solc也可以直接使用基于浏览器的编译器，例如<a href="https://chriseth.github.io/browser-solidity/" target="_blank" rel="noopener">Solidity real-time compiler</a>或者<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo</a>。后文有关编程的部分会假设你安装了solc。</p><p>注意：以太坊正处于积极的开发中，有时候新的版本之间会有不同步。确认你使用的是最新的dev版本，或者稳定版本。如果遇到问题可以去以太坊项目对应的Gitter聊天室或者<a href="http://forums.ethereum.org" target="_blank" rel="noopener">forums.ethereum.org</a>上问问其他人在用什么版本。</p><p><strong>web3.js API。</strong> 当Solidity合约编译好并且发送到网络上之后，你可以使用以太坊的<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API" target="_blank" rel="noopener">web3.js JavaScript API</a>来调用它，构建能与之交互的web应用。</p><p>以上就是在以太坊上编写智能合约和构建与之交互的DApp所需的基本工具。</p><h2 id="第二部分-DApp框架，工具以及工作流程"><a href="#第二部分-DApp框架，工具以及工作流程" class="headerlink" title="第二部分 DApp框架，工具以及工作流程"></a>第二部分 DApp框架，工具以及工作流程</h2><h3 id="DApp开发框架"><a href="#DApp开发框架" class="headerlink" title="DApp开发框架"></a>DApp开发框架</h3><p>虽然有上文提到的工具就可以进行开发了，但是使用社区大神们创造的框架会让开发更容易。</p><p><strong>Truffle and Embark。</strong> 是<a href="https://github.com/ConsenSys/truffle" target="_blank" rel="noopener">Truffle</a>把我领进了门。在Truffle出现之前的那个夏天，我目睹了一帮有天分的学生是如何不眠不休的参加一个hackathon（编程马拉松）活动的，虽然<a href="https://www.youtube.com/watch?v=TJBHTT88I8k" target="_blank" rel="noopener">结果相当不错</a>，但我还是吓到了。然后Truffle出现了，帮你处理掉大量无关紧要的小事情，让你可以迅速进入写代码-编译-部署-测试-打包DApp这个流程。另外一个相似的DApp构建与测试框架是<a href="https://iurimatias.github.io/embark-framework" target="_blank" rel="noopener">Embark</a>。我只用过Truffle, 但是两个阵营都拥有不少DApp大神。</p><p><strong>Meteor。</strong> 许多DApp开发者使用的另一套开发栈由web3.js和<a href="https://www.meteor.com/" target="_blank" rel="noopener">Meteor</a>组成，Meteor是一套通用webapp开发框架（<a href="https://github.com/ethereum/meteor-dapp-wallet" target="_blank" rel="noopener">ethereum-meteor-wallet</a>项目提供了一个很棒的入门实例，而<a href="https://github.com/SilentCicero" target="_blank" rel="noopener">SilentCiero</a>正在构建大量Meteor与web3.js和DApp集成的模板）。我下载并运行过一些不错的DApp是以这种方式构造的。在11月9日至13日的<a href="http://consensys.github.io/developers/articles/101-noob-intro/devcon.ethereum.org" target="_blank" rel="noopener">以太坊开发者大会ÐΞVCON1</a>上将有一些有趣的讨论，是关于使用这些工具构建DApp以及相关最佳实践的（会议将会在<a href="https://www.youtube.com/channel/UC6rYoXJ_3BbPyWx_GQDDRRQ" target="_blank" rel="noopener">YouTube</a>上直播）。</p><p><strong>APIs。</strong> <a href="http://blockapps.net/" target="_blank" rel="noopener">BlockApps.net</a>打算提供一套RESTful API给DApp使用以免去开发者运行本地节点的麻烦，这个中心化服务是基于以太坊Haskell实现的。这与DApp的去中心化模型背道而驰，但是在本地无法运行以太坊节点的场合非常有用，比如在你希望只有浏览器或者使用移动设备的用户也能使用你的DApp的时候。BlockApps提供了一个命令行工具<a href="https://github.com/blockapps/bloc" target="_blank" rel="noopener">bloc</a>，注册一个开发者帐号之后就可以使用。</p><p>许多人担心需要运行以太坊节点才能使用DApp的话会把用户吓跑，其实包括BlockApps在内的许多工具都能解决这个问题。<a href="https://metamask.io/" target="_blank" rel="noopener">Metamask</a>允许你在浏览器里面使用以太坊的功能而无需节点，以太坊官方提供的AlethZero或者AlethOne是正在开发中有易用界面的客户端，ConsenSys正在打造一个轻钱包<a href="https://github.com/ConsenSys/eth-lightwallet" target="_blank" rel="noopener">LightWallet</a>，这些工具都会让DApp的使用变得更容易。<a href="https://github.com/ethereum/wiki/wiki/White-Paper#scalability" target="_blank" rel="noopener">轻客户端</a>和水平分片(sharding)也在计划和开发之中。这是一个能进化出混合架构的P2P生态系统。</p><h3 id="智能合约集成开发环境-IDE"><a href="#智能合约集成开发环境-IDE" class="headerlink" title="智能合约集成开发环境 (IDE)"></a>智能合约集成开发环境 (IDE)</h3><p><strong>IDE。</strong> 以太坊官方出品了用来编写智能合约的<a href="https://github.com/ethereum/wiki/wiki/Mix:-The-DApp-IDE" target="_blank" rel="noopener">Mix IDE</a>，我还没用过但会尽快一试。</p><p><strong>基于浏览器的IDE。</strong> <a href="https://chriseth.github.io/browser-solidity" target="_blank" rel="noopener">Solidity real-time compiler</a>和<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo</a>都可以让你快速开始在浏览器中编写智能合约。你甚至可以让这些工具使用你的本地节点，只要让本地节点开一个端口（注意安全！这些工具站点必须可信，而且千万不要把你的全部身家放在这样一个本地节点里面！<a href="http://cosmo.to/" target="_blank" rel="noopener">Cosmo UI</a>上有如何使用geth做到这一点的指引）。在你的智能合约调试通过之后，可以用开发框架来给它添加用户界面和打包成DApp，这正是Truffle的工作，后面的编程章节会有详细讲解。</p><p><a href="http://frontier.ether.camp/" target="_blank" rel="noopener">Ether.Camp</a>正在开发另一个强大的企业级浏览器IDE。他们的IDE将支持沙盒测试网络，自动生成用于测试的用户界面（取代后文将展示的手动编写测试），以及一个测试交易浏览器<a href="http://test.ether.camp/" target="_blank" rel="noopener">test.ether.camp</a>。当你的合约准备正式上线之前，使用他们的测试网络会是确保你的智能合约在一个接近真实的环境工作正常的好方法。他们也为正式网络提供了一个交易浏览器<a href="http://frontier.ether.camp/" target="_blank" rel="noopener">frontier.ether.camp</a>，上面可以看到每一笔交易的细节。在本文写作时Ether.Camp的IDE还只能通过邀请注册，预计很快会正式发布。</p><p><strong>合约和Dapp示例。</strong> 在Github上搜索DApp仓库和.sol文件可以看到进行中的有趣东西。这里有一个DApp大列表：<a href="http://dapps.ethercasts.com/" target="_blank" rel="noopener">dapps.ethercasts.com</a>，不过其中一些项目已经过时。<a href="http://ether.fund/contracts" target="_blank" rel="noopener">Ether.fund/contracts</a>上有一些Solidity和Serpent写的合约示例，但是不清楚这些例子有没有经过测试或者正确性验证。11月12日的<a href="https://devcon.ethereum.org/" target="_blank" rel="noopener">开发者大会ÐΞVCON1</a>将会有一整天的DApp主题演讲。</p><h3 id="部署智能合约的流程"><a href="#部署智能合约的流程" class="headerlink" title="部署智能合约的流程"></a>部署智能合约的流程</h3><p>流程如下：</p><ol><li>启动一个<strong>以太坊节点</strong> (例如geth或者testrpc)。</li><li>使用solc<em>_编译_</em>智能合约。 =&gt; 获得二进制代码。</li><li>将编译好的合约<strong>部署</strong>到网络。（这一步会消耗以太币，还需要使用你的节点的默认地址或者指定地址来给合约签名。） =&gt; 获得合约的区块链地址和ABI（合约接口的JSON表示，包括变量，事件和可以调用的方法）。(译注：作者在这里把ABI与合约接口弄混了。ABI是合约接口的二进制表示。)</li><li>用web3.js提供的JavaScript API来<strong>调用</strong>合约。（根据调用的类型有可能会消耗以太币。）</li></ol><p>下图详细描绘了这个流程：</p><p><img src="https://ethfans.org/uploads/photo/2015/1fc96327c8a1d60c8dc16f8ec1a2fe5d.png" alt="这里写图片描述"></p><p>你的DApp可以给用户提供一个界面先部署所需合约再使用之（如图1到4步），也可以假设合约已经部署了（常见方法），直接从使用合约（如图第6步）的界面开始。</p><h2 id="第三部分-编程"><a href="#第三部分-编程" class="headerlink" title="第三部分 编程"></a>第三部分 编程</h2><h3 id="在Truffle中进行测试"><a href="#在Truffle中进行测试" class="headerlink" title="在Truffle中进行测试"></a>在Truffle中进行测试</h3><p><a href="https://github.com/consensys/truffle" target="_blank" rel="noopener">Truffle</a>用来做智能合约的测试驱动开发(TDD)非常棒，我强烈推荐你在学习中使用它。它也是学习使用JavaScript Promise的一个好途径，例如deferred和异步调用。Promise机制有点像是说“做这件事，如果结果是这样，做甲，如果结果是那样，做乙… 与此同时不要在那儿干等着结果返回，行不？”。Truffle使用了包装web3.js的一个JS Promise框架<a href="https://github.com/ConsenSys/ether-pudding" target="_blank" rel="noopener">Pudding</a>（因此它为为你安装web3.js）。(译注：Promise是流行于JavaScript社区中的一种异步调用模式。它很好的封装了异步调用，使其能够灵活组合，而不会陷入callback hell.)</p><p><strong>Transaction times。</strong> Promise对于DApp非常有用，因为交易写入以太坊区块链需要大约12-15秒的时间。即使在测试网络上看起来没有那么慢，在正式网络上却可能会要更长的时间（例如你的交易可能用光了Gas，或者被写入了一个孤儿块）。</p><p>下面让我们给一个简单的智能合约写测试用例吧。</p><h3 id="使用Truffle"><a href="#使用Truffle" class="headerlink" title="使用Truffle"></a>使用Truffle</h3><p>首先确保你 1.安装好了<a href="https://github.com/ethereum/webthree-umbrella/wiki" target="_blank" rel="noopener">solc</a>以及 2.<a href="https://github.com/ConsenSys/eth-testrpc" target="_blank" rel="noopener">testrpc</a>。（testrpc需要<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python</a>和<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip</a>。如果你是Python新手，你可能需要用<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" target="_blank" rel="noopener">virtualenv</a>来安装，这可以将Python程序库安装在一个独立的环境中。）</p><p>接下来安装 3.<a href="https://github.com/ConsenSys/truffle" target="_blank" rel="noopener">Truffle</a>（你可以使用<a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" rel="noopener">NodeJS’s npm</a>来安装：<code>npm install -g truffle</code>, <code>-g</code>开关可能会需要sudo）。安装好之后，在命令行中输入<code>truffle list</code>来验证安装成功。然后创建一个新的项目目录（我把它命名为’conference’），进入这个目录，运行<code>truffle init</code>。该命令会建立如下的目录结构：</p><p><img src="https://ethfans.org/uploads/photo/2015/57b9fb67369c190fa455766ab5f6556f.png" alt="这里写图片描述"></p><p>现在让我们在<strong>另一个终端</strong>里通过执行<code>testrpc</code>来启动一个节点（你也可以用geth）：</p><p><img src="https://ethfans.org/uploads/photo/2015/a7d19ebfb8d027b65384c532770b3ba8.png" alt="这里写图片描述"></p><p>回到之前的终端中，输入<code>truffle deploy</code>。这条命令会部署之前<code>truffle init</code>产生的模板合约到网络上。任何你可能遇到的错误信息都会在testrpc的终端或者执行truffle的终端中输出。</p><p>在开发过程中你随时可以使用<code>truffle compile</code>命令来确认你的合约可以正常编译（或者使用<code>solc YourContract.sol</code>），<code>truffle deploy</code>来编译和部署合约，最后是<code>truffle test</code>来运行智能合约的测试用例。</p><h3 id="第一个合约"><a href="#第一个合约" class="headerlink" title="第一个合约"></a>第一个合约</h3><p>下面是一个针对会议的智能合约，通过它参会者可以买票，组织者可以设置参会人数上限，以及退款策略。本文涉及的所有代码都可以在这个<a href="https://github.com/eshon/conference" target="_blank" rel="noopener">代码仓库</a>找到。</p><pre><code>contract Conference {  address public organizer;  mapping (address =&gt; uint) public registrantsPaid;  uint public numRegistrants;  uint public quota;  event Deposit(address _from, uint _amount);  // so you can log these events  event Refund(address _to, uint _amount);   function Conference() { // Constructor    organizer = msg.sender;    quota = 500;    numRegistrants = 0;  }  function buyTicket() public returns (bool success) {    if (numRegistrants &gt;= quota) { return false; }    registrantsPaid[msg.sender] = msg.value;    numRegistrants++;    Deposit(msg.sender, msg.value);    return true;  }  function changeQuota(uint newquota) public {    if (msg.sender != organizer) { return; }    quota = newquota;  }  function refundTicket(address recipient, uint amount) public {    if (msg.sender != organizer) { return; }    if (registrantsPaid[recipient] == amount) {       address myAddress = this;      if (myAddress.balance &gt;= amount) {         recipient.send(amount);        registrantsPaid[recipient] = 0;        numRegistrants--;        Refund(recipient, amount);      }    }  }  function destroy() { // so funds not locked in contract forever    if (msg.sender == organizer) {       suicide(organizer); // send funds to organizer    }  }}</code></pre><p>接下来让我们部署这个合约。（注意：本文写作时我使用的是Mac OS X 10.10.5, solc 0.1.3+ (通过brew安装)，Truffle v0.2.3, testrpc v0.1.18 (使用venv)）</p><h3 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h3><p><img src="https://ethfans.org/uploads/photo/2015/93ece58476d59db60d3c60657d5baa2d.png" alt="这里写图片描述"></p><p>(译注：图中步骤翻译如下：）</p><p>使用truffle部署智能合约的步骤：<br>1. <code>truffle init</code> (在新目录中) =&gt; 创建truffle项目目录结构<br>2. 编写合约代码，保存到<code>contracts/YourContractName.sol</code>文件。<br>3. 把合约名字加到<code>config/app.json</code>的’contracts’部分。<br>4. 启动以太坊节点（例如在另一个终端里面运行<code>testrpc</code>）。<br>5. <code>truffle deploy</code>（在truffle项目目录中)</p><p><strong>添加一个智能合约。</strong> 在<code>truffle init</code>执行后或是一个现有的项目目录中，复制粘帖上面的会议合约到<code>contracts/Conference.sol</code>文件中。然后打开<code>config/app.json</code>文件，把’Conference’加入’deploy’数组中。</p><p><img src="https://ethfans.org/uploads/photo/2015/62922e726f12f928492d4a647951f72c.png" alt=""></p><p><strong>启动testrpc。</strong> 在另一个终端中启动<code>testrpc</code>。</p><p><strong>编译或部署。</strong> 执行<code>truffle compile</code>看一下合约是否能成功编译，或者直接<code>truffle deploy</code>一步完成编译和部署。这条命令会把部署好的合约的地址和ABI（应用接口）加入到配置文件中，这样之后的<code>truffle test</code>和<code>truffle build</code>步骤可以使用这些信息。</p><p><strong>出错了？</strong> 编译是否成功了？记住，错误信息即可能出现在testrpc终端也可能出现在truffle终端。</p><p><strong>重启节点后记得重新部署！</strong> 如果你停止了testrpc节点，下一次使用任何合约之前切记使用<code>truffle deploy</code>重新部署。testrpc在每一次重启之后都会回到完全空白的状态。</p><h3 id="合约代码解读"><a href="#合约代码解读" class="headerlink" title="合约代码解读"></a>合约代码解读</h3><p>让我们从智能合约头部的变量声明开始：</p><pre><code>address public organizer;mapping (address =&gt; uint) public registrantsPaid;uint public numRegistrants;uint public quota;</code></pre><p><strong>address。</strong> 地址类型。第一个变量是会议组织者的钱包地址。这个地址会在合约的构造函数<code>function Conference()</code>中被赋值。很多时候也称呼这种地址为’owner’（所有人）。</p><p><strong>uint。</strong> 无符号整型。区块链上的存储空间很紧张，保持数据尽可能的小。</p><p><strong>public。</strong> 这个关键字表明变量可以被合约之外的对象使用。<code>private</code>修饰符则表示变量只能被本合约(或者衍生合约)内的对象使用。如果你想要在测试中通过web3.js使用合约中的某个变量，记得把它声明为<code>public</code>。</p><p><strong>Mapping或数组。</strong>（译注：Mapping类似Hash, Directory等数据类型，不做翻译。）在Solidity加入数组类型之前，大家都使用类似<code>mapping (address =&gt; uint)</code>的Mapping类型。这个声明也可以写作<code>address registrantsPaid[]</code>，不过Mapping的存储占用更小(smaller footprint)。这个Mapping变量会用来保存参加者（用他们的钱包地址表示）的付款数量以便在退款时使用。</p><p><strong>关于地址。</strong> 你的客户端（比如testrpc或者geth）可以生成一个或多个账户/地址。testrpc启动时会显示10个可用地址：</p><p><img src="https://ethfans.org/uploads/photo/2015/26c59b073b0d405cd482e2690e47639a.png" alt=""></p><p>第一个地址, <code>accounts[0]</code>，是发起调用的默认地址，如果没有特别指定的话。</p><p><strong>组织者地址 vs 合约地址。</strong> 部署好的合约会在区块链上拥有自己的地址（与组织者拥有的是不同的地址）。在Solidity合约中可以使用<code>this</code>来访问这个合约地址，正如<code>refundTicket</code>函数所展示的：<code>address myAddress = this;</code></p><p><strong>Suicide, Solidity的好东西。</strong>（译注：<code>suicide</code>意为’自杀’, 为Solidity提供的关键字，不做翻译。）转给合约的资金会保存于合约（地址）中。最终这些资金通过<code>destroy</code>函数被释放给了构造函数中设置的组织者地址。这是通过<code>suicide(orgnizer);</code>这行代码实现的。没有这个，资金可能被永远锁定在合约之中（reddit上有些人就遇到过），因此如果你的合约会接受资金一定要记得在合约中使用这个方法！</p><p>如果想要模拟另一个用户或者对手方（例如你是卖家想要模拟一个买家），你可以使用可用地址数组中另外的地址。假设你要以另一个用户，<code>accounts[1]</code>, 的身份来买票，可以通过<code>from</code>参数设置：</p><pre><code>conference.buyTicket({ from: accounts[1], value: some_ticket_price_integer });</code></pre><p><strong>函数调用可以是交易。</strong> 改变合约状态（修改变量值，添加记录，等等）的函数调用本身也是转账交易，隐式的包含了发送人和交易价值。因此web3.js的函数调用可以通过指定<code>{ from: __, value: __ }</code>参数来发送以太币。在Solidity合约中，你可以通过<code>msg.sender</code>和<code>msg.value</code>来获取这些信息：</p><pre><code>function buyTicket() public {    ...    registrantsPaid[msg.sender] = msg.value;    ...}</code></pre><p><strong>事件(Event)。</strong> 可选的功能。合约中的<code>Deposit</code>（充值）和<code>Send</code>（发送）事件是会被记录在以太坊虚拟机日志中的数据。它们实际上没有任何作用，但是用事件(Event)把交易记录进日志是好的做法。</p><p>好了，现在让我们给这个智能合约写一个测试，来确保它能工作。</p><h3 id="写测试"><a href="#写测试" class="headerlink" title="写测试"></a>写测试</h3><p>把项目目录<code>test/</code>中的<code>example.js</code>文件重命名为<code>conference.js</code>，文件中所有的’Example’替换为’Conference’。</p><pre><code>contract(&apos;Conference&apos;, function(accounts) {  it(&quot;should assert true&quot;, function(done) {    var conference = Conference.at(Conference.deployed_address);    assert.isTrue(true);    done();   // stops tests at this point  });});</code></pre><p>在项目根目录下运行<code>truffle test</code>，你应该看到测试通过。在上面的测试中truffle通过<code>Conference.deployed_address</code>获得合约部署在区块链上的地址。</p><p>让我们写一个测试来初始化一个新的Conference，然后检查变量都正确赋值了。将<code>conference.js</code>中的测试代码替换为：</p><pre><code>contract(&apos;Conference&apos;, function(accounts) {  it(&quot;Initial conference settings should match&quot;, function(done) {    var conference = Conference.at(Conference.deployed_address);      // same as previous example up to here    Conference.new({ from: accounts[0]  })    .then(function(conference) {      conference.quota.call().then(          function(quota) {            assert.equal(quota, 500, &quot;Quota doesn&apos;t match!&quot;);           }).then( function() {            return conference.numRegistrants.call();          }).then( function(num) {            assert.equal(num, 0, &quot;Registrants should be zero!&quot;);            return conference.organizer.call();          }).then( function(organizer) {            assert.equal(organizer, accounts[0], &quot;Owner doesn&apos;t match!&quot;);            done();   // to stop these tests earlier, move this up        }).catch(done);      }).catch(done);    });  });</code></pre><p><strong>构造函数。</strong> <code>Conference.new({ from: accounts[0] })</code>通过调用合约构造函数创造了一个新的Conference实例。由于不指定<code>from</code>时会默认使用<code>accounts[0]</code>，它其实可以被省略掉：</p><pre><code>Conference.new({ from: accounts[0] }); // 和Conference.new()效果相同</code></pre><p><strong>Promise。</strong> 代码中的那些<code>then</code>和<code>return</code>就是Promise。它们的作用写成一个深深的嵌套调用链的话会是这样：</p><pre><code>conference.numRegistrants.call().then(  function(num) {    assert.equal(num, 0, &quot;Registrants should be zero!&quot;);    conference.organizer.call().then(     function(organizer) {        assert.equal(organizer, accounts[0], &quot;Owner doesn&apos;t match!&quot;);        }).then(          function(...))            }).then(              function(...))            // Because this would get hairy...</code></pre><p>Promise减少嵌套，使代码变得扁平，允许调用异步返回，并且简化了表达“成功时做这个”和“失败时做那个”的语法。Web3.js通过<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#using-callbacks" target="_blank" rel="noopener">回调函数</a>实现异步调用，因此你不需要等到交易完成就可以继续执行前端代码。Truffle借助了用Promise封装web3.js的一个框架，叫做<a href="https://github.com/ConsenSys/ether-pudding" target="_blank" rel="noopener">Pudding</a>，这个框架本身又是基于<a href="http://ricostacruz.com/cheatsheets/bluebird.html" target="_blank" rel="noopener">Bluebird</a>的，它支持Promise的高级特性。</p><p><strong>call。</strong> 我们使用<code>call</code>来检查变量的值，例如<code>conference.quota.call().then(...</code>，还可以通过传参数，例如<code>call(0)</code>, 来获取mapping在index 0处的元素。Solidity的文档说这是一种特殊的“消息调用”因为 1.不会为矿工记录和 2.不需要从钱包账户/地址发起（因此它没有被账户持有者私钥做签名）。另一方面，交易/事务(Transaction)会被矿工记录，必须来自于一个账户（也就是有签名），会被记录到区块链上。对合约中数据做的任何修改都是交易。仅仅是检查一个变量的值则不是。因此在读取变量时不要忘记加上<code>call()</code>！否则会发生奇怪的事情。（此外如果在读取变量是遇到问题别忘记检查它是否是<code>public</code>。）<code>call()</code>也能用于调用不是交易的函数。如果一个函数本来是交易，但你却用<code>call()</code>来调用，则不会在区块链上产生交易。</p><p><strong>断言。</strong> 标准JS测试中的断言（如果你不小心拼成了复数形式’asserts’，truffle会报错，让你一头雾水），<code>assert.equal</code>是最常用的，其他类型的断言可以在<a href="http://chaijs.com/api/assert/" target="_blank" rel="noopener">Chai的文档</a>中找到。</p><p>再一次运行<code>truffle test</code>确保一切工作正常。</p><h3 id="测试合约函数调用"><a href="#测试合约函数调用" class="headerlink" title="测试合约函数调用"></a>测试合约函数调用</h3><p>现在我们测试一下改变<code>quote</code>变量的函数能工作。在<code>tests/conference.js</code>文件的<code>contract(&#39;Conference&#39;, function(accounts) {...};)</code>的函数体中添加如下测试用例：</p><pre><code>it(&quot;Should update quota&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({from: accounts[0] }).then(    function(conference) {      conference.quota.call().then(         function(quota) {           assert.equal(quota, 500, &quot;Quota doesn&apos;t match!&quot;);         }).then( function() {           return conference.changeQuota(300);        }).then( function(result) {  // result here is a transaction hash          console.log(result);  // if you were to print this out it’d be long hex - the transaction hash          return conference.quota.call()        }).then( function(quota) {           assert.equal(quota, 300, &quot;New quota is not correct!&quot;);          done();        }).catch(done);    }).catch(done);});</code></pre><p>这里的新东西是调用<code>changeQuota</code>函数的那一行。<code>console.log</code>对于调试很有用，用它能在运行truffle的终端中输出信息。在关键点插入<code>console.log</code>可以查看执行到了哪一步。记得把Solidity合约中<code>changeQuota</code>函数被声明为<code>public</code>，否则你不能调用它：</p><pre><code>function changeQuota(uint newquota) public {  }</code></pre><h3 id="测试交易"><a href="#测试交易" class="headerlink" title="测试交易"></a>测试交易</h3><p>现在让我们调用一个需要发起人发送资金的函数。</p><p><strong>Wei。</strong> 以太币有很多种单位（这里有个很有用的<a href="http://ether.fund/tool/converter" target="_blank" rel="noopener">转换器</a>）,在合约中通常用的是Wei，最小的单位。Web3.js提供了在各单位与Wei之间互相转换的便利方法，形如<code>web3.toWei(.05, &#39;ether&#39;)</code>。JavaScript在处理很大的数字时有问题，因此web3.js使用了<a href="https://github.com/MikeMcl/bignumber.js/" target="_blank" rel="noopener">程序库BigNumber</a>，并建议在代码各处都以Wei做单位，直到要给用户看的时候（<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#a-note-on-big-numbers-in-web3js" target="_blank" rel="noopener">文档</a>。</p><p><strong>账户余额。</strong> Web3.js提供了许多提供方便的<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3-javascript-%C3%90app-api-reference" target="_blank" rel="noopener">方法</a>，其中另一个会在下面测试用到的是<code>web3.eth.getBalance(some_address)</code>。记住发送给合约的资金会由合约自己持有直到调用<code>suicide</code>。</p><p>在<code>contract(Conference, function(accounts) {...};)</code>的函数体中插入下面的测试用例。在高亮显示的方法中，测试用例让另一个用户(<code>accounts[1]</code>)以<code>ticketPrice</code>的价格买了一张门票。然后它检查合约的账户余额增加了<code>ticketPrice</code>，以及购票用户被加入了参会者列表。</p><p>这个测试中的<code>buyTicket</code>是一个交易函数：</p><pre><code>it(&quot;Should let you buy a ticket&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {      var ticketPrice = web3.toWei(.05, &apos;ether&apos;);      var initialBalance = web3.eth.getBalance(conference.address).toNumber();      conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(        function() {          var newBalance = web3.eth.getBalance(conference.address).toNumber();          var difference = newBalance - initialBalance;          assert.equal(difference, ticketPrice, &quot;Difference should be what was sent&quot;);          return conference.numRegistrants.call();      }).then(function(num) {          assert.equal(num, 1, &quot;there should be 1 registrant&quot;);          return conference.registrantsPaid.call(accounts[1]);      }).then(function(amount) {          assert.equal(amount.toNumber(), ticketPrice, &quot;Sender&apos;s paid but is not listed&quot;);          done();      }).catch(done);  }).catch(done);});</code></pre><p><strong>交易需要签名。</strong> 和之前的函数调用不同，这个调用是一个会发送资金的交易，在这种情况下购票用户(<code>accounts[1]</code>)会用他的私钥对<code>buyTicket()</code>调用做签名。（在geth中用户需要在发送资金之前通过输入密码来批准这个交易或是解锁钱包的账户。）</p><p><strong>toNumber()。</strong> 有时我们需要把Solidity返回的十六进制结果转码。如果结果可能是个很大的数字可以用<code>web3.toBigNumber(numberOrHexString)</code>来处理因为JavaScript直接对付大数要糟。</p><h3 id="测试包含转账的合约"><a href="#测试包含转账的合约" class="headerlink" title="测试包含转账的合约"></a>测试包含转账的合约</h3><p>最后，为了完整性，我们确认一下<code>refundTicket</code>方法能正常工作，而且只有会议组织者能调用。下面是测试用例：</p><pre><code>it(&quot;Should issue a refund by owner only&quot;, function(done) {  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {      var ticketPrice = web3.toWei(.05, &apos;ether&apos;);      var initialBalance = web3.eth.getBalance(conference.address).toNumber();       conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(        function() {          var newBalance = web3.eth.getBalance(conference.address).toNumber();          var difference = newBalance - initialBalance;          assert.equal(difference, ticketPrice, &quot;Difference should be what was sent&quot;);  // same as before up to here          // Now try to issue refund as second user - should fail          return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[1]});          }).then(          function() {            var balance = web3.eth.getBalance(conference.address).toNumber();            assert.equal(web3.toBigNumber(balance), ticketPrice, &quot;Balance should be unchanged&quot;);            // Now try to issue refund as organizer/owner - should work            return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[0]});          }).then(          function() {            var postRefundBalance = web3.eth.getBalance(conference.address).toNumber();            assert.equal(postRefundBalance, initialBalance, &quot;Balance should be initial balance&quot;);            done();        }).catch(done);    }).catch(done); });</code></pre><p>这个测试用例覆盖的Solidity函数如下：</p><pre><code>function refundTicket(address recipient, uint amount) public returns (bool success) {  if (msg.sender != organizer) { return false; }  if (registrantsPaid[recipient] == amount) {     address myAddress = this;    if (myAddress.balance &gt;= amount) {       recipient.send(amount);      Refund(recipient, amount);      registrantsPaid[recipient] = 0;      numRegistrants--;      return true;    }  }  return false;}</code></pre><p><strong>合约中发送以太币。</strong> <code>address myAddress = this</code>展示了如何获取该会议合约实例的地址，以变接下来检查这个地址的余额（或者直接使用<code>this.balance</code>）。合约通过<code>recipient.send(amount)</code>方法把资金发回了购票人。</p><p><strong>交易无法返回结果给web3.js。</strong> 注意这一点！<code>refundTicket</code>函数会返回一个布尔值，但是这在测试中无法检查。因为这个方法是一个交易函数（会改变合约内数据或是发送以太币的调用），而web3.js得到的交易运行结果是一个交易哈希（如果打印出来是一个长长的十六进制/怪怪的字符串）。既然如此为什么还要让<code>refundTicket</code>返回一个值？因为在Solidity合约内可以读到这个返回值，例如当另一个合约调用<code>refundTicket()</code>的时候。也就是说Solidity合约可以读取交易运行的返回值，而web3.js不行。另一方面，在web3.js中你可以用事件机制（Event, 下文会解释）来监控交易运行，而合约不行。合约也无法通过<code>call()</code>来检查交易是否修改了合约内变量的值。</p><p><strong>关于sendTransaction()。</strong> 当你通过web3.js调用类似<code>buyTicket()</code>或者<code>refundTicket()</code>的交易函数时（使用<code>web3.eth.sendTransaction</code>），交易并不会立即执行。事实上交易会被提交到矿工网络中，交易代码直到其中一位矿工产生一个新区块把交易记录进区块链之后才执行。因此你必须等交易进入区块链并且同步回本地节点之后才能验证交易执行的结果。用testrpc的时候可能看上去是实时的，因为测试环境很快，但是正式网络会比较慢。</p><p><strong>事件/Event。</strong> 在web3.js中你应该监听<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">事件</a>而不是返回值。我们的智能合约示例定义了这些事件：</p><pre><code>event Deposit(address _from, uint _amount);event Refund(address _to, uint _amount);</code></pre><p>它们在<code>buyTicket()</code>和<code>refundTicket()</code>中被触发。触发时你可以在testrpc的输出中看到日志。要监听事件，你可以使用web.js监听器(listener)。在写本文时我还不能在truffle测试中记录事件，但是在应用中没问题：</p><pre><code>Conference.new({ from: accounts[0] }).then(  function(conference) {    var event = conference.allEvents().watch({}, &apos;&apos;); // or use conference.Deposit() or .Refund()    event.watch(function (error, result) {      if (error) {        console.log(&quot;Error: &quot; + error);      } else {        console.log(&quot;Event: &quot; + result.event);      }    });    // ...</code></pre><p><strong>过滤器/Filter。</strong> 监听所有事件可能会产生大量的轮询，作为替代可以使用过滤器。它们可以更灵活的开始或是停止对事件的监听。更多过滤器的信息可查看<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter" target="_blank" rel="noopener">Solidity文档</a>。</p><p>总的来说，使用事件和过滤器的组合比检查变量消耗的Gas更少，因而在验证正式网络的交易运行结果时非常有用。</p><p><strong>Gas。</strong> （译注：以太坊上的燃料，因为代码的执行必须消耗Gas。直译为汽油比较突兀，故保留原文做专有名词。）直到现在我们都没有涉及Gas的概念，因为在使用testrpc时通常不需要显式的设置。当你转向geth和正式网络时会需要。在交易函数调用中可以在<code>{from: __, value: __, gas: __}</code>对象内设置Gas参数。Web3.js提供了<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgasprice" target="_blank" rel="noopener"><code>web3.eth.gasPrice</code></a>调用来获取当前Gas的价格，Solidity编译器也提供了一个参数让你可以从命令行获取合约的Gas开销概要：<code>solc --gas YouContract.sol</code>。下面是<code>Conference.sol</code>的结果：</p><p><img src="https://ethfans.org/uploads/photo/2015/afa43126d926ed3db1915718900c69c7.png" alt=""></p><h3 id="为合约创建DApp界面"><a href="#为合约创建DApp界面" class="headerlink" title="为合约创建DApp界面"></a>为合约创建DApp界面</h3><p><em>下面的段落会假设你没有网页开发经验。</em></p><p>上面编写的测试用例用到的都是在前端界面中也可以用的方法。你可以把前端代码放到<code>app/</code>目录中，运行<code>truffle build</code>之后它们会和合约配置信息一起编译输出到<code>build/</code>目录。在开发时可以使用<code>truffle watch</code>命令在<code>app/</code>有任何变动时自动编译输出到<code>build/</code>目录。然后在浏览器中刷新页面即可看到<code>build/</code>目录中的最新内容。（<code>truffle serve</code>可以启动一个基于<code>build/</code>目录的网页服务器。）</p><p><code>app/</code>目录中有一些样板文件帮助你开始：</p><p><img src="https://ethfans.org/uploads/photo/2015/a6a8374e2ee98c702455fdfa93b5e117.png" alt=""></p><p><code>index.html</code>会加载<code>app.js</code>：</p><p><img src="https://ethfans.org/uploads/photo/2015/91153d00abd7361d997276e252a3ac75.png" alt=""></p><p>因此我们只需要添加代码到<code>app.js</code>就可以了。</p><p>默认的<code>app.js</code>会在浏览器的console(控制台)中输出一条”Hello from Truffle!”的日志。在项目根目录中运行<code>truffle watch</code>，然后在浏览器中打开<code>build/index.html</code>文件，再打开浏览器的console就可以看到。（大部分浏览器例如Chrome中，单击右键 -&gt; 选择Inspect Element然后切换到Console即可。）</p><p><img src="https://ethfans.org/uploads/photo/2015/18b1dd84faa4aa16a841f6fe7ab0093e.png" alt=""></p><p>在<code>app.js</code>中，添加一个在页面加载时会运行的<code>window.onload</code>调用。下面的代码会确认web3.js已经正常载入并显示所有可用的账户。（注意：你的testrpc节点应该保持运行。）</p><pre><code>window.onload = function() {  var accounts = web3.eth.accounts;  console.log(accounts);}</code></pre><p>看看你的浏览器console中看看是否打印出了一组账户地址。</p><p>现在你可以从<code>tests/conference.js</code>中复制一些代码过来（去掉只和测试有关的断言），将调用返回的结果输出到console中以确认代码能工作。下面是个例子：</p><pre><code>window.onload = function() {  var accounts = web3.eth.accounts;  var c = Conference.at(Conference.deployed_address);  Conference.new({ from: accounts[0] }).then(    function(conference) {    var ticketPrice = web3.toWei(.05, &apos;ether&apos;);    var initialBalance = web3.eth.getBalance(conference.address).toNumber();     console.log(&quot;The conference&apos;s initial balance is: &quot; + initialBalance);    conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(      function() {        var newBalance = web3.eth.getBalance(conference.address).toNumber();        console.log(&quot;After someone bought a ticket it&apos;s: &quot; + newBalance);        return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[0]});      }).then(        function() {            var balance = web3.eth.getBalance(conference.address).toNumber();          console.log(&quot;After a refund it&apos;s: &quot; + balance);      });  });};</code></pre><p>上面的代码应该输出如下：</p><p><img src="https://ethfans.org/uploads/photo/2015/f093c01e94c9d56b8f58202edb42a27e.png" alt=""></p><p>(console输出的warning信息可忽略。)</p><p>现在起你就可以使用你喜欢的任何前端工具，jQuery, ReactJS, Meteor, Ember, AngularJS，等等等等，在<code>app/</code>目录中构建可以与以太坊智能合约互动的DApp界面了！接下来我们给出一个极其简单基于jQuery的界面作为示例。</p><p><img src="https://ethfans.org/uploads/photo/2015/a85ed594ffaceef763fb249508d855eb.png" alt=""></p><p>这里是<a href="https://github.com/eshon/conference/blob/master/app/index.html" target="_blank" rel="noopener">index.html的代码</a>，这里是<a href="https://github.com/eshon/conference/blob/master/app/javascripts/app.js" target="_blank" rel="noopener">app.js的代码</a>。</p><p>通过界面测试了智能合约之后我意识到最好加入检查以保证相同的用户不能注册两次。另外由于现在是运行在testrpc节点上，速度很快，最好是切换到geth节点并确认交易过程依然能及时响应。否则的话界面上就应该显示提示信息并且在处理交易时禁用相关的按钮。</p><p><strong>尝试geth。</strong> 如果你使用<a href="https://github.com/ethereum/go-ethereum/" target="_blank" rel="noopener">geth</a>, 可以尝试以下面的命令启动 - 在我这儿(geth v1.2.3)工作的很好：</p><pre><code>build/bin/geth --rpc --rpcaddr=&quot;0.0.0.0&quot; --rpccorsdomain=&quot;*&quot; --mine --unlock=&apos;0 1&apos; --verbosity=5 --maxpeers=0 --minerthreads=&apos;4&apos;  --networkid &apos;12345&apos; --genesis test-genesis.json</code></pre><p>这条命令解锁了两个账户, <code>0</code>和<code>1</code>。1. 在geth控制台启动后你可能需要输入这两个账户的密码。2. 你需要在<a href="https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network#custom-networks" target="_blank" rel="noopener"><code>test-genesis.json</code></a>文件里面的’alloc’配置中加入你的这两个账户，并且给它们充足的资金。3. 最后，在创建合约实例时加上gas参数：</p><pre><code>Conference.new({from: accounts[0], gas: 3141592})</code></pre><p>然后把整个<code>truffle deploy</code>, <code>truffle build</code>流程重来一遍。</p><p><strong>教程中的代码。</strong> 在这篇基础教程中用到的所有代码都可以在这个<a href="https://github.com/eshon/conference" target="_blank" rel="noopener">代码仓库</a>中找到。</p><p><strong>自动为合约生成界面。</strong> <a href="https://github.com/SilentCicero" target="_blank" rel="noopener">SilentCicero</a>制作了一个叫做<a href="http://dapp-builder.meteor.com/" target="_blank" rel="noopener">DApp Builder</a>的工具，可以用Solidity合约自动生成HTML, jQuery和web.js的代码。这种模式也正在被越来越多的正在开发中的开发者工具采用。</p><p><strong>教程到此结束！</strong> 最后一章我们仅仅学习了一套工具集，主要是Truffle和testrpc. 要知道即使在ConsenSys内部，不同的开发者使用的工具和框架也不尽相同。你可能会发现更适合你的工具，这里所说的工具可能很快也会有改进。但是本文介绍的工作流程帮助我走上了DApp开发之路。</p><p>(⊙ω⊙) wonk wonk</p><p><em>感谢Joseph Chow的校阅和建议，Christian Lundkvist, Daniel Novy, Jim Berry, Peter Borah和Tim Coulter帮我修改文字和debug，以及Tim Coulter, Nchinda Nchinda和Mike Goldin对DApp前端步骤图提供的帮助。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链：教程 | 以太坊智能合约编程之菜鸟教程。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://www.oxysun.cn/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的基本操作：删除记录（删）</title>
    <link href="https://www.oxysun.cn/mongodb/mongodb-collection-delete.html"/>
    <id>https://www.oxysun.cn/mongodb/mongodb-collection-delete.html</id>
    <published>2018-07-23T13:29:48.000Z</published>
    <updated>2018-07-23T13:34:13.622Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的基本操作：删除记录（删）。<br><a id="more"></a></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>删除记录有两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.2版本之前</span><br><span class="line">db.collection.remove() //</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.2版本之后</span><br><span class="line"> - db.collection.deleteMany() //删除匹配条件的多条记录</span><br><span class="line"> - db.collection.deleteOne() //删除匹配条件的单条记录</span><br></pre></td></tr></table></figure><p>括号里面的参数是查询过滤器。</p><h1 id="查询过滤器："><a href="#查询过滤器：" class="headerlink" title="查询过滤器："></a><a href="https://docs.mongodb.com/v3.6/core/document/#document-query-filter" target="_blank" rel="noopener">查询过滤器</a>：</h1><p>查询过滤器用来设定查询条件。</p><p>格式<code>&lt;field&gt;:&lt;value&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &lt;field1&gt;: &lt;value1&gt;,</span><br><span class="line">  &lt;field2&gt;: &#123; &lt;operator&gt;: &lt;value&gt; &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>实例：</strong>删除前文test数据库中所有记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.deleteMany(&#123;&#125;);</span><br></pre></td></tr></table></figure><p><code>{}</code>表示没有约束条件。</p><p><strong>实例：</strong>删除前文test数据库中_id为5abb3b5bce69c048be080199的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.deleteMany(&#123;_id: ObjectId(&quot;5abb3b5bce69c048be080199&quot;)&#125;);</span><br></pre></td></tr></table></figure><p>笔记整理到这里，发现之前的记录有点问题，因为对MongoDB的官网的结构没有完全搞清楚，所以，之前的基本操作更多偏向于参考手册的层面，可能还需要修改和调整一下。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://docs.mongodb.com/manual/tutorial/remove-documents/。" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/remove-documents/。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB的基本操作：删除记录（删）。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://www.oxysun.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>JS：逻辑操作符“||”、“&amp;&amp;”和“!”</title>
    <link href="https://www.oxysun.cn/js/js-logical-operator.html"/>
    <id>https://www.oxysun.cn/js/js-logical-operator.html</id>
    <published>2018-07-19T15:00:00.000Z</published>
    <updated>2018-07-29T12:12:38.498Z</updated>
    
    <content type="html"><![CDATA[<p>JS：逻辑操作符“||”、“&amp;&amp;”和“!”。<br><a id="more"></a></p><table><thead><tr><th>Operator</th><th>Usage</th><th>Description</th></tr></thead><tbody><tr><td>Logical AND (&amp;&amp;)</td><td>expr1 &amp;&amp; expr2</td><td>Returns expr1 if it can be converted to false; otherwise, returns expr2. Thus, when used with Boolean values, &amp;&amp; returns true if both operands are true; otherwise, returns false.</td></tr><tr><td>Logical OR (&#124;&#124;)</td><td>expr1 &#124;&#124; expr2</td><td>Returns expr1 if it can be converted to true; otherwise, returns expr2. Thus, when used with Boolean values, &#124;&#124; returns true if either operand is true.</td></tr><tr><td>Logical NOT (!)</td><td>!expr</td><td>Returns false if its single operand can be converted to true; otherwise, returns true.</td></tr></tbody></table><p>翻译一下：</p><table><thead><tr><th>操作符</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>逻辑和 (&amp;&amp;)</td><td>expr1 &amp;&amp; expr2</td><td>如果expr1可以被转换为false，那么返回expr1，否则，返回expr2。 如果使用的是布尔值，那么仅当两个操作数都为真时，返回true；否则，返回false。</td></tr><tr><td>逻辑或 (&#124;&#124;)</td><td>expr1 &#124;&#124; expr2</td><td>如果expr1可以被转换为true，返回expr1；否则，返回expr2。如果是布尔值，则两个操作数中有一个位true就返回true。</td></tr><tr><td>逻辑非 (!)</td><td>!expr</td><td>如果这个操作数可以转换为true，返回false，否则，返回true</td></tr></tbody></table><p>以下这些表达式都可以转换为false：</p><ul><li>null;</li><li>NaN;</li><li>0;</li><li>empty string (“” or ‘’); </li><li>undefined.</li></ul><p><br><br>这样就比较清楚了。</p><p>需要注意的是：操作符有一个优先级的规定，可以参考：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence。" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence。</a></p><p>参考：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators。" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS：逻辑操作符“||”、“&amp;amp;&amp;amp;”和“!”。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.oxysun.cn/categories/JavaScript/"/>
    
    
      <category term="JS,逻辑操作符" scheme="https://www.oxysun.cn/tags/JS-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>程序员晋升之路：生存意识、服务意识--IT老兵的心得</title>
    <link href="https://www.oxysun.cn/thinking%20in%20programmer%20life/full-stack-programmer.html"/>
    <id>https://www.oxysun.cn/thinking in programmer life/full-stack-programmer.html</id>
    <published>2018-07-18T15:15:33.000Z</published>
    <updated>2018-07-22T07:27:09.079Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>这篇文章原载于新浪博客，写于2017-06-06<br>23:15:33，现在因为建立了自己的博客，所以迁过来，也转载在CSDN上，同时又加上“时过境迁”，又会有一些新的思考，所以修改一下，修改的地方以备注的形式展示出来，可以看出一些心态的不同来。</p></blockquote><p>有一个程序员，学过前端、学过iOS，或者这么说，他喜欢研究技术，而且能把所研究的技术都搞得明明白白，但是他做项目，从来不排期，不汇报，也从来不怎么理会产品设计，结果他什么好的产品都做不出来。</p><blockquote><p>这些是在厦门遇到了一个程序员所发出的感想，到了今时今日，据我了解，他还是什么都没有做出来</p></blockquote><p>做不出好的产品来，是一个好的程序员吗？</p><p>技术都会过时的，最新的技术也不见得是最好的技术，那么技术人员的使命是什么呢？</p><p>掌握了那么复杂的C++就算是好的程序员了吗？</p><blockquote><p>实际上，很多年了，C++程序员都缺乏用武之地了—-直到今天的区块链的火热，才又唤起市场对C++程序员的需求。</p></blockquote><p>或者说，现在所鼓吹的全栈，你成为全栈了，就是好的程序员了吗？</p><p>我觉得都不是。</p><p>你用你的能力，掌握了技术，能够很好服务于你的公司，服务于社会，这才是好的程序员。</p><p>技术是为人类服务的，脱离了服务，再尖端的技术又有什么用呢？脱离了服务，掌握了再尖端的技术的程序员，又有什么用呢？</p><p>要使用你的技术，去提供服务，换取你的合理报酬，这就是生存意识。</p><p>掌握社会服务所需要的，或者是将要需要的技术，去提供服务，换取更好的报酬，这就是生存意识。</p><p>固守于一门很复杂的语言，为自己掌握了它而别人没有掌握而沾沾自喜，却不思考这门语言对于提供服务的价值和意义，这就已经完全走偏了，惑于技巧的层面，而忽略了根本的初衷，我们不是为了学技术而学技术的，技术也从来不是为了让你学而产生的。如果一门技术，已经不能很好地服务于社会，那怕它再难，学习起来再有挑战性，对你来说只能是满足征服的快乐，而不是满足你谋生、立业的人生目标。</p><p>放下心中自己围起来的那道技术的篱笆，不拘一格地去掌握那些需要你掌握的技术，做出好的产品来提供你的服务。</p><p>不要太在意这个技术是你新学的，也许掌握的还没有那么扎实，也许写出来的代码还没有那么漂亮，这些都会慢慢变好的，因为你写的代码，做出的产品有人在使用，这就要比那些写的很漂亮，但是没人用，只能束之高阁的代码要强太多了。代码不被使用，再漂亮，也缺乏生命力。</p><blockquote><p>代码也是有生命的，这是我的感觉，所以，我们需要好好去维护她，不断去调整她。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章原载于新浪博客，写于2017-06-06&lt;br&gt;23:15:33，现在
      
    
    </summary>
    
      <category term="程序人生" scheme="https://www.oxysun.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Git：git-checkout的用法总结（1）</title>
    <link href="https://www.oxysun.cn/git/git-checkout-1.html"/>
    <id>https://www.oxysun.cn/git/git-checkout-1.html</id>
    <published>2018-07-17T15:00:00.000Z</published>
    <updated>2018-08-02T00:39:42.484Z</updated>
    
    <content type="html"><![CDATA[<p>Git的git-checkout的用法总结。<br><a id="more"></a></p><h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p><code>git-checkout</code>是<code>Git</code>最常用的命令之一，但又是有些复杂的命令，总会感觉有些用不明白，用不明白的原因应该是没有深度地、全面地理解一下，所以要对它好好整理一下。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>checkout</code>在<code>CVS</code>和<code>SVN</code>中都是检出的意思，从版本库检出一个版本，在<code>Git</code>中就不是这么简单了。手册上是这样介绍的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-checkout - Switch branches or restore working tree files</span><br></pre></td></tr></table></figure><p>在<code>Git</code>里面，<code>checkout</code>用于切换分支或者恢复工作树的文件。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>问题：</strong>线上分支出现了一个问题，急需要修复（可以参看Git Flow一章）。<br><strong>步骤：</strong></p><ol><li>需要创建一个hotfix分支，参考语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;]</span><br></pre></td></tr></table></figure></li></ol><p>实际语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hotfix-1.2.1 master</span><br></pre></td></tr></table></figure></p><p>这个时候分支是本地分支，并没有提交到服务器上去，如果这个分支已经被创建，这个命令会失败，这个时候，如果想要重置这个分支，需要使用<code>-B</code>参数。</p><ol start="2"><li>查看分支：<code>git branch -av</code></li><li>进行修改工作</li><li>……</li></ol><p><strong>问题：</strong>本地发生了一些修改，但是想放弃这些修改，回退到获取这个版本初始时的状态。<br>参考语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br></pre></td></tr></table></figure></p><p>实际语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout 26a2e80 # 26a2e80 是一个commit号，这个命令会把index区域和工作区域的内容都更新</span><br><span class="line">git checkout -- README # README是想恢复的文件名，恢复成index区域里面的内容，为什么要加“--”呢，这个是为了告诉Git，这是一个文件而不是一个分支</span><br><span class="line">Git checkout . # 从index区域恢复所有文件</span><br></pre></td></tr></table></figure></p><p>这个命令很灵活，既可以带一个<code>commit</code>号，又可以带着一个路径，<code>tree-ish</code> 可以理解成一个<code>commit</code>号，就是恢复到某一个<code>commit</code>号，<code>index</code>就是暂存区，这里要理解<code>Git</code>的三个区域，如果这个还不明白，那需要单开一篇文章去讲了。</p><p>以上是checkout比较常用的两个用法，逐步整理其他的用法。</p><p>参考：<a href="https://git-scm.com/docs/git-checkout。" target="_blank" rel="noopener">https://git-scm.com/docs/git-checkout。</a><br><a href="https://stackoverflow.com/questions/14460595/git-checkout-with-dot。" target="_blank" rel="noopener">https://stackoverflow.com/questions/14460595/git-checkout-with-dot。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git的git-checkout的用法总结。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="用法" scheme="https://www.oxysun.cn/tags/%E7%94%A8%E6%B3%95/"/>
    
      <category term="checkout" scheme="https://www.oxysun.cn/tags/checkout/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell命令用法及常见用例：top</title>
    <link href="https://www.oxysun.cn/linux/shell-command-top.html"/>
    <id>https://www.oxysun.cn/linux/shell-command-top.html</id>
    <published>2018-07-13T14:20:23.000Z</published>
    <updated>2018-07-18T11:09:55.845Z</updated>
    
    <content type="html"><![CDATA[<p><code>top</code>命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的使用工具。<code>top</code>命令提供了互动式的界面，用热键管理。这个命令是一个非常重要和常用的命令，但是同时也有点复杂，参数较多，怎么能够掌握好呢？用了这么多年，也都一直没有用好。老老实实读一遍手册，总体了解一下都有什么才好去做整理，有的时候可能连它都有什么功能都不知道。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>top [选项]</code></p><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p><code>top</code>命令用来显示<code>Linux</code>的处理器活动和内核实时管理的任务。它会显示正在使用的处理器和内存以及运行进程等其他信息。</p><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul><li>-b：以批处理模式操作。</li><li>-c：显示完整的命令。</li><li>-d：屏幕刷新间隔时间。</li><li>-I：忽略失效过程。</li><li>-s：保密模式。</li><li>-S：累积模式。</li><li>-i&lt;时间&gt;：设置间隔时间。</li><li>-u&lt;用户名&gt;：指定用户名。</li><li>-p&lt;进程号&gt;：指定进程。</li><li>-n&lt;次数&gt;：循环显示的次数。</li></ul><h2 id="top交互命令"><a href="#top交互命令" class="headerlink" title="top交互命令"></a><code>top</code>交互命令</h2><p>在<code>top</code>命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。</p><ul><li>h：显示帮助画面，给出一些简短的命令总结说明。</li><li>k：终止一个进程。</li><li>i：忽略闲置和僵死进程，这是一个开关式命令。</li><li>q：退出程序。</li><li>r：重新安排一个进程的优先级别。</li><li>S：切换到累计模式。</li><li>s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s。</li><li>f或者F：从当前显示中添加或者删除项目。</li><li>o或者O：改变显示项目的顺序。</li><li>l：切换显示平均负载和启动时间信息。</li><li>m：切换显示内存信息。</li><li>t：切换显示进程和CPU状态信息。</li><li>c：显示进程启动时的完整路径和程序名。</li><li>M：根据驻留内存大小进行排序。</li><li>P：根据CPU使用百分比大小进行排序。</li><li>T：根据时间/累计时间进行排序。</li><li>w：将当前设置写入~/.toprc文件中。</li></ul><h2 id="界面解释"><a href="#界面解释" class="headerlink" title="界面解释"></a>界面解释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 21:52:52 up 247 days,  6:23,  2 users,  load average: 0.09, 0.12, 0.13</span><br><span class="line">Tasks: 126 total,   1 running, 125 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  4.0 us,  2.3 sy,  0.0 ni, 93.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  3881808 total,   153396 free,  3577588 used,   150824 buff/cache</span><br><span class="line">KiB Swap:  4063228 total,  1206484 free,  2856744 used.    86344 avail Mem</span><br></pre></td></tr></table></figure><p>统计信息区前五行是系统整体的统计信息。<br><strong>系统运行时间和平均负载</strong><br>第一行是任务队列信息，同uptime命令的执行结果，可以使用l命令切换uptime的显示。其内容如下：</p><ul><li>21:52:52：当前时间。</li><li>up 247 days, 6:23：系统运行时间。</li><li>2 users：当前登录用户数。</li><li>load average: 0.09, 0.12, 0.13：系统负载，即任务队列平均长度。分别为1、5、15min前到现在平均值。</li></ul><p><strong>进程</strong><br>第二行为进程信息。内容如下：</p><ul><li>126 total：进程总数[键入H可查看线程数]。</li><li>1 running：正在运行的进程。</li><li>125 sleeping：睡眠进程。</li><li>0 stopped：停止的进程。</li><li>0 zombie：僵尸进程数。</li></ul><p><strong>CPU状态</strong><br>第三行为CPU状态信息，当有多个CPU时，这些内容可能会超过两行。内容如下：</p><ul><li>us, user：运行(未调整优先级的) 用户进程的CPU百分比。</li><li>sy，system：运行内核进程的CPU百分比。</li><li>ni，niced：运行已调整优先级的用户进程的CPU百分比。</li><li>wa，IO wait：用于等待IO完成的CPU百分比。</li><li>hi：处理硬件中断的CPU百分比。</li><li>si：处理软件中断的CPU百分比。</li><li>st：这个虚拟机被hypervisor偷去的CPU百分比。（译注：如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）。</li></ul><p><strong>内存使用</strong><br>倒数第2、3行为内存相关信息，内存显示可以用m命令切换：</p><ul><li>KiB Mem: 3881808 total,   153396 free：分别是物理内存总量、空闲内存总量。</li><li>3577588 used,   150824 buff/cache：使用物理内存总量、用作内核缓存内存量。</li><li>KiB Swap: 4063228 total,  1206484 free：分别是交换分区总量、使用交换分区剩余量。</li><li>2856744 used.    86344 avail Mem：可用来启动应用的内存（有些复杂，以后解释，恶意参考<a href="https://unix.stackexchange.com/questions/390518/what-do-the-buff-cache-and-avail-mem-fields-in-top-mean" target="_blank" rel="noopener">这里</a>）。</li></ul><p><strong>字段/列</strong><br>最后一行则是进程相关的资源占用信息：</p><ul><li>PID：进程的ID，进程的唯一标识符。</li><li>USER：进程所有者的实际用户名。</li><li>PR：进程的优先级别，范围0-39，越小越优先被执行。</li><li>NI：nice值。范围-20-19，负值表示高优先级，正值表示低优先级。在top里，PR-NI=20，默认启动一个进程，nice是0。</li><li>VIRT：进程占用的虚拟内存。</li><li>RES：进程占用的物理内存。</li><li>SHR：进程使用的共享内存。</li><li>S：进程的状态。<ul><li>D：表示不可终端的睡眠状态。</li><li>R：表示正在运行。</li><li>S：表示休眠。</li><li>T：表示作业控制信号下已停止。</li><li>t：表示在调试状态的停止。</li><li>Z：表示僵死状态。</li></ul></li><li>%CPU：自从上一次更新到现在任务所使用的CPU使用率。</li><li>%MEM：进程使用的物理内存和总内存的百分比。</li><li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值，精确到百分之一秒。</li><li>COMMAND：进程启动命令名称。</li></ul><h2 id="交互命令实例"><a href="#交互命令实例" class="headerlink" title="交互命令实例"></a>交互命令实例</h2><p><strong>实例：<code>h</code>：帮助</strong><br>描述：在<code>top</code>状态下，按<code>h</code>键或者<code>?</code>键显示交互命令的帮助菜单。<br>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Help for Interactive Commands - procps-ng version 3.3.10</span><br><span class="line">Window 1:Def: Cumulative mode Off.  System: Delay 3.0 secs; Secure mode Off.</span><br><span class="line"></span><br><span class="line">  Z,B,E,e   Global: &apos;Z&apos; colors; &apos;B&apos; bold; &apos;E&apos;/&apos;e&apos; summary/task memory scale</span><br><span class="line">  l,t,m     Toggle Summary: &apos;l&apos; load avg; &apos;t&apos; task/cpu stats; &apos;m&apos; memory info</span><br><span class="line">  0,1,2,3,I Toggle: &apos;0&apos; zeros; &apos;1/2/3&apos; cpus or numa node views; &apos;I&apos; Irix mode</span><br><span class="line">  f,F,X     Fields: &apos;f&apos;/&apos;F&apos; add/remove/order/sort; &apos;X&apos; increase fixed-width</span><br><span class="line"></span><br><span class="line">  L,&amp;,&lt;,&gt; . Locate: &apos;L&apos;/&apos;&amp;&apos; find/again; Move sort column: &apos;&lt;&apos;/&apos;&gt;&apos; left/right</span><br><span class="line">  R,H,V,J . Toggle: &apos;R&apos; Sort; &apos;H&apos; Threads; &apos;V&apos; Forest view; &apos;J&apos; Num justify</span><br><span class="line">  c,i,S,j . Toggle: &apos;c&apos; Cmd name/line; &apos;i&apos; Idle; &apos;S&apos; Time; &apos;j&apos; Str justify</span><br><span class="line">  x,y     . Toggle highlights: &apos;x&apos; sort field; &apos;y&apos; running tasks</span><br><span class="line">  z,b     . Toggle: &apos;z&apos; color/mono; &apos;b&apos; bold/reverse (only if &apos;x&apos; or &apos;y&apos;)</span><br><span class="line">  u,U,o,O . Filter by: &apos;u&apos;/&apos;U&apos; effective/any user; &apos;o&apos;/&apos;O&apos; other criteria</span><br><span class="line">  n,#,^O  . Set: &apos;n&apos;/&apos;#&apos; max tasks displayed; Show: Ctrl+&apos;O&apos; other filter(s)</span><br><span class="line">  C,...   . Toggle scroll coordinates msg for: up,down,left,right,home,end</span><br><span class="line"></span><br><span class="line">  k,r       Manipulate tasks: &apos;k&apos; kill; &apos;r&apos; renice</span><br><span class="line">  d or s    Set update interval</span><br><span class="line">  W,Y       Write configuration file &apos;W&apos;; Inspect other output &apos;Y&apos;</span><br><span class="line">  q         Quit</span><br><span class="line">          ( commands shown with &apos;.&apos; require a visible task display window ) </span><br><span class="line">Press &apos;h&apos; or &apos;?&apos; for help with Windows,</span><br><span class="line">Type &apos;q&apos; or &lt;Esc&gt; to continue</span><br></pre></td></tr></table></figure><p><strong>实例：显示各个CPU负载</strong><br>描述：在<code>top</code>状态下，按下“1”，可以显示每个CPU的负载情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 22:30:09 up 247 days,  7:00,  2 users,  load average: 0.16, 0.14, 0.14</span><br><span class="line">Tasks: 126 total,   1 running, 125 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.3 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu2  :  0.3 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu3  :  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  3881808 total,   141164 free,  3578540 used,   162104 buff/cache</span><br><span class="line">KiB Swap:  4063228 total,  1206756 free,  2856472 used.    79768 avail Mem</span><br></pre></td></tr></table></figure><p><strong>实例：手动刷新</strong><br>描述：在<code>top</code>状态下，按空格或者回车进行手动刷新。top命令默认在一个特定间隔（3秒）后刷新显示。</p><p><strong>实例：<code>A</code>：切换交替显示模式</strong></p><p>描述：在<code>top</code>状态下，按<code>A</code>键，可以在全屏和交替模式间切换。在交替模式下会显示4个窗口。</p><ul><li>Def（默认字段组）</li><li>Job（任务字段组）</li><li>Mem（内存字段组）</li><li>Usr（用户字段组）</li></ul><p>这四组字段共有一个独立的可配置的概括区域和它自己的可配置任务区域。4个窗口中只有一个窗口是当前窗口。当前窗口的名称显示在左上方。只有当前窗口才会接受你键盘交互命令。<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-A.png" alt=""><br>可以用<code>a</code>和<code>w</code>在4个窗口间切换，<code>a</code>移到后一个窗口，<code>w</code>移到前一个窗口。用<code>g</code>命令可以输入一个数字来选择当前窗口。<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-switch.png" alt=""></p><p><strong>实例：<code>B</code>：粗体显示</strong><br>描述：在<code>top</code>状态下，按<code>B</code>键，会将一些重要信息会以加粗字体显示。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-B.png" alt=""></p><p><strong>实例：<code>d</code>或<code>s</code>：设置显示的刷新间隔</strong><br>描述：在<code>top</code>状态下，按<code>d</code>键或者<code>s</code>键，设置显示的刷新间隔为1秒。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-d-s.png" alt=""></p><p><strong>实例：<code>f</code>：字段管理</strong><br>描述：在<code>top</code>状态下，按<code>f</code>键进入字段管理界面。d键选择要显示的字段，用*标记的是已选择的。上下光标键在字段内导航，左光标键可以选择字段，右光标键进入排序状态，此时按上下光标键可以进行上下移动，回车确认。s键设置当前排序的字段，q或Esc键退出。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-f.png" alt=""></p><p><strong>实例：<code>R</code>：反向排序</strong><br>描述：在<code>top</code>状态下，按<code>R</code>键切换反向/常规排序。</p><p><strong>实例：<code>c</code>：切换显示命令名称和完整命令行</strong><br>描述：在<code>top</code>状态下，按<code>c</code>键，切换是否显示进程启动时的完整路径和程序名。也可以使用如下命令行。<br>命令：<code>top -c</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-c.png" alt=""></p><p><strong>实例：<code>i</code>：空闲任务</strong><br>描述：在<code>top</code>状态下，按i键，切换显示空闲任务。<br>输出：<br>不显示空闲任务：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-i.png" alt=""></p><p><strong>实例：<code>V</code>：树视图</strong><br>描述：在<code>top</code>状态下，按V键，切换树视图。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-V.png" alt=""></p><p><strong>实例：<code>z</code>：切换彩色显示</strong><br>描述：在<code>top</code>状态下，按<code>z</code>键，切换彩色，即打开或关闭彩色显示。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-z-normal.png" alt=""></p><p><strong>实例：<code>Z</code>：改变配色</strong><br>描述：在<code>top</code>状态下，按<code>Z</code>键，显示一个改变<code>top</code>命令的输出颜色的屏幕。可以为8个任务区域选择8种颜色。<br>输出：<br>设置修改：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-Z.png" alt=""><br>显示效果：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-Z-show.png" alt=""></p><p><strong>实例：按照内存使用大小排序</strong><br>描述：在<code>top</code>状态下，按shift+m，可以按照内存使用大小排序进程。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-M.png" alt=""></p><p><strong>实例：<code>x、y</code>：切换高亮信息</strong><br>描述：在<code>top</code>状态下，按<code>x</code>键将排序字段高亮显示（纵列）；按<code>y</code>键将运行进程高亮显示（横行）。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-x-y.png" alt=""></p><p><strong>实例：<code>u</code>：特定用户的进程</strong><br>描述：在<code>top</code>状态下，按u键将会提示输入用户名，输入首显示特定用户的进程。空白将会显示全部用户。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-u.png" alt=""></p><p><strong>实例：<code>n或#</code>：任务的数量</strong><br>描述：在<code>top</code>状态下，按n键或者<code>#</code>键可以设置最大显示的任务数量。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-n-#.png" alt=""></p><p><strong>实例：<code>k</code>：结束任务</strong><br>描述：在<code>top</code>状态下，按<code>k</code>键输入<code>PID</code>后，发送信号给任务（通常是结束任务）。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-k.png" alt=""></p><p><strong>实例：<code>r</code>：重新设置优先级</strong><br>描述：在<code>top</code>状态下，按<code>r</code>键输入-20~19范围中的数字后，重新设置一个任务的调度优先级（nice值）。<br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-k.png" alt=""></p><h2 id="命令行实例"><a href="#命令行实例" class="headerlink" title="命令行实例"></a>命令行实例</h2><p><strong>实例：<code>-p</code>：监控特定的PID</strong><br>描述：-p选项监控指定的PID。PID的值为0将被作为top命令自身的PID。<br>命令：<code>top -p 0</code></p><p><strong>实例：<code>-u或-U</code>: 用户名或者UID</strong><br>描述：可以用这些选项浏览特定用户的进程。用户名或者UID可以在选项中指定。-p、-u和-U选项是互斥的，同时只可以使用这其中一个选项。试图组合使用这些选项时，会得到一个错误:<br>命令：<code>top -p 1248 -u root</code><br>输出：<br><img src="http://p9xqnn501.bkt.clouddn.com/top/top-U-p-u-error.png" alt=""></p><p><strong>实例：<code>-b</code>：批处理模式</strong><br>描述：-b选项以批处理模式启动top命令，在文件中保存输出时是很有用的。</p><p><strong>实例：<code>-c</code>：命令/程序名 触发:</strong><br>描述：显示进程启动时的完整路径和程序名。</p><p><strong>实例：<code>-d</code>：设置延迟间隔</strong><br>描述：设置top的显示间隔(以秒计)。<br>命令：<code>top -d 1</code></p><p><strong>实例：<code>-i</code>：切换显示空闲进程</strong><br>命令：<code>top -i</code></p><p><strong>实例：<code>-n</code>：特定重复次数后退出</strong><br>描述：top输出保持刷新，直到按q键或者到达指定次数。下面的命令将在10次重复之后自动退出。<br>命令：<code>top -n 10</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;top&lt;/code&gt;命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的使用工具。&lt;code&gt;top&lt;/code&gt;命令提供了互动式的界面，用热键管理。这个命令是一个非常重要和常用的命令，但是同时也有点复杂，参数较多，怎么能够掌握好呢？用了这么多年，也都一直没有用好。老老实实读一遍手册，总体了解一下都有什么才好去做整理，有的时候可能连它都有什么功能都不知道。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Shell" scheme="https://www.oxysun.cn/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git：Git merge的--ff和--no-ff</title>
    <link href="https://www.oxysun.cn/git/git-git-merge-ff-no-ff.html"/>
    <id>https://www.oxysun.cn/git/git-git-merge-ff-no-ff.html</id>
    <published>2018-07-12T14:07:00.000Z</published>
    <updated>2018-08-02T00:39:42.486Z</updated>
    
    <content type="html"><![CDATA[<p>Git：Git-merge的–ff和–no-ff。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git merge最容易糊涂的地方就是这个<code>--ff</code>参数和<code>--no-ff</code> 参数，通过本文，把这个整理清楚。</p><p>其实官网讲的非常清楚，不过可能因为是英文的，所以大家阅读起来会有一些障碍。（PS：其实还是应该逐步逐步提高自己阅读英文文档的能力，想达到一个更高的高度，是需要客服自己本身很多的弱点的）</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>假设合并前的分支是这样，这个一个非常常见的场景，如果不明白，可以参考另外一篇文章Git Flow工作流：<br><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="这里写图片描述"><br>这是一个很常见的用例，功能开发分支是<code>iss53</code>，在开发新功能，<code>master</code>分支是线上分支，出现了问题，开辟了<code>hotfix</code>分支进行修复，修复完成，进行合并，需要把<code>hotfix</code>合并回<code>master</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>步骤如下：</p><ol><li>切换回master分支。</li><li>将hotfix分支合并会master分支。<br>然后看到了<code>Fast-forward</code> 的字样，这个词组的意思就是快进，播放电影的时候，可以注意一下，快进按钮上面就是这个词组。<br>那么实际变成了什么样呢？<br><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt="这里写图片描述"><br>仅仅是<code>master</code>指针指向了这个提交<code>C4</code>。这样是一种比较快的合并方式，轻量级，简单。<br>这个时候，我们往往会删掉<code>hotfix</code>分支，因为它的历史作用已经结束，这个时候，我们的<code>iss53</code>这个功能又向前开发，进行了一次提交，到了<code>C5</code>，那么变成了这样：<br><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="这里写图片描述"><br>然后，我们要把<code>iss53</code> 这个分支合并回<code>master</code>，就变成了这样：<br><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="这里写图片描述"><br>这个时候生成了一个新的<code>commit</code>号，这种提交就不是<code>fast-forward</code>（这个时候也无法生成<code>fast-forward</code>提交，因为要将两个版本的内容进行合并，只有在没有需要合并内容的时候，会有这个<code>fast-forward</code> 方式的提交）。<br>如果我们对第一次合并，使用了<code>--no-ff</code>参数，那么也会产生这样的结果，生成一个新的提交，实际上等于是对<code>C4</code> 进行一次复制，创建一个新的<code>commit</code>，这就是<code>--no-ff</code>的作用。<br><img src="https://i.stack.imgur.com/FMD5h.png" alt="这里写图片描述"></li></ol><p>参考：<a href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging，这里讲了原理。" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging，这里讲了原理。</a><br>参考：<a href="https://git-scm.com/docs/git-merge，这里是参考。" target="_blank" rel="noopener">https://git-scm.com/docs/git-merge，这里是参考。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git：Git-merge的–ff和–no-ff。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.oxysun.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.oxysun.cn/tags/Git/"/>
    
      <category term="git merge" scheme="https://www.oxysun.cn/tags/git-merge/"/>
    
      <category term="ff" scheme="https://www.oxysun.cn/tags/ff/"/>
    
      <category term="no-ff" scheme="https://www.oxysun.cn/tags/no-ff/"/>
    
      <category term="fast forward" scheme="https://www.oxysun.cn/tags/fast-forward/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu：新增和删除用户</title>
    <link href="https://www.oxysun.cn/linux/ubuntu-user-add-delete.html"/>
    <id>https://www.oxysun.cn/linux/ubuntu-user-add-delete.html</id>
    <published>2018-07-12T03:15:00.000Z</published>
    <updated>2018-07-18T11:09:55.846Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu：新增和删除用户，修改用户组信息。<br><a id="more"></a><br>参考：<a href="https://www.digitalocean.com/community/tutorials/how-to-add-and-delete-users-on-ubuntu-16-04#how-to-delete-a-user。" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-add-and-delete-users-on-ubuntu-16-04#how-to-delete-a-user。</a></p><p><code>Linux</code>上root用户是权力最大的用户，但是也非常危险，处于安全考虑，增加个人用户是必要的方法，下文讲了讲在<code>Ubuntu</code>上如何新增和删除用户。</p><h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><p><strong>实例：</strong> <code>root</code>用户新增用户<code>chenming</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# adduser chenming</span><br><span class="line">Adding user `chenming&apos; ...</span><br><span class="line">Adding new group `chenming&apos; (1000) ...</span><br><span class="line">Adding new user `chenming&apos; (1000) with group `chenming&apos; ...</span><br><span class="line">Creating home directory `/home/chenming&apos; ...</span><br><span class="line">Copying files from `/etc/skel&apos; ...</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for chenming</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">Full Name []: </span><br><span class="line">Room Number []: </span><br><span class="line">Work Phone []: </span><br><span class="line">Home Phone []: </span><br><span class="line">Other []: </span><br><span class="line">Is the information correct? [Y/n] y</span><br></pre></td></tr></table></figure></p><p>首先创建了一个新的用户组<code>chenming</code>。<br>在这个组内新建了用户<code>chenming</code>。<br>要求你输入密码。<br>要求输入一些其他信息，可以按回车略过。<br>最后按下<code>y</code>对以上信息进行确认。</p><p><strong>实例：</strong>非<code>root</code>用户新增用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo adduser chenming</span><br></pre></td></tr></table></figure><h1 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h1><p><strong>实例：</strong>把<code>chenming</code>加到<code>sudo</code>组里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# groups chenming</span><br><span class="line">chenming : chenming</span><br></pre></td></tr></table></figure><p>可以看到，<code>chenming</code>只在<code>chenming</code>的组里面（前面是用户名，冒号后面是组名）。在这个组里面，可能很多命令你都不能执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# usermod -aG sudo chenming</span><br></pre></td></tr></table></figure><p>再来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# groups chenming</span><br><span class="line">chenming : chenming sudo</span><br></pre></td></tr></table></figure><p>look，进入了sudo组了，这下你可以臭屁了。</p><p>还有一种方法可以加入<code>sodu</code>组。<br>如果是<code>root</code>用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# visudo</span><br></pre></td></tr></table></figure></p><p>这个时候会打开一个文本编辑器，去编辑<code>/etc/sudoer</code>这个文件，可能是<code>vim</code>，也可能是<code>nano</code>。<br>找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>在下面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chenming ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>保存（vim下是<code>:x</code>，<code>nano</code>下是<code>ctrl+x</code>），退出，这样<code>chenming</code>这个用户就加入了<code>sudo</code>组。</p><h1 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h1><p>仅仅删除用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# deluser chenming</span><br><span class="line">Removing user `chenming&apos; ...</span><br><span class="line">Warning: group `chenming&apos; has no more members.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure></p><p>将用户的目录也删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@iZhp3fz3iqsadyes2s8ay8Z:~# deluser --remove-home chenming</span><br></pre></td></tr></table></figure></p><p>但这个时候，这个已经被删除的用户还是在<code>sudo</code>组里面。<br>参照上面的过程，使用visudo命令，删掉增加的那一行即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu：新增和删除用户，修改用户组信息。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.oxysun.cn/categories/Linux/"/>
    
      <category term="Ubuntu" scheme="https://www.oxysun.cn/categories/Linux/Ubuntu/"/>
    
    
      <category term="Linux" scheme="https://www.oxysun.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
